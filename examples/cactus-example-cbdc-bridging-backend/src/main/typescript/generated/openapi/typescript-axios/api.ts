/* tslint:disable */
/* eslint-disable */
/**
 * CBDC-example backend API
 * Cactus-Example 
 *
 * The version of the OpenAPI document: 0.0.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Request schema for approving a transaction.
 * @export
 * @interface ApproveRequest
 */
export interface ApproveRequest {
    /**
     * 
     * @type {string}
     * @memberof ApproveRequest
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof ApproveRequest
     */
    'amount': string;
    /**
     * 
     * @type {TransactRequestSourceChain}
     * @memberof ApproveRequest
     */
    'ledger': TransactRequestSourceChain;
}
/**
 * Response schema for an amount request.
 * @export
 * @interface GetBalance200Response
 */
export interface GetBalance200Response {
    /**
     * 
     * @type {string}
     * @memberof GetBalance200Response
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface GetSessionsReferences200ResponseInner
 */
export interface GetSessionsReferences200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetSessionsReferences200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetSessionsReferences200ResponseInner
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof GetSessionsReferences200ResponseInner
     */
    'sourceLedger': string;
    /**
     * 
     * @type {string}
     * @memberof GetSessionsReferences200ResponseInner
     */
    'receiverLedger': string;
}
/**
 * Request schema for minting an asset.
 * @export
 * @interface MintRequest
 */
export interface MintRequest {
    /**
     * 
     * @type {string}
     * @memberof MintRequest
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof MintRequest
     */
    'amount': string;
    /**
     * 
     * @type {TransactRequestSourceChain}
     * @memberof MintRequest
     */
    'ledger': TransactRequestSourceChain;
}
/**
 * Response schema for a transaction request.
 * @export
 * @interface Transact200Response
 */
export interface Transact200Response {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof Transact200Response
     */
    'statusResponse': Transact200ResponseStatusResponse;
}
/**
 * Response schema for a transaction status request.
 * @export
 * @interface Transact200ResponseStatusResponse
 */
export interface Transact200ResponseStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof Transact200ResponseStatusResponse
     */
    'sessionID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transact200ResponseStatusResponse
     */
    'status': Transact200ResponseStatusResponseStatusEnum;
}

export const Transact200ResponseStatusResponseStatusEnum = {
    NotFound: 'NOT_FOUND',
    Invalid: 'INVALID',
    Pending: 'PENDING',
    Done: 'DONE',
    Failed: 'FAILED'
} as const;

export type Transact200ResponseStatusResponseStatusEnum = typeof Transact200ResponseStatusResponseStatusEnum[keyof typeof Transact200ResponseStatusResponseStatusEnum];

/**
 * An Error
 * @export
 * @interface TransactDefaultResponse
 */
export interface TransactDefaultResponse {
    /**
     * HTTP error type
     * @type {string}
     * @memberof TransactDefaultResponse
     */
    'type': string;
    /**
     * Numeric error code
     * @type {number}
     * @memberof TransactDefaultResponse
     */
    'code': number;
    /**
     * HTTP status of the error
     * @type {number}
     * @memberof TransactDefaultResponse
     */
    'status': number;
    /**
     * Long error description
     * @type {string}
     * @memberof TransactDefaultResponse
     */
    'message': string;
    /**
     * Timestamp of the error
     * @type {string}
     * @memberof TransactDefaultResponse
     */
    'timestamp': string;
}
/**
 * Request schema for initiating a transaction. Includes details such as the transaction context, mode (data or transfer), payload, and information about the source and receiver DLT networks.
 * @export
 * @interface TransactRequest
 */
export interface TransactRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'sender': string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'receiver': string;
    /**
     * 
     * @type {TransactRequestSourceChain}
     * @memberof TransactRequest
     */
    'sourceChain': TransactRequestSourceChain;
    /**
     * 
     * @type {TransactRequestSourceChain}
     * @memberof TransactRequest
     */
    'receiverChain': TransactRequestSourceChain;
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'amount': string;
}
/**
 * Enum for the type of asset being transferred.
 * @export
 * @interface TransactRequestSourceChain
 */
export interface TransactRequestSourceChain {
    /**
     * 
     * @type {string}
     * @memberof TransactRequestSourceChain
     */
    'assetType'?: TransactRequestSourceChainAssetTypeEnum;
}

export const TransactRequestSourceChainAssetTypeEnum = {
    Fabric: 'FABRIC',
    Besu: 'BESU'
} as const;

export type TransactRequestSourceChainAssetTypeEnum = typeof TransactRequestSourceChainAssetTypeEnum[keyof typeof TransactRequestSourceChainAssetTypeEnum];

/**
 * Request schema for transferring an asset.
 * @export
 * @interface TransferRequest
 */
export interface TransferRequest {
    /**
     * 
     * @type {string}
     * @memberof TransferRequest
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof TransferRequest
     */
    'to': string;
    /**
     * 
     * @type {TransactRequestSourceChain}
     * @memberof TransferRequest
     */
    'sourceChain': TransactRequestSourceChain;
    /**
     * 
     * @type {TransactRequestSourceChain}
     * @memberof TransferRequest
     */
    'receiverChain': TransactRequestSourceChain;
    /**
     * 
     * @type {string}
     * @memberof TransferRequest
     */
    'amount': string;
}

/**
 * ApproveApi - axios parameter creator
 * @export
 */
export const ApproveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approves a certain amount to be transferred from the user\'s account by the bridge.
         * @summary Submit a transaction intent
         * @param {ApproveRequest} approveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve: async (approveRequest: ApproveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approveRequest' is not null or undefined
            assertParamExists('approve', 'approveRequest', approveRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-example-cbdc/approve-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(approveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApproveApi - functional programming interface
 * @export
 */
export const ApproveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApproveApiAxiosParamCreator(configuration)
    return {
        /**
         * Approves a certain amount to be transferred from the user\'s account by the bridge.
         * @summary Submit a transaction intent
         * @param {ApproveRequest} approveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approve(approveRequest: ApproveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approve(approveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApproveApi.approve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApproveApi - factory interface
 * @export
 */
export const ApproveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApproveApiFp(configuration)
    return {
        /**
         * Approves a certain amount to be transferred from the user\'s account by the bridge.
         * @summary Submit a transaction intent
         * @param {ApproveRequest} approveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve(approveRequest: ApproveRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.approve(approveRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApproveApi - object-oriented interface
 * @export
 * @class ApproveApi
 * @extends {BaseAPI}
 */
export class ApproveApi extends BaseAPI {
    /**
     * Approves a certain amount to be transferred from the user\'s account by the bridge.
     * @summary Submit a transaction intent
     * @param {ApproveRequest} approveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApproveApi
     */
    public approve(approveRequest: ApproveRequest, options?: RawAxiosRequestConfig) {
        return ApproveApiFp(this.configuration).approve(approveRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GetAmountApprovedApi - axios parameter creator
 * @export
 */
export const GetAmountApprovedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the amount approved for a transaction
         * @summary Get the amount approved for a transaction
         * @param {string} [user] 
         * @param {GetAmountApprovedChainEnum} [chain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAmountApproved: async (user?: string, chain?: GetAmountApprovedChainEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/@hyperledger/cactus-example-cbdc/get-amount-approved`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (chain !== undefined) {
                localVarQueryParameter['chain'] = chain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetAmountApprovedApi - functional programming interface
 * @export
 */
export const GetAmountApprovedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetAmountApprovedApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the amount approved for a transaction
         * @summary Get the amount approved for a transaction
         * @param {string} [user] 
         * @param {GetAmountApprovedChainEnum} [chain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAmountApproved(user?: string, chain?: GetAmountApprovedChainEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAmountApproved(user, chain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GetAmountApprovedApi.getAmountApproved']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GetAmountApprovedApi - factory interface
 * @export
 */
export const GetAmountApprovedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetAmountApprovedApiFp(configuration)
    return {
        /**
         * Get the amount approved for a transaction
         * @summary Get the amount approved for a transaction
         * @param {string} [user] 
         * @param {GetAmountApprovedChainEnum} [chain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAmountApproved(user?: string, chain?: GetAmountApprovedChainEnum, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getAmountApproved(user, chain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetAmountApprovedApi - object-oriented interface
 * @export
 * @class GetAmountApprovedApi
 * @extends {BaseAPI}
 */
export class GetAmountApprovedApi extends BaseAPI {
    /**
     * Get the amount approved for a transaction
     * @summary Get the amount approved for a transaction
     * @param {string} [user] 
     * @param {GetAmountApprovedChainEnum} [chain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetAmountApprovedApi
     */
    public getAmountApproved(user?: string, chain?: GetAmountApprovedChainEnum, options?: RawAxiosRequestConfig) {
        return GetAmountApprovedApiFp(this.configuration).getAmountApproved(user, chain, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAmountApprovedChainEnum = {
    Fabric: 'FABRIC',
    Besu: 'BESU'
} as const;
export type GetAmountApprovedChainEnum = typeof GetAmountApprovedChainEnum[keyof typeof GetAmountApprovedChainEnum];


/**
 * GetBalanceApi - axios parameter creator
 * @export
 */
export const GetBalanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [user] 
         * @param {GetBalanceChainEnum} [chain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (user?: string, chain?: GetBalanceChainEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/@hyperledger/cactus-example-cbdc/get-balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (chain !== undefined) {
                localVarQueryParameter['chain'] = chain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetBalanceApi - functional programming interface
 * @export
 */
export const GetBalanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetBalanceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [user] 
         * @param {GetBalanceChainEnum} [chain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(user?: string, chain?: GetBalanceChainEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalance200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalance(user, chain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GetBalanceApi.getBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GetBalanceApi - factory interface
 * @export
 */
export const GetBalanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetBalanceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [user] 
         * @param {GetBalanceChainEnum} [chain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(user?: string, chain?: GetBalanceChainEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetBalance200Response> {
            return localVarFp.getBalance(user, chain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetBalanceApi - object-oriented interface
 * @export
 * @class GetBalanceApi
 * @extends {BaseAPI}
 */
export class GetBalanceApi extends BaseAPI {
    /**
     * 
     * @param {string} [user] 
     * @param {GetBalanceChainEnum} [chain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetBalanceApi
     */
    public getBalance(user?: string, chain?: GetBalanceChainEnum, options?: RawAxiosRequestConfig) {
        return GetBalanceApiFp(this.configuration).getBalance(user, chain, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetBalanceChainEnum = {
    Fabric: 'FABRIC',
    Besu: 'BESU'
} as const;
export type GetBalanceChainEnum = typeof GetBalanceChainEnum[keyof typeof GetBalanceChainEnum];


/**
 * GetSessionsReferencesApi - axios parameter creator
 * @export
 */
export const GetSessionsReferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the status of a SATP sessions of a gateway
         * @summary Get SATP current sessions data
         * @param {GetSessionsReferencesLedgerEnum} [ledger] Unique identifier for the session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsReferences: async (ledger?: GetSessionsReferencesLedgerEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/@hyperledger/cactus-example-cbdc/get-sessions-references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ledger !== undefined) {
                localVarQueryParameter['Ledger'] = ledger;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetSessionsReferencesApi - functional programming interface
 * @export
 */
export const GetSessionsReferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetSessionsReferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the status of a SATP sessions of a gateway
         * @summary Get SATP current sessions data
         * @param {GetSessionsReferencesLedgerEnum} [ledger] Unique identifier for the session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionsReferences(ledger?: GetSessionsReferencesLedgerEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetSessionsReferences200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionsReferences(ledger, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GetSessionsReferencesApi.getSessionsReferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GetSessionsReferencesApi - factory interface
 * @export
 */
export const GetSessionsReferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetSessionsReferencesApiFp(configuration)
    return {
        /**
         * Retrieve the status of a SATP sessions of a gateway
         * @summary Get SATP current sessions data
         * @param {GetSessionsReferencesLedgerEnum} [ledger] Unique identifier for the session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsReferences(ledger?: GetSessionsReferencesLedgerEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetSessionsReferences200ResponseInner>> {
            return localVarFp.getSessionsReferences(ledger, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetSessionsReferencesApi - object-oriented interface
 * @export
 * @class GetSessionsReferencesApi
 * @extends {BaseAPI}
 */
export class GetSessionsReferencesApi extends BaseAPI {
    /**
     * Retrieve the status of a SATP sessions of a gateway
     * @summary Get SATP current sessions data
     * @param {GetSessionsReferencesLedgerEnum} [ledger] Unique identifier for the session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetSessionsReferencesApi
     */
    public getSessionsReferences(ledger?: GetSessionsReferencesLedgerEnum, options?: RawAxiosRequestConfig) {
        return GetSessionsReferencesApiFp(this.configuration).getSessionsReferences(ledger, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetSessionsReferencesLedgerEnum = {
    Fabric: 'FABRIC',
    Besu: 'BESU'
} as const;
export type GetSessionsReferencesLedgerEnum = typeof GetSessionsReferencesLedgerEnum[keyof typeof GetSessionsReferencesLedgerEnum];


/**
 * MintApi - axios parameter creator
 * @export
 */
export const MintApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {MintRequest} mintRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mint: async (mintRequest: MintRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintRequest' is not null or undefined
            assertParamExists('mint', 'mintRequest', mintRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-example-cbdc/mint-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mintRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MintApi - functional programming interface
 * @export
 */
export const MintApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MintApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {MintRequest} mintRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mint(mintRequest: MintRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mint(mintRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MintApi.mint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MintApi - factory interface
 * @export
 */
export const MintApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MintApiFp(configuration)
    return {
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {MintRequest} mintRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mint(mintRequest: MintRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.mint(mintRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MintApi - object-oriented interface
 * @export
 * @class MintApi
 * @extends {BaseAPI}
 */
export class MintApi extends BaseAPI {
    /**
     * Allows users to queue intents for transactions based on specified parameters.
     * @summary Submit a transaction intent
     * @param {MintRequest} mintRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MintApi
     */
    public mint(mintRequest: MintRequest, options?: RawAxiosRequestConfig) {
        return MintApiFp(this.configuration).mint(mintRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactApi - axios parameter creator
 * @export
 */
export const TransactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {TransactRequest} transactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transact: async (transactRequest: TransactRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactRequest' is not null or undefined
            assertParamExists('transact', 'transactRequest', transactRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-example-cbdc/transact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactApi - functional programming interface
 * @export
 */
export const TransactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {TransactRequest} transactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transact(transactRequest: TransactRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transact(transactRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactApi.transact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactApi - factory interface
 * @export
 */
export const TransactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactApiFp(configuration)
    return {
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {TransactRequest} transactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transact(transactRequest: TransactRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transact200Response> {
            return localVarFp.transact(transactRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactApi - object-oriented interface
 * @export
 * @class TransactApi
 * @extends {BaseAPI}
 */
export class TransactApi extends BaseAPI {
    /**
     * Allows users to queue intents for transactions based on specified parameters.
     * @summary Submit a transaction intent
     * @param {TransactRequest} transactRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactApi
     */
    public transact(transactRequest: TransactRequest, options?: RawAxiosRequestConfig) {
        return TransactApiFp(this.configuration).transact(transactRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransferApi - axios parameter creator
 * @export
 */
export const TransferApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {TransferRequest} transferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transfer: async (transferRequest: TransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferRequest' is not null or undefined
            assertParamExists('transfer', 'transferRequest', transferRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-example-cbdc/transfer-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransferApi - functional programming interface
 * @export
 */
export const TransferApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransferApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {TransferRequest} transferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transfer(transferRequest: TransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transfer(transferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransferApi.transfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransferApi - factory interface
 * @export
 */
export const TransferApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransferApiFp(configuration)
    return {
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {TransferRequest} transferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transfer(transferRequest: TransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.transfer(transferRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransferApi - object-oriented interface
 * @export
 * @class TransferApi
 * @extends {BaseAPI}
 */
export class TransferApi extends BaseAPI {
    /**
     * Allows users to queue intents for transactions based on specified parameters.
     * @summary Submit a transaction intent
     * @param {TransferRequest} transferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransferApi
     */
    public transfer(transferRequest: TransferRequest, options?: RawAxiosRequestConfig) {
        return TransferApiFp(this.configuration).transfer(transferRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



