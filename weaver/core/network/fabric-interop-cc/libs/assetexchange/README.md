<!--
 Copyright IBM Corp. All Rights Reserved.

 SPDX-License-Identifier: CC-BY-4.0
 -->
# Asset Exchange Library

The asset exchange library within the Weaver chaincode package offers two sets of APIs to manage asset locks and claims for a cross-ledger asset exchange. In one set, the transactions take a unique contract ID referring to an asset exchange instance as parameter. This contract ID is generated by the Weaver chaincode when the first asset is locked (as per the protocol steps), and returned to the calling application client. Though you must use contract ID-based API functions for fungible assets, you may also use them for non-fungible assets. For non-fungible assets, Weaver also provides a parallel set of API functions that take asset type and ID as parameters rather than a temporarily generated contract ID.

To use this library, in you smart contract `go.mod`, add following in require (update the version according to the latest module version):
```
require(
    ...
    github.com/hyperledger-labs/weaver-dlt-interoperability/common/protos-go v1.5.3
    github.com/hyperledger-labs/weaver-dlt-interoperability/core/network/fabric-interop-cc/libs/assetexchange v1.5.3
    ...
)
```

## With ContractId

Atleast following 5 functions needs to be added in chaincode (Note: the function signature, i.e. the name,  arguments and return values needs to be exactly same):
1. **LockAsset**
  ```go
  import (
      ...
      "github.com/hyperledger-labs/weaver-dlt-interoperability/core/network/fabric-interop-cc/libs/assetexchange"
  )
  func (s *SmartContract) LockAsset(ctx contractapi.TransactionContextInterface, assetExchangeAgreementSerializedProto64 string, lockInfoSerializedProto64 string) (string, error) {
      // Add some safety checks before calling LockAsset from library
      // Caller of this chaincode is supposed to be the Locker and the owner of the asset being locked.
      contractId, err := assetexchange.LockAsset(ctx, "", assetExchangeAgreementSerializedProto64, lockInfoSerializedProto64)
      if err != nil {
          return "", logThenErrorf(err.Error())
      }
      // Post proccessing of asset after LockAsset called like change status of the asset so that it can't be spent.
      
      return contractId, nil
  }
  ```
  Here `assetExchangeAgreementSerializedProto64` is serialized protobuf in base64 encoded string of `AssetExchangeAgreement` protobuf structure, and can be used to extract details like asset id, type of asset and recipient. Check the structure definition [here](https://github.com/hyperledger-labs/weaver-dlt-interoperability/blob/main/rfcs/formats/assets/exchange.md#representing-two-party-asset-exchange-agreements). 
  Similarly `lockInfoSerializedProto64` is serialized protobuf in base64 encoded string of `AssetLock` protobuf structure. Check the structure definition [here](https://github.com/hyperledger-labs/weaver-dlt-interoperability/blob/main/rfcs/formats/assets/exchange.md#representing-locks-on-assets).
  
2. **LockFungibleAsset**
  ```go
  func (s *SmartContract) LockFungibleAsset(ctx contractapi.TransactionContextInterface, fungibleAssetExchangeAgreementSerializedProto64 string, lockInfoSerializedProto64 string) (string, error) {
      // Add some safety checks before calling LockFungibleAsset from library
      // Caller of this chaincode is supposed to be the Locker and the owner of the asset being locked.
      contractId, err := assetexchange.LockFungibleAsset(ctx, "", fungibleAssetExchangeAgreementSerializedProto64, lockInfoSerializedProto64)
      if err != nil {
          return "", logThenErrorf(err.Error())
      }
      // Post proccessing of asset after LockFungibleAsset called like reduce the amount of tokens owned by the locker, or mark it locked so that it can't be spent.
      
      return contractId, nil
  }
  ```
  Here `fungibleAssetExchangeAgreementSerializedProto64` is serialized protobuf in base64 encoded string of `FungibleAssetExchangeAgreement` protobuf structure, and can be used to extract details like asset quantity, type of asset and recipient. Check the structure definition [here](https://github.com/hyperledger-labs/weaver-dlt-interoperability/blob/main/rfcs/formats/assets/exchange.md#representing-two-party-asset-exchange-agreements).
  
3. **IsAssetLockedQueryUsingContractId**
  ```go
  func (s *SmartContract) IsAssetLockedQueryUsingContractId(ctx contractapi.TransactionContextInterface, contractId string) (bool, error) {
      return assetexchange.IsAssetLockedQueryUsingContractId(ctx, contractId)
  }
  ```
  
4. **ClaimAssetUsingContractId**
  ```go
  func (s *SmartContract) ClaimAssetUsingContractId(ctx contractapi.TransactionContextInterface, contractId, claimInfoSerializedProto64 string) (bool, error) {
      // Note recipient will be the caller for this function
      claimed := false
      err := assetexchange.ClaimAssetUsingContractId(ctx, contractId, claimInfoSerializedProto64)
      if err != nil {
          return false, logThenErrorf(err.Error())
      }
      claimed = true
      // After the above function call, update the owner of the asset with recipeint/caller
      
      return claimed, nil
  }
  ```
  
5. **UnlockAssetUsingContractId**
  ```go
  func (s *SmartContract) UnlockAssetUsingContractId(ctx contractapi.TransactionContextInterface, contractId string) (bool, error) {
      unlocked := false
      err := assetexchange.UnlockAssetUsingContractId(ctx, contractId)
      if err != nil {
          return false, logThenErrorf(err.Error())
      }
      unlocked = true
      ...
      ...
      return true, nil
  }
  ```

6. Add following extra utility functions as well:
  ```go
  func (s *SmartContract) GetHTLCHashByContractId(ctx contractapi.TransactionContextInterface, contractId string) (string, error) {
      return assetexchange.GetHTLCHashByContractId(ctx, contractId)
  }
  func (s *SmartContract) GetHTLCHashPreImageByContractId(ctx contractapi.TransactionContextInterface, contractId string) (string, error) {
      return assetexchange.GetHTLCHashPreImageByContractId(ctx, contractId)
  }
  ```

## Without ContractId:

1. *LockAsset*: This will be same as in "With ContractId" section.

2. *LockFungibleAsset*: This will also be same as in "With ContractId" section.

3. *IsAssetLocked*
```go
func (s *SmartContract) IsAssetLocked(ctx contractapi.TransactionContextInterface, assetAgreementSerializedProto64 string) (bool, error) {
    return assetexchange.IsAssetLocked(ctx, "", assetAgreementSerializedProto64)
}
```

5. *IsFungibleAssetLocked*
```go
func (s *SmartContract) IsFungibleAssetLocked(ctx contractapi.TransactionContextInterface, contractId string) (bool, error) {
    return assetexchange.IsFungibleAssetLocked(ctx, contractId)
}
```

6. *ClaimAsset*
```go
func (s *SmartContract) ClaimAsset(ctx contractapi.TransactionContextInterface, assetAgreementSerializedProto64 string, claimInfoSerializedProto64 string) (bool, error) {
    // Note recipient will be the caller for this function
    claimed := false
    claimed, err = assetexchange.ClaimAsset(ctx, "", assetAgreementSerializedProto64, claimInfoSerializedProto64)
    if err != nil {
        return false, logThenErrorf(err.Error())
    }
    // After the above function call, update the owner of the asset with recipeint/caller
    
    return claimed, nil
}
```

8. *ClaimFungibleAsset*
```go
func (s *SmartContract) ClaimFungibleAsset(ctx contractapi.TransactionContextInterface, contractId, claimInfoSerializedProto64 string) (bool, error) {
    // Note recipient will be the caller for this function
    claimed := false
    err := assetexchange.ClaimAssetUsingContractId(ctx, contractId, claimInfoSerializedProto64)
    if err != nil {
        return false, logThenErrorf(err.Error())
    }
    claimed = true
    // After the above function call, update the owner of the asset with recipeint/caller
    
    return claimed, nil
}
```

9. *UnlockAsset*
```go
func (s *SmartContract) UnlockAsset(ctx contractapi.TransactionContextInterface, assetAgreementSerializedProto64 string) (bool, error) {
    unlocked := false
    unlocked, err = assetexchange.UnlockAsset(ctx, "", assetAgreementSerializedProto64)
    if err != nil {
        return false, logThenErrorf(err.Error())
    }
    ...
    ...
    return true, nil
}
```

11. *UnlockFungibleAsset*
```go
func (s *SmartContract) UnlockFungibleAsset(ctx contractapi.TransactionContextInterface, contractId string) (bool, error) {
    unlocked := false
    err := assetexchange.UnlockFungibleAsset(ctx, contractId)
    if err != nil {
        return false, logThenErrorf(err.Error())
    }
    unlocked = true
    ...
    ...
    return true, nil
}
```

6. Add following extra utility functions as well:
  ```go
  func (s *SmartContract) GetHTLCHash(ctx contractapi.TransactionContextInterface, callerChaincodeID, assetAgreementBytesBase64 string) (string, error) {
      return assetexchange.GetHTLCHash(ctx, callerChaincodeID, assetAgreementBytesBase64)
  }
  func (s *SmartContract) GetHTLCHashPreImage(ctx contractapi.TransactionContextInterface, callerChaincodeID, assetAgreementBytesBase64 string) (string, error) {
      return assetexchange.GetHTLCHashPreImage(ctx, callerChaincodeID, assetAgreementBytesBase64)
  }
  ```