// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.23.4
// source: relay/satp.proto

package relay

import (
	context "context"
	common "github.com/hyperledger-cacti/cacti/weaver/common/protos-go/v2/common"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	SATP_TransferProposalClaims_FullMethodName  = "/relay.satp.SATP/TransferProposalClaims"
	SATP_TransferProposalReceipt_FullMethodName = "/relay.satp.SATP/TransferProposalReceipt"
	SATP_TransferCommence_FullMethodName        = "/relay.satp.SATP/TransferCommence"
	SATP_AckCommence_FullMethodName             = "/relay.satp.SATP/AckCommence"
	SATP_SendAssetStatus_FullMethodName         = "/relay.satp.SATP/SendAssetStatus"
	SATP_LockAssertion_FullMethodName           = "/relay.satp.SATP/LockAssertion"
	SATP_LockAssertionReceipt_FullMethodName    = "/relay.satp.SATP/LockAssertionReceipt"
	SATP_CommitPrepare_FullMethodName           = "/relay.satp.SATP/CommitPrepare"
	SATP_CommitReady_FullMethodName             = "/relay.satp.SATP/CommitReady"
	SATP_CommitFinalAssertion_FullMethodName    = "/relay.satp.SATP/CommitFinalAssertion"
	SATP_AckFinalReceipt_FullMethodName         = "/relay.satp.SATP/AckFinalReceipt"
	SATP_TransferCompleted_FullMethodName       = "/relay.satp.SATP/TransferCompleted"
)

// SATPClient is the client API for SATP service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SATPClient interface {
	// The sender gateway sends a TransferProposalClaims request to initiate an asset transfer.
	// Depending on the proposal, multiple rounds of communication between the two gateways may happen.
	TransferProposalClaims(ctx context.Context, in *TransferProposalClaimsRequest, opts ...grpc.CallOption) (*common.Ack, error)
	// The sender gateway sends a TransferProposalClaims request to signal to the receiver gateway
	// that the it is ready to start the transfer of the digital asset
	TransferProposalReceipt(ctx context.Context, in *TransferProposalReceiptRequest, opts ...grpc.CallOption) (*common.Ack, error)
	// The sender gateway sends a TransferCommence request to signal to the receiver gateway
	// that the it is ready to start the transfer of the digital asset
	TransferCommence(ctx context.Context, in *TransferCommenceRequest, opts ...grpc.CallOption) (*common.Ack, error)
	// The receiver gateway sends a AckCommence request to the sender gateway to indicate agreement
	// to proceed with the asset transfe
	AckCommence(ctx context.Context, in *AckCommenceRequest, opts ...grpc.CallOption) (*common.Ack, error)
	SendAssetStatus(ctx context.Context, in *SendAssetStatusRequest, opts ...grpc.CallOption) (*common.Ack, error)
	// The sender gateway sends a LockAssertion request to convey a signed claim to the receiver gateway
	// declaring that the asset in question has been locked or escrowed by the sender gateway in
	// the origin network (e.g. to prevent double spending)
	LockAssertion(ctx context.Context, in *LockAssertionRequest, opts ...grpc.CallOption) (*common.Ack, error)
	// The receiver gateway sends a LockAssertionReceipt request to the sender gateway to indicate acceptance
	// of the claim(s) delivered by the sender gateway in the previous message
	LockAssertionReceipt(ctx context.Context, in *LockAssertionReceiptRequest, opts ...grpc.CallOption) (*common.Ack, error)
	CommitPrepare(ctx context.Context, in *CommitPrepareRequest, opts ...grpc.CallOption) (*common.Ack, error)
	CommitReady(ctx context.Context, in *CommitReadyRequest, opts ...grpc.CallOption) (*common.Ack, error)
	CommitFinalAssertion(ctx context.Context, in *CommitFinalAssertionRequest, opts ...grpc.CallOption) (*common.Ack, error)
	AckFinalReceipt(ctx context.Context, in *AckFinalReceiptRequest, opts ...grpc.CallOption) (*common.Ack, error)
	TransferCompleted(ctx context.Context, in *TransferCompletedRequest, opts ...grpc.CallOption) (*common.Ack, error)
}

type sATPClient struct {
	cc grpc.ClientConnInterface
}

func NewSATPClient(cc grpc.ClientConnInterface) SATPClient {
	return &sATPClient{cc}
}

func (c *sATPClient) TransferProposalClaims(ctx context.Context, in *TransferProposalClaimsRequest, opts ...grpc.CallOption) (*common.Ack, error) {
	out := new(common.Ack)
	err := c.cc.Invoke(ctx, SATP_TransferProposalClaims_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sATPClient) TransferProposalReceipt(ctx context.Context, in *TransferProposalReceiptRequest, opts ...grpc.CallOption) (*common.Ack, error) {
	out := new(common.Ack)
	err := c.cc.Invoke(ctx, SATP_TransferProposalReceipt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sATPClient) TransferCommence(ctx context.Context, in *TransferCommenceRequest, opts ...grpc.CallOption) (*common.Ack, error) {
	out := new(common.Ack)
	err := c.cc.Invoke(ctx, SATP_TransferCommence_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sATPClient) AckCommence(ctx context.Context, in *AckCommenceRequest, opts ...grpc.CallOption) (*common.Ack, error) {
	out := new(common.Ack)
	err := c.cc.Invoke(ctx, SATP_AckCommence_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sATPClient) SendAssetStatus(ctx context.Context, in *SendAssetStatusRequest, opts ...grpc.CallOption) (*common.Ack, error) {
	out := new(common.Ack)
	err := c.cc.Invoke(ctx, SATP_SendAssetStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sATPClient) LockAssertion(ctx context.Context, in *LockAssertionRequest, opts ...grpc.CallOption) (*common.Ack, error) {
	out := new(common.Ack)
	err := c.cc.Invoke(ctx, SATP_LockAssertion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sATPClient) LockAssertionReceipt(ctx context.Context, in *LockAssertionReceiptRequest, opts ...grpc.CallOption) (*common.Ack, error) {
	out := new(common.Ack)
	err := c.cc.Invoke(ctx, SATP_LockAssertionReceipt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sATPClient) CommitPrepare(ctx context.Context, in *CommitPrepareRequest, opts ...grpc.CallOption) (*common.Ack, error) {
	out := new(common.Ack)
	err := c.cc.Invoke(ctx, SATP_CommitPrepare_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sATPClient) CommitReady(ctx context.Context, in *CommitReadyRequest, opts ...grpc.CallOption) (*common.Ack, error) {
	out := new(common.Ack)
	err := c.cc.Invoke(ctx, SATP_CommitReady_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sATPClient) CommitFinalAssertion(ctx context.Context, in *CommitFinalAssertionRequest, opts ...grpc.CallOption) (*common.Ack, error) {
	out := new(common.Ack)
	err := c.cc.Invoke(ctx, SATP_CommitFinalAssertion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sATPClient) AckFinalReceipt(ctx context.Context, in *AckFinalReceiptRequest, opts ...grpc.CallOption) (*common.Ack, error) {
	out := new(common.Ack)
	err := c.cc.Invoke(ctx, SATP_AckFinalReceipt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sATPClient) TransferCompleted(ctx context.Context, in *TransferCompletedRequest, opts ...grpc.CallOption) (*common.Ack, error) {
	out := new(common.Ack)
	err := c.cc.Invoke(ctx, SATP_TransferCompleted_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SATPServer is the server API for SATP service.
// All implementations must embed UnimplementedSATPServer
// for forward compatibility
type SATPServer interface {
	// The sender gateway sends a TransferProposalClaims request to initiate an asset transfer.
	// Depending on the proposal, multiple rounds of communication between the two gateways may happen.
	TransferProposalClaims(context.Context, *TransferProposalClaimsRequest) (*common.Ack, error)
	// The sender gateway sends a TransferProposalClaims request to signal to the receiver gateway
	// that the it is ready to start the transfer of the digital asset
	TransferProposalReceipt(context.Context, *TransferProposalReceiptRequest) (*common.Ack, error)
	// The sender gateway sends a TransferCommence request to signal to the receiver gateway
	// that the it is ready to start the transfer of the digital asset
	TransferCommence(context.Context, *TransferCommenceRequest) (*common.Ack, error)
	// The receiver gateway sends a AckCommence request to the sender gateway to indicate agreement
	// to proceed with the asset transfe
	AckCommence(context.Context, *AckCommenceRequest) (*common.Ack, error)
	SendAssetStatus(context.Context, *SendAssetStatusRequest) (*common.Ack, error)
	// The sender gateway sends a LockAssertion request to convey a signed claim to the receiver gateway
	// declaring that the asset in question has been locked or escrowed by the sender gateway in
	// the origin network (e.g. to prevent double spending)
	LockAssertion(context.Context, *LockAssertionRequest) (*common.Ack, error)
	// The receiver gateway sends a LockAssertionReceipt request to the sender gateway to indicate acceptance
	// of the claim(s) delivered by the sender gateway in the previous message
	LockAssertionReceipt(context.Context, *LockAssertionReceiptRequest) (*common.Ack, error)
	CommitPrepare(context.Context, *CommitPrepareRequest) (*common.Ack, error)
	CommitReady(context.Context, *CommitReadyRequest) (*common.Ack, error)
	CommitFinalAssertion(context.Context, *CommitFinalAssertionRequest) (*common.Ack, error)
	AckFinalReceipt(context.Context, *AckFinalReceiptRequest) (*common.Ack, error)
	TransferCompleted(context.Context, *TransferCompletedRequest) (*common.Ack, error)
	mustEmbedUnimplementedSATPServer()
}

// UnimplementedSATPServer must be embedded to have forward compatible implementations.
type UnimplementedSATPServer struct {
}

func (UnimplementedSATPServer) TransferProposalClaims(context.Context, *TransferProposalClaimsRequest) (*common.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferProposalClaims not implemented")
}
func (UnimplementedSATPServer) TransferProposalReceipt(context.Context, *TransferProposalReceiptRequest) (*common.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferProposalReceipt not implemented")
}
func (UnimplementedSATPServer) TransferCommence(context.Context, *TransferCommenceRequest) (*common.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferCommence not implemented")
}
func (UnimplementedSATPServer) AckCommence(context.Context, *AckCommenceRequest) (*common.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AckCommence not implemented")
}
func (UnimplementedSATPServer) SendAssetStatus(context.Context, *SendAssetStatusRequest) (*common.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendAssetStatus not implemented")
}
func (UnimplementedSATPServer) LockAssertion(context.Context, *LockAssertionRequest) (*common.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockAssertion not implemented")
}
func (UnimplementedSATPServer) LockAssertionReceipt(context.Context, *LockAssertionReceiptRequest) (*common.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockAssertionReceipt not implemented")
}
func (UnimplementedSATPServer) CommitPrepare(context.Context, *CommitPrepareRequest) (*common.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitPrepare not implemented")
}
func (UnimplementedSATPServer) CommitReady(context.Context, *CommitReadyRequest) (*common.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitReady not implemented")
}
func (UnimplementedSATPServer) CommitFinalAssertion(context.Context, *CommitFinalAssertionRequest) (*common.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitFinalAssertion not implemented")
}
func (UnimplementedSATPServer) AckFinalReceipt(context.Context, *AckFinalReceiptRequest) (*common.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AckFinalReceipt not implemented")
}
func (UnimplementedSATPServer) TransferCompleted(context.Context, *TransferCompletedRequest) (*common.Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferCompleted not implemented")
}
func (UnimplementedSATPServer) mustEmbedUnimplementedSATPServer() {}

// UnsafeSATPServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SATPServer will
// result in compilation errors.
type UnsafeSATPServer interface {
	mustEmbedUnimplementedSATPServer()
}

func RegisterSATPServer(s grpc.ServiceRegistrar, srv SATPServer) {
	s.RegisterService(&SATP_ServiceDesc, srv)
}

func _SATP_TransferProposalClaims_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferProposalClaimsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SATPServer).TransferProposalClaims(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SATP_TransferProposalClaims_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SATPServer).TransferProposalClaims(ctx, req.(*TransferProposalClaimsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SATP_TransferProposalReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferProposalReceiptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SATPServer).TransferProposalReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SATP_TransferProposalReceipt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SATPServer).TransferProposalReceipt(ctx, req.(*TransferProposalReceiptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SATP_TransferCommence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferCommenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SATPServer).TransferCommence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SATP_TransferCommence_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SATPServer).TransferCommence(ctx, req.(*TransferCommenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SATP_AckCommence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckCommenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SATPServer).AckCommence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SATP_AckCommence_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SATPServer).AckCommence(ctx, req.(*AckCommenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SATP_SendAssetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendAssetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SATPServer).SendAssetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SATP_SendAssetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SATPServer).SendAssetStatus(ctx, req.(*SendAssetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SATP_LockAssertion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockAssertionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SATPServer).LockAssertion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SATP_LockAssertion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SATPServer).LockAssertion(ctx, req.(*LockAssertionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SATP_LockAssertionReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockAssertionReceiptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SATPServer).LockAssertionReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SATP_LockAssertionReceipt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SATPServer).LockAssertionReceipt(ctx, req.(*LockAssertionReceiptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SATP_CommitPrepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitPrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SATPServer).CommitPrepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SATP_CommitPrepare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SATPServer).CommitPrepare(ctx, req.(*CommitPrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SATP_CommitReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitReadyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SATPServer).CommitReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SATP_CommitReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SATPServer).CommitReady(ctx, req.(*CommitReadyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SATP_CommitFinalAssertion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitFinalAssertionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SATPServer).CommitFinalAssertion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SATP_CommitFinalAssertion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SATPServer).CommitFinalAssertion(ctx, req.(*CommitFinalAssertionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SATP_AckFinalReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckFinalReceiptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SATPServer).AckFinalReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SATP_AckFinalReceipt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SATPServer).AckFinalReceipt(ctx, req.(*AckFinalReceiptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SATP_TransferCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SATPServer).TransferCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SATP_TransferCompleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SATPServer).TransferCompleted(ctx, req.(*TransferCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SATP_ServiceDesc is the grpc.ServiceDesc for SATP service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SATP_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "relay.satp.SATP",
	HandlerType: (*SATPServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TransferProposalClaims",
			Handler:    _SATP_TransferProposalClaims_Handler,
		},
		{
			MethodName: "TransferProposalReceipt",
			Handler:    _SATP_TransferProposalReceipt_Handler,
		},
		{
			MethodName: "TransferCommence",
			Handler:    _SATP_TransferCommence_Handler,
		},
		{
			MethodName: "AckCommence",
			Handler:    _SATP_AckCommence_Handler,
		},
		{
			MethodName: "SendAssetStatus",
			Handler:    _SATP_SendAssetStatus_Handler,
		},
		{
			MethodName: "LockAssertion",
			Handler:    _SATP_LockAssertion_Handler,
		},
		{
			MethodName: "LockAssertionReceipt",
			Handler:    _SATP_LockAssertionReceipt_Handler,
		},
		{
			MethodName: "CommitPrepare",
			Handler:    _SATP_CommitPrepare_Handler,
		},
		{
			MethodName: "CommitReady",
			Handler:    _SATP_CommitReady_Handler,
		},
		{
			MethodName: "CommitFinalAssertion",
			Handler:    _SATP_CommitFinalAssertion_Handler,
		},
		{
			MethodName: "AckFinalReceipt",
			Handler:    _SATP_AckFinalReceipt_Handler,
		},
		{
			MethodName: "TransferCompleted",
			Handler:    _SATP_TransferCompleted_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "relay/satp.proto",
}
