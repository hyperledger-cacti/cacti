/* eslint-disable */
/**
 * Copyright 2016 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/**
 * Licensed Materials - Property of IBM
 * Â© Copyright IBM Corp. 2016
 */

/*
 * This file provides a function to encrypt and decrypt messages using the ECIES public key algorithm.
 * It implements the specification in https://www.secg.org/sec1-v2.pdf
 * It is designed to be compatible with the Golang implementation in the following repo:
 * - https://godoc.org/github.com/ethereum/go-ethereum/crypto/ecies
 * Any ciphertext generated by the encryption function in the Golang package can be decrypted
 * using the function implemented here as long as the private key is available. Likewise, any message
 * encrypted using the encryption function implemented here can be decrypted by the decryption
 * function in the Golang package.
 *
 */

// requires
const crypto = require("crypto");
const elliptic = require("elliptic");
const sha3 = require("js-sha3");
const sjcl = require("sjcl");
const jsrsa = require("jsrsasign");

// constants
const SHA2 = "SHA2";
const SHA3 = "SHA3";
const AESKeyLength = 16;
const HMACKeyLength = 32;

const ECIESKDFOutput = 512; // bits
const IVLength = 16; // bytes

const CURVE_P_256_Size = 256;
const CURVE_P_384_Size = 384;

/** Decrypt a message.
 *
 * @param {object} recipientPrivateKey the private key object. Format
 * {
 *      ecparams: { keylen: {int} security level },
 *      prvKeyHex: private key in HEX {string},
 *  }
 * - Using the 'jsrsasign' npm package
 * - this private key can be a KJUR.crypto.ECDSA object, parsed from a PEM file
 * - using 'jsrsasign.KEYUTIL.getKeyFromPlainPrivatePKCS8PEM(pkcs8PEM)'
 *
 * @param {string} cipherText message to decrypt
 * @param {object} options In the following format:
 * {
 *      hashAlgorithm: hash algorithm,
 *      securityLevel: key size,
 *  }
 * - 'hashAlgorithm': either 'SHA2' or 'SHA3' (NOTE: only the former is tested)
 *
 * @returns decrypted message as a Buffer.
 *
 * Comments below indicate a mapping between variables defined here and in the
 * 'Decrypt(...)' function implemented in 'ecies.go' in the Golang package
 */
function eciesDecryptMessage(recipientPrivateKey, cipherText, options) {
    const level = recipientPrivateKey.ecparams.keylen;
    options.securityLevel = level;
    processOption(options);

    const Rb_len = Math.floor((level + 7) / 8) * 2 + 1; // 'rLen'
    const D_len = level >> 3; // 'hLen'
    const ct_len = cipherText.length; // 'len(ct)'

    if (ct_len <= Rb_len + D_len) {
        throw new Error(`Illegal cipherText length: ${ct_len} must be > ${Rb_len + D_len}`);
    }

    const Rb = cipherText.slice(0, Rb_len); // ephemeral public key bytes
    const EM = cipherText.slice(Rb_len, ct_len - D_len); // encrypted content bytes
    const D = cipherText.slice(ct_len - D_len);

    const ecdsa = new elliptic.ec(`p${level}`);

    // convert bytes to usable key object
    const ephPubKey = ecdsa.keyFromPublic(Buffer.from(Rb, "hex"), "hex"); // 'R'
    const privKey = ecdsa.keyFromPrivate(recipientPrivateKey.prvKeyHex, "hex");

    const Z = privKey.derive(ephPubKey.pub); // 'z'
    const kdfOutput = hkdf(Z.toArray(), ECIESKDFOutput, null, null, options); // The 'null's correspond to 's1' and 's2', which are both
    // empty in our SNAMCC and ESCC plugin implementations
    const kbuf = Buffer.from(kdfOutput);
    const aesKey = kdfOutput.slice(0, AESKeyLength); // 'Ke'
    const hmacKey = kdfOutput.slice(AESKeyLength, AESKeyLength + HMACKeyLength); // 'Km'

    const hmacKeyHash = new options.hashFunctionKeyDerivation();
    hmacKeyHash.update(bytesToBits(hmacKey));
    const hKm = bitsToBytes(hmacKeyHash.finalize());

    const recoveredD = hmac(hKm, EM, options);

    if (D.compare(Buffer.from(recoveredD)) !== 0) {
        throw new Error("HMAC verify failed");
    }
    const iv = EM.slice(0, IVLength);
    const cipher = crypto.createDecipheriv("aes-128-ctr", Buffer.from(aesKey), iv); // The Golang package implements AES-128-CTR
    const decryptedBytes = cipher.update(EM.slice(IVLength));
    return decryptedBytes;
}

/** Encrypt a message.
 *
 * @param {object} recipientPublicKey the private key object. Format
 * {
 *      ecparams: { keylen: {int} security level },
 *      pubKeyHex: public key in HEX {string},
 *  }
 * - Using the 'jsrsasign' npm package
 * - this public key can be a KJUR.crypto.ECDSA object, parsed from an X.509 certificate PEM file
 * - using 'jsrsasign.KEYUTIL.getKey(pemX509Certificate)'
 *
 * @param {string} cipherText message to encrypt
 * @param {object} options In the following format:
 * {
 *      hashAlgorithm: hash algorithm,
 *      securityLevel: key size,
 *  }
 * - 'hashAlgorithm': either 'SHA2' or 'SHA3' (NOTE: only the former is tested)
 *
 * @returns encrypted message as a Buffer.
 *
 */
function eciesEncryptMessage(recipientPublicKey, msg, options) {
    const level = recipientPublicKey.ecparams.keylen;
    options.securityLevel = level;
    processOption(options);

    const ecdsa = new elliptic.ec(`p${level}`);
    const pubKey = ecdsa.keyFromPublic(recipientPublicKey.pubKeyHex, "hex");

    // Generate ephemeral key-pair
    const ephKeyPair = jsrsa.KEYUTIL.generateKeypair("EC", options.curveName);
    const ephPrivKey = ecdsa.keyFromPrivate(ephKeyPair.prvKeyObj.prvKeyHex, "hex");
    const Rb = ephKeyPair.pubKeyObj.pubKeyHex;

    // Derive a shared secret field element z from the ephemeral secret key k
    // and convert z to an octet string Z
    const Z = ephPrivKey.derive(pubKey.pub);
    const kdfOutput = hkdf(Z.toArray(), ECIESKDFOutput, null, null, options);

    const aesKey = kdfOutput.slice(0, AESKeyLength);
    const hmacKey = kdfOutput.slice(AESKeyLength, AESKeyLength + HMACKeyLength);

    const hmacKeyHash = new options.hashFunctionKeyDerivation();
    hmacKeyHash.update(bytesToBits(hmacKey));
    const hKm = bitsToBytes(hmacKeyHash.finalize());

    const iv = crypto.randomBytes(IVLength);
    const cipher = crypto.createCipheriv("aes-128-ctr", Buffer.from(aesKey), iv);
    const encryptedBytes = cipher.update(msg);
    const EM = Buffer.concat([iv, encryptedBytes]);
    const D = hmac(hKm, EM, options);

    return Buffer.concat([Buffer.from(Rb, "hex"), EM, Buffer.from(D)]);
}

function checkSecurityLevel(securityLevel) {
    if (securityLevel !== 256 && securityLevel !== 384)
        throw new Error(`Illegal level: ${this.securityLevel} - must be either 256 or 384`);
}

function checkHashFunction(hashAlgorithm) {
    if (!isString(hashAlgorithm))
        throw new Error(`Illegal Hash function family: ${hashAlgorithm} - must be either SHA2 or SHA3`);

    const hashAlgorithmUpper = hashAlgorithm.toUpperCase();
    if (hashAlgorithmUpper !== SHA2 && hashAlgorithmUpper !== SHA3)
        throw new Error(`Illegal Hash function family: ${hashAlgorithm} - must be either SHA2 or SHA3`);
}

function processOption(options) {
    checkSecurityLevel(options.securityLevel);
    checkHashFunction(options.hashAlgorithm);

    options.suite = `${options.hashAlgorithm.toLowerCase()}-${options.securityLevel}`;

    if (options.securityLevel === CURVE_P_256_Size) {
        options.curveName = "secp256r1";
    } else if (options.securityLevel === CURVE_P_384_Size) {
        options.curveName = "secp384r1";
    }

    switch (options.suite) {
        case "sha3-256":
            options.hashFunctionKeyDerivation = sha3.sha3_256;
            options.hashOutputSize = 32;
            break;
        case "sha3-384":
            options.hashFunctionKeyDerivation = sha3.sha3_384;
            options.hashOutputSize = 48;
            break;
        case "sha2-256":
            options.hashFunctionKeyDerivation = sjcl.hash.sha256;
            options.hashOutputSize = 32;
            break;
        default:
            throw new Error(`Suite ${options.suite} not found.`);
    }

    switch (options.securityLevel) {
        case 256:
            options.ecdsaCurve = elliptic.curves.p256;
            break;
        case 384:
            options.ecdsaCurve = elliptic.curves.p384;
            break;
        default:
            throw new Error(`Security level ${options.securityLevel} not found.`);
    }

    return options;
}

function hkdf(ikm, keyBitLength, salt, info, options) {
    if (!salt) salt = createZeroBuffer(options.hashOutputSize);
    if (!info) info = "";

    const key = hkdf2(
        bytesToBits(Buffer.from(ikm)),
        keyBitLength,
        bytesToBits(salt),
        info,
        options.hashFunctionKeyDerivation,
    );

    return bitsToBytes(key);
}

function hkdf2(ikm, keyBitLength, salt, info, Hash) {
    let hmac;
    let i;
    let curOut;
    let ret = [];

    if (typeof info === "string") {
        info = sjcl.codec.utf8String.toBits(info);
    } else if (!info) {
        info = sjcl.codec.utf8String.toBits("");
    }
    if (typeof salt === "string") {
        salt = sjcl.codec.utf8String.toBits(salt);
    } else if (!salt) {
        salt = [];
    }

    hmac = new sjcl.misc.hmac(salt, Hash);
    hmac.update(ikm);
    const key = hmac.digest();
    const hashLen = sjcl.bitArray.bitLength(key);

    const loops = Math.ceil(keyBitLength / hashLen);
    if (loops > 255) {
        throw new sjcl.exception.invalid("key bit length is too large for hkdf");
    }

    const counter = [0, 0, 0, 1];
    curOut = [];
    for (i = 1; i <= loops; i++) {
        hmac = new Hash();
        hmac.update(bytesToBits(counter));
        hmac.update(ikm);
        hmac.update(bytesToBits(info));
        ret = sjcl.bitArray.concat(hmac.finalize(), curOut);
    }
    return sjcl.bitArray.clamp(ret, keyBitLength);
}

function hmac(key, bytes, options) {
    const hmac = new sjcl.misc.hmac(bytesToBits(key), options.hashFunctionKeyDerivation);
    hmac.update(bytesToBits(bytes));
    const result = hmac.digest();
    return bitsToBytes(result);
}

function bitsToBytes(arr) {
    const out = [];
    const bl = sjcl.bitArray.bitLength(arr);
    let tmp;
    for (let i = 0; i < bl / 8; i++) {
        if ((i & 3) === 0) {
            tmp = arr[i / 4];
        }
        out.push(tmp >>> 24);
        tmp <<= 8;
    }
    return out;
}

function bytesToBits(bytes) {
    const out = [];
    let i;
    let tmp = 0;
    for (i = 0; i < bytes.length; i++) {
        tmp = (tmp << 8) | bytes[i];
        if ((i & 3) === 3) {
            out.push(tmp);
            tmp = 0;
        }
    }
    if (i & 3) {
        out.push(sjcl.bitArray.partial(8 * (i & 3), tmp));
    }
    return out;
}

function createZeroBuffer(length) {
    const buf = Buffer.alloc(length);
    buf.fill(0);
    return buf;
}

function isString(obj) {
    return typeof obj === "string" || obj instanceof String;
}

module.exports.eciesDecryptMessage = eciesDecryptMessage;
module.exports.eciesEncryptMessage = eciesEncryptMessage;
