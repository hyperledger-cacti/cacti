/*
 * Copyright IBM Corp. All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/* eslint-disable */

/*
 * This file provides a function to encrypt and decrypt messages using the ECIES public key algorithm.
 * It implements the specification in https://www.secg.org/sec1-v2.pdf
 * It is designed to be compatible with the Golang implementation in the following repo:
 * - https://godoc.org/github.com/ethereum/go-ethereum/crypto/ecies
 * Any ciphertext generated by the encryption function in the Golang package can be decrypted
 * using the function implemented here as long as the private key is available. Likewise, any message
 * encrypted using the encryption function implemented here can be decrypted by the decryption
 * function in the Golang package.
 *
 */

// requires
const crypto = require("crypto");
const elliptic = require("elliptic");
const sha3 = require("js-sha3");
const sjcl = require("sjcl");
const jsrsa = require("jsrsasign");

// constants
const SHA2 = "SHA2";
const SHA3 = "SHA3";
const AESKeyLength = 16;
const HMACKeyLength = 32;

const ECIESKDFOutput = 512; // bits
const IVLength = 16; // bytes

const CURVE_P_256_Size = 256;
const CURVE_P_384_Size = 384;

/** Decrypt a message.
 *
 * @param {object} recipientPrivateKey the private key object. Format
 * {
 *      ecparams: { keylen: {int} security level },
 *      prvKeyHex: private key in HEX {string},
 *  }
 * - Using the 'jsrsasign' npm package
 * - this private key can be a KJUR.crypto.ECDSA object, parsed from a PEM file
 * - using 'jsrsasign.KEYUTIL.getKeyFromPlainPrivatePKCS8PEM(pkcs8PEM)'
 *
 * @param {string} cipherText message to decrypt
 * @param {object} options In the following format:
 * {
 *      hashAlgorithm: hash algorithm,
 *      securityLevel: key size,
 *  }
 * - 'hashAlgorithm': either 'SHA2' or 'SHA3' (NOTE: only the former is tested)
 *
 * @returns decrypted message as a Buffer.
 *
 * Comments below indicate a mapping between variables defined here and in the
 * 'Decrypt(...)' function implemented in 'ecies.go' in the Golang package
 */
function eciesDecryptMessage(
  recipientPrivateKey,
  cipherText,
  options,
  aesKeyLength = AESKeyLength,
) {
  const level = recipientPrivateKey.ecparams.keylen;
  options.securityLevel = level;
  processOption(options);

  const Rb_len = Math.floor((level + 7) / 8) * 2 + 1; // 'rLen'
  const D_len = level >> 3; // 'hLen'
  const ct_len = cipherText.length; // 'len(ct)'

  if (ct_len <= Rb_len + D_len) {
    throw new Error(
      `Illegal cipherText length: ${ct_len} must be > ${Rb_len + D_len}`,
    );
  }

  const Rb = cipherText.slice(0, Rb_len); // ephemeral public key bytes
  const EM = cipherText.slice(Rb_len, ct_len - D_len); // encrypted content bytes
  const D = cipherText.slice(ct_len - D_len);

  const ecdsa = new elliptic.ec(`p${level}`);

  // convert bytes to usable key object
  const ephPubKey = ecdsa.keyFromPublic(Buffer.from(Rb, "hex"), "hex"); // 'R'
  const privKey = ecdsa.keyFromPrivate(recipientPrivateKey.prvKeyHex, "hex");

  const Z = privKey.derive(ephPubKey.pub); // 'z'
  // Append missing leading zeros to Z
  let ZArray = Z.toArray();
  const zerosToAdd = 32 - ZArray.length;
  for (let ii = 0; ii < zerosToAdd; ii++) {
    ZArray = new Uint8Array([0, ...ZArray]);
  }
  // The 'null's below correspond to 's1' and 's2',
  // which are both set to nil in golang implementation of the encryption function
  const kdfOutput = hkdf(ZArray, ECIESKDFOutput, null, null, options);

  const kbuf = Buffer.from(kdfOutput);
  const aesKey = kdfOutput.slice(0, aesKeyLength); // 'Ke'
  const hmacKey = kdfOutput.slice(aesKeyLength, aesKeyLength + HMACKeyLength);

  const hmacKeyHash = new options.hashFunctionKeyDerivation();
  hmacKeyHash.update(bytesToBits(hmacKey));
  const hKm = bitsToBytes(hmacKeyHash.finalize()); // 'Km'

  const recoveredD = hmac(hKm, EM, options);
  if (D.compare(Buffer.from(recoveredD)) !== 0) {
    throw new Error("HMAC verify failed");
  }
  const iv = EM.slice(0, IVLength);
  // The go-ethereum crypto/ecies package that encrypts/decrypts data uses AES-128-CTR by default for signing certs currently generated by Fabric
  let aesAlgorithm;
  if (aesKeyLength === 16) {
    aesAlgorithm = "aes-128-ctr";
  } else if (aesKeyLength === 32) {
    aesAlgorithm = "aes-256-ctr";
  } else {
    throw new Error("Invalid AES key length supplied: " + aesKeyLength);
  }
  const cipher = crypto.createDecipheriv(aesAlgorithm, Buffer.from(aesKey), iv);
  const decryptedBytes = cipher.update(EM.slice(IVLength));
  return decryptedBytes;
}

/** Encrypt a message.
 *
 * @param {object} recipientPublicKey the private key object. Format
 * {
 *      ecparams: { keylen: {int} security level },
 *      pubKeyHex: public key in HEX {string},
 *  }
 * - Using the 'jsrsasign' npm package
 * - this public key can be a KJUR.crypto.ECDSA object, parsed from an X.509 certificate PEM file
 * - using 'jsrsasign.KEYUTIL.getKey(pemX509Certificate)'
 *
 * @param {string} cipherText message to encrypt
 * @param {object} options In the following format:
 * {
 *      hashAlgorithm: hash algorithm,
 *      securityLevel: key size,
 *  }
 * - 'hashAlgorithm': either 'SHA2' or 'SHA3' (NOTE: only the former is tested)
 *
 * @returns encrypted message as a Buffer.
 *
 */
function eciesEncryptMessage(
  recipientPublicKey,
  msg,
  options,
  aesKeyLength = AESKeyLength,
) {
  const level = recipientPublicKey.ecparams.keylen;
  options.securityLevel = level;
  processOption(options);

  const ecdsa = new elliptic.ec(`p${level}`);
  const pubKey = ecdsa.keyFromPublic(recipientPublicKey.pubKeyHex, "hex");

  // Generate ephemeral key-pair
  const ephKeyPair = jsrsa.KEYUTIL.generateKeypair("EC", options.curveName);
  const ephPrivKey = ecdsa.keyFromPrivate(
    ephKeyPair.prvKeyObj.prvKeyHex,
    "hex",
  );
  const Rb = ephKeyPair.pubKeyObj.pubKeyHex;

  // Derive a shared secret field element z from the ephemeral secret key k
  // and convert z to an octet string Z
  const Z = ephPrivKey.derive(pubKey.pub);
  const kdfOutput = hkdf(Z.toArray(), ECIESKDFOutput, null, null, options);

  const aesKey = kdfOutput.slice(0, aesKeyLength);
  const hmacKey = kdfOutput.slice(aesKeyLength, aesKeyLength + HMACKeyLength);

  const hmacKeyHash = new options.hashFunctionKeyDerivation();
  hmacKeyHash.update(bytesToBits(hmacKey));
  const hKm = bitsToBytes(hmacKeyHash.finalize());

  const iv = crypto.randomBytes(IVLength);
  // The go-ethereum crypto/ecies package that encrypts/decrypts data uses AES-128-CTR by default for signing certs currently generated by Fabric
  let aesAlgorithm;
  if (aesKeyLength === 16) {
    aesAlgorithm = "aes-128-ctr";
  } else if (aesKeyLength === 32) {
    aesAlgorithm = "aes-256-ctr";
  } else {
    throw new Error("Invalid AES key length supplied: " + aesKeyLength);
  }
  const cipher = crypto.createCipheriv(aesAlgorithm, Buffer.from(aesKey), iv);
  const encryptedBytes = cipher.update(msg);
  const EM = Buffer.concat([iv, encryptedBytes]);
  const D = hmac(hKm, EM, options);

  return Buffer.concat([Buffer.from(Rb, "hex"), EM, Buffer.from(D)]);
}

function checkSecurityLevel(securityLevel) {
  if (securityLevel !== 256 && securityLevel !== 384)
    throw new Error(
      `Illegal level: ${this.securityLevel} - must be either 256 or 384`,
    );
}

function checkHashFunction(hashAlgorithm) {
  if (!isString(hashAlgorithm))
    throw new Error(
      `Illegal Hash function family: ${hashAlgorithm} - must be either SHA2 or SHA3`,
    );

  const hashAlgorithmUpper = hashAlgorithm.toUpperCase();
  if (hashAlgorithmUpper !== SHA2 && hashAlgorithmUpper !== SHA3)
    throw new Error(
      `Illegal Hash function family: ${hashAlgorithm} - must be either SHA2 or SHA3`,
    );
}

function processOption(options) {
  checkSecurityLevel(options.securityLevel);
  checkHashFunction(options.hashAlgorithm);

  options.suite = `${options.hashAlgorithm.toLowerCase()}-${options.securityLevel}`;

  if (options.securityLevel === CURVE_P_256_Size) {
    options.curveName = "secp256r1";
  } else if (options.securityLevel === CURVE_P_384_Size) {
    options.curveName = "secp384r1";
  }

  switch (options.suite) {
    case "sha3-256":
      options.hashFunctionKeyDerivation = sha3.sha3_256;
      options.hashOutputSize = 32;
      break;
    case "sha3-384":
      options.hashFunctionKeyDerivation = sha3.sha3_384;
      options.hashOutputSize = 48;
      break;
    case "sha2-256":
      options.hashFunctionKeyDerivation = sjcl.hash.sha256;
      options.hashOutputSize = 32;
      break;
    default:
      throw new Error(`Suite ${options.suite} not found.`);
  }

  switch (options.securityLevel) {
    case 256:
      options.ecdsaCurve = elliptic.curves.p256;
      break;
    case 384:
      options.ecdsaCurve = elliptic.curves.p384;
      break;
    default:
      throw new Error(`Security level ${options.securityLevel} not found.`);
  }

  return options;
}

function hkdf(ikm, keyBitLength, salt, info, options) {
  if (!salt) salt = createZeroBuffer(options.hashOutputSize);
  if (!info) info = "";

  const key = hkdf2(
    bytesToBits(Buffer.from(ikm)),
    keyBitLength,
    bytesToBits(salt),
    info,
    options.hashFunctionKeyDerivation,
  );

  return bitsToBytes(key);
}

function hkdf2(ikm, keyBitLength, salt, info, Hash) {
  let hmac;
  let i;
  let curOut;
  let ret = [];

  if (typeof info === "string") {
    info = sjcl.codec.utf8String.toBits(info);
  } else if (!info) {
    info = sjcl.codec.utf8String.toBits("");
  }
  if (typeof salt === "string") {
    salt = sjcl.codec.utf8String.toBits(salt);
  } else if (!salt) {
    salt = [];
  }

  hmac = new sjcl.misc.hmac(salt, Hash);
  hmac.update(ikm);
  const key = hmac.digest();
  const hashLen = sjcl.bitArray.bitLength(key);

  const loops = Math.ceil(keyBitLength / hashLen);
  if (loops > 255) {
    throw new sjcl.exception.invalid("key bit length is too large for hkdf");
  }

  const counter = [0, 0, 0, 1];
  curOut = [];
  for (i = 1; i <= loops; i++) {
    hmac = new Hash();
    hmac.update(bytesToBits(counter));
    hmac.update(ikm);
    hmac.update(bytesToBits(info));
    ret = sjcl.bitArray.concat(hmac.finalize(), curOut);
  }
  return sjcl.bitArray.clamp(ret, keyBitLength);
}

function hmac(key, bytes, options) {
  const hmac = new sjcl.misc.hmac(
    bytesToBits(key),
    options.hashFunctionKeyDerivation,
  );
  hmac.update(bytesToBits(bytes));
  const result = hmac.digest();
  return bitsToBytes(result);
}

function bitsToBytes(arr) {
  const out = [];
  const bl = sjcl.bitArray.bitLength(arr);
  let tmp;
  for (let i = 0; i < bl / 8; i++) {
    if ((i & 3) === 0) {
      tmp = arr[i / 4];
    }
    out.push(tmp >>> 24);
    tmp <<= 8;
  }
  return out;
}

function bytesToBits(bytes) {
  const out = [];
  let i;
  let tmp = 0;
  for (i = 0; i < bytes.length; i++) {
    tmp = (tmp << 8) | bytes[i];
    if ((i & 3) === 3) {
      out.push(tmp);
      tmp = 0;
    }
  }
  if (i & 3) {
    out.push(sjcl.bitArray.partial(8 * (i & 3), tmp));
  }
  return out;
}

function createZeroBuffer(length) {
  const buf = Buffer.alloc(length);
  buf.fill(0);
  return buf;
}

function isString(obj) {
  return typeof obj === "string" || obj instanceof String;
}

module.exports.eciesDecryptMessage = eciesDecryptMessage;
module.exports.eciesEncryptMessage = eciesEncryptMessage;
