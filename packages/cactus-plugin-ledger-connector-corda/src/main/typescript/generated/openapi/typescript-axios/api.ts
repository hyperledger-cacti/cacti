/* tslint:disable */
/* eslint-disable */
/**
 * Hyperledger Cacti Plugin - Connector Corda
 * Can perform basic tasks on a Corda ledger
 *
 * The version of the OpenAPI document: 2.0.0-rc.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CPIIDV1
 */
export interface CPIIDV1 {
    /**
     * 
     * @type {string}
     * @memberof CPIIDV1
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CPIIDV1
     */
    'signerSummaryHash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CPIIDV1
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ClearMonitorTransactionsV1Request
 */
export interface ClearMonitorTransactionsV1Request {
    /**
     * ID of a client application that wants to monitor the state changes
     * @type {string}
     * @memberof ClearMonitorTransactionsV1Request
     */
    'clientAppId': string;
    /**
     * The fully qualified name of the Corda state to monitor
     * @type {string}
     * @memberof ClearMonitorTransactionsV1Request
     */
    'stateFullClassName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClearMonitorTransactionsV1Request
     */
    'txIndexes': Array<string>;
}
/**
 * 
 * @export
 * @interface ClearMonitorTransactionsV1Response
 */
export interface ClearMonitorTransactionsV1Response {
    /**
     * Flag set to true if operation completed correctly.
     * @type {boolean}
     * @memberof ClearMonitorTransactionsV1Response
     */
    'success': boolean;
    /**
     * Message describing operation status or any errors that occurred.
     * @type {string}
     * @memberof ClearMonitorTransactionsV1Response
     */
    'msg': string;
}
/**
 * 
 * @export
 * @interface CordaNodeSshCredentials
 */
export interface CordaNodeSshCredentials {
    /**
     * 
     * @type {string}
     * @memberof CordaNodeSshCredentials
     */
    'hostKeyEntry': string;
    /**
     * 
     * @type {string}
     * @memberof CordaNodeSshCredentials
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof CordaNodeSshCredentials
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CordaNodeSshCredentials
     */
    'hostname': string;
    /**
     * 
     * @type {number}
     * @memberof CordaNodeSshCredentials
     */
    'port': number;
}
/**
 * 
 * @export
 * @interface CordaRpcCredentials
 */
export interface CordaRpcCredentials {
    /**
     * 
     * @type {string}
     * @memberof CordaRpcCredentials
     */
    'hostname': string;
    /**
     * 
     * @type {number}
     * @memberof CordaRpcCredentials
     */
    'port': number;
    /**
     * 
     * @type {string}
     * @memberof CordaRpcCredentials
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof CordaRpcCredentials
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CordaX500Name
 */
export interface CordaX500Name {
    /**
     * 
     * @type {string}
     * @memberof CordaX500Name
     */
    'commonName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CordaX500Name
     */
    'organisationUnit'?: string;
    /**
     * 
     * @type {string}
     * @memberof CordaX500Name
     */
    'organisation': string;
    /**
     * 
     * @type {string}
     * @memberof CordaX500Name
     */
    'locality': string;
    /**
     * 
     * @type {string}
     * @memberof CordaX500Name
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof CordaX500Name
     */
    'country': string;
    /**
     * 
     * @type {X500Principal}
     * @memberof CordaX500Name
     */
    'x500Principal': X500Principal;
}
/**
 * 
 * @export
 * @interface CordappDeploymentConfig
 */
export interface CordappDeploymentConfig {
    /**
     * 
     * @type {CordaNodeSshCredentials}
     * @memberof CordappDeploymentConfig
     */
    'sshCredentials': CordaNodeSshCredentials;
    /**
     * 
     * @type {CordaRpcCredentials}
     * @memberof CordappDeploymentConfig
     */
    'rpcCredentials': CordaRpcCredentials;
    /**
     * The shell command to execute in order to start back up a Corda node after having placed new jars in the cordapp directory of said node.
     * @type {string}
     * @memberof CordappDeploymentConfig
     */
    'cordaNodeStartCmd': string;
    /**
     * The absolute file system path where the Corda Node is expecting deployed Cordapp jar files to be placed.
     * @type {string}
     * @memberof CordappDeploymentConfig
     */
    'cordappDir': string;
    /**
     * The absolute file system path where the corda.jar file of the node can be found. This is used to execute database schema migrations where applicable (H2 database in use in development environments).
     * @type {string}
     * @memberof CordappDeploymentConfig
     */
    'cordaJarPath': string;
    /**
     * The absolute file system path where the base directory of the Corda node can be found. This is used to pass in to corda.jar when being invoked for certain tasks such as executing database schema migrations for a deployed contract.
     * @type {string}
     * @memberof CordappDeploymentConfig
     */
    'nodeBaseDirPath': string;
}
/**
 * A CordappInfo describes a single CorDapp currently installed on the node
 * @export
 * @interface CordappInfo
 */
export interface CordappInfo {
    /**
     * 
     * @type {SHA256}
     * @memberof CordappInfo
     */
    'jarHash': SHA256;
    /**
     * The name of the licence this CorDapp is released under
     * @type {string}
     * @memberof CordappInfo
     */
    'licence': string;
    /**
     * The minimum platform version the node must be at for the CorDapp to run
     * @type {number}
     * @memberof CordappInfo
     */
    'minimumPlatformVersion': number;
    /**
     * The name of the JAR file that defines the CorDapp
     * @type {string}
     * @memberof CordappInfo
     */
    'name': string;
    /**
     * The name of the CorDapp
     * @type {string}
     * @memberof CordappInfo
     */
    'shortName': string;
    /**
     * The target platform version this CorDapp has been tested against
     * @type {number}
     * @memberof CordappInfo
     */
    'targetPlatformVersion': number;
    /**
     * A description of what sort of CorDapp this is - either a contract, workflow, or a combination.
     * @type {string}
     * @memberof CordappInfo
     */
    'type': string;
    /**
     * The vendor of this CorDapp
     * @type {string}
     * @memberof CordappInfo
     */
    'vendor': string;
    /**
     * The version of this CorDapp
     * @type {string}
     * @memberof CordappInfo
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface DeployContractJarsBadRequestV1Response
 */
export interface DeployContractJarsBadRequestV1Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployContractJarsBadRequestV1Response
     */
    'errors': Array<string>;
}
/**
 * 
 * @export
 * @interface DeployContractJarsSuccessV1Response
 */
export interface DeployContractJarsSuccessV1Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployContractJarsSuccessV1Response
     */
    'deployedJarFiles': Array<string>;
}
/**
 * 
 * @export
 * @interface DeployContractJarsV1Request
 */
export interface DeployContractJarsV1Request {
    /**
     * The list of deployment configurations pointing to the nodes where the provided cordapp jar files are to be deployed .
     * @type {Array<CordappDeploymentConfig>}
     * @memberof DeployContractJarsV1Request
     */
    'cordappDeploymentConfigs': Array<CordappDeploymentConfig>;
    /**
     * 
     * @type {Array<JarFile>}
     * @memberof DeployContractJarsV1Request
     */
    'jarFiles': Array<JarFile>;
}
/**
 * 
 * @export
 * @interface DiagnoseNodeV1Request
 */
export interface DiagnoseNodeV1Request {
    /**
     * Optional property specifying which Corda Node should be the one being diagnosed in case the Connector has multiple connections established for different nodes (which is not yet a supported feature, but we want to keep this possibility open for the future).
     * @type {Array<string>}
     * @memberof DiagnoseNodeV1Request
     */
    'nodeIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DiagnoseNodeV1Response
 */
export interface DiagnoseNodeV1Response {
    /**
     * 
     * @type {NodeDiagnosticInfo}
     * @memberof DiagnoseNodeV1Response
     */
    'nodeDiagnosticInfo': NodeDiagnosticInfo;
}
/**
 * Determines which flow starting method will be used on the back-end when invoking the flow. Based on the value here the plugin back-end might invoke the rpc.startFlowDynamic() method or the rpc.startTrackedFlowDynamic() method. Streamed responses are aggregated and returned in a single response to HTTP callers who are not equipped to handle streams like WebSocket/gRPC/etc. do.
 * @export
 * @enum {string}
 */

export const FlowInvocationType = {
    TrackedFlowDynamic: 'TRACKED_FLOW_DYNAMIC',
    FlowDynamic: 'FLOW_DYNAMIC'
} as const;

export type FlowInvocationType = typeof FlowInvocationType[keyof typeof FlowInvocationType];


/**
 * 
 * @export
 * @interface FlowStatusV1Responses
 */
export interface FlowStatusV1Responses {
    /**
     * 
     * @type {Array<FlowStatusV1ResponsesFlowStatusResponsesInner>}
     * @memberof FlowStatusV1Responses
     */
    'flowStatusResponses'?: Array<FlowStatusV1ResponsesFlowStatusResponsesInner>;
}
/**
 * 
 * @export
 * @interface FlowStatusV1ResponsesFlowStatusResponsesInner
 */
export interface FlowStatusV1ResponsesFlowStatusResponsesInner {
    /**
     * 
     * @type {string}
     * @memberof FlowStatusV1ResponsesFlowStatusResponsesInner
     */
    'clientRequestId'?: string | null;
    /**
     * 
     * @type {FlowV1Error}
     * @memberof FlowStatusV1ResponsesFlowStatusResponsesInner
     */
    'flowError'?: FlowV1Error;
    /**
     * 
     * @type {string}
     * @memberof FlowStatusV1ResponsesFlowStatusResponsesInner
     */
    'flowId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowStatusV1ResponsesFlowStatusResponsesInner
     */
    'flowResult'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowStatusV1ResponsesFlowStatusResponsesInner
     */
    'flowStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlowStatusV1ResponsesFlowStatusResponsesInner
     */
    'holdingIDShortHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlowStatusV1ResponsesFlowStatusResponsesInner
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface FlowV1Error
 */
export interface FlowV1Error {
    /**
     * 
     * @type {string}
     * @memberof FlowV1Error
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof FlowV1Error
     */
    'type': string;
}
/**
 * This method gets the current status of the specified flow instance.
 * @export
 * @interface GetFlowCidV1Request
 */
export interface GetFlowCidV1Request {
    /**
     * 
     * @type {string}
     * @memberof GetFlowCidV1Request
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof GetFlowCidV1Request
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetFlowCidV1Request
     */
    'rejectUnauthorized': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetFlowCidV1Request
     */
    'holdingIDShortHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFlowCidV1Request
     */
    'clientRequestId'?: string;
}
/**
 * 
 * @export
 * @interface GetFlowCidV1Response
 */
export interface GetFlowCidV1Response {
    /**
     * 
     * @type {string}
     * @memberof GetFlowCidV1Response
     */
    'clientRequestId'?: string | null;
    /**
     * 
     * @type {FlowV1Error}
     * @memberof GetFlowCidV1Response
     */
    'flowError'?: FlowV1Error;
    /**
     * 
     * @type {string}
     * @memberof GetFlowCidV1Response
     */
    'flowId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetFlowCidV1Response
     */
    'flowResult'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetFlowCidV1Response
     */
    'flowStatus': string;
    /**
     * 
     * @type {string}
     * @memberof GetFlowCidV1Response
     */
    'holdingIDShortHash': string;
    /**
     * 
     * @type {string}
     * @memberof GetFlowCidV1Response
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface GetMonitorTransactionsV1Request
 */
export interface GetMonitorTransactionsV1Request {
    /**
     * ID of a client application that wants to monitor the state changes
     * @type {string}
     * @memberof GetMonitorTransactionsV1Request
     */
    'clientAppId': string;
    /**
     * The fully qualified name of the Corda state to monitor
     * @type {string}
     * @memberof GetMonitorTransactionsV1Request
     */
    'stateFullClassName': string;
}
/**
 * 
 * @export
 * @interface GetMonitorTransactionsV1Response
 */
export interface GetMonitorTransactionsV1Response {
    /**
     * Flag set to true if operation completed correctly.
     * @type {boolean}
     * @memberof GetMonitorTransactionsV1Response
     */
    'success': boolean;
    /**
     * Message describing operation status or any errors that occurred.
     * @type {string}
     * @memberof GetMonitorTransactionsV1Response
     */
    'msg': string;
    /**
     * The fully qualified name of the Corda state to monitor
     * @type {string}
     * @memberof GetMonitorTransactionsV1Response
     */
    'stateFullClassName'?: string;
    /**
     * 
     * @type {Array<GetMonitorTransactionsV1ResponseTxInner>}
     * @memberof GetMonitorTransactionsV1Response
     */
    'tx'?: Array<GetMonitorTransactionsV1ResponseTxInner>;
}
/**
 * 
 * @export
 * @interface GetMonitorTransactionsV1ResponseTxInner
 */
export interface GetMonitorTransactionsV1ResponseTxInner {
    /**
     * 
     * @type {string}
     * @memberof GetMonitorTransactionsV1ResponseTxInner
     */
    'index'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMonitorTransactionsV1ResponseTxInner
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface InvokeContractV1Request
 */
export interface InvokeContractV1Request {
    /**
     * The fully qualified name of the Corda flow to invoke
     * @type {string}
     * @memberof InvokeContractV1Request
     */
    'flowFullClassName': string;
    /**
     * 
     * @type {FlowInvocationType}
     * @memberof InvokeContractV1Request
     */
    'flowInvocationType': FlowInvocationType;
    /**
     * The list of arguments to pass in to the contract method being invoked.
     * @type {Array<JvmObject>}
     * @memberof InvokeContractV1Request
     */
    'params': Array<JvmObject>;
    /**
     * The amount of milliseconds to wait for a transaction receipt beforegiving up and crashing.
     * @type {number}
     * @memberof InvokeContractV1Request
     */
    'timeoutMs'?: number;
}


/**
 * 
 * @export
 * @interface InvokeContractV1Response
 */
export interface InvokeContractV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof InvokeContractV1Response
     */
    'success': boolean;
    /**
     * Data returned from the JVM when no transaction is running
     * @type {object}
     * @memberof InvokeContractV1Response
     */
    'callOutput': object;
    /**
     * The net.corda.core.flows.StateMachineRunId value returned by the flow execution.
     * @type {string}
     * @memberof InvokeContractV1Response
     */
    'transactionId'?: string;
    /**
     * An array of strings representing the aggregated stream of progress updates provided by a *tracked* flow invocation. If the flow invocation was not tracked, this array is still returned, but as empty.
     * @type {Array<string>}
     * @memberof InvokeContractV1Response
     */
    'progress'?: Array<string>;
    /**
     * The id for the flow handle
     * @type {string}
     * @memberof InvokeContractV1Response
     */
    'flowId': string;
}
/**
 * 
 * @export
 * @interface JarFile
 */
export interface JarFile {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof JarFile
     */
    'filename': string;
    /**
     * Indicates whether the cordapp jar in question contains any embedded migrations that Cactus can/should execute between copying the jar into the cordapp directory and starting the node back up.
     * @type {boolean}
     * @memberof JarFile
     */
    'hasDbMigrations': boolean;
    /**
     * 
     * @type {string}
     * @memberof JarFile
     */
    'contentBase64': string;
}
/**
 * Can represent JVM primitive and reference types as well. The jvmTypeKind field indicates which one is being stored. If the jvmTypeKind field is set to REFERENCE then the jvmCtorArgs array is expected to be filled, otherwise (e.g. PRIMITIVE jvmTypeKind) it is expected that the primitiveValue property is filled with a primitive data type supported by the JSON standard such as strings, booleans, numbers, etc.
 * @export
 * @interface JvmObject
 */
export interface JvmObject {
    /**
     * 
     * @type {JvmTypeKind}
     * @memberof JvmObject
     */
    'jvmTypeKind': JvmTypeKind;
    /**
     * 
     * @type {any}
     * @memberof JvmObject
     */
    'primitiveValue'?: any;
    /**
     * 
     * @type {Array<JvmObject>}
     * @memberof JvmObject
     */
    'jvmCtorArgs'?: Array<JvmObject>;
    /**
     * 
     * @type {JvmType}
     * @memberof JvmObject
     */
    'jvmType': JvmType;
}


/**
 * Represents a reference to a JVM type (such as a Java class)
 * @export
 * @interface JvmType
 */
export interface JvmType {
    /**
     * 
     * @type {string}
     * @memberof JvmType
     */
    'fqClassName': string;
    /**
     * This parameter is used to specify that the function used to construct this JvmType is not a constructor function but instead is a factory function. Setting this parameter will cause the plugin to look up methods of the class denoted by fqClassName instead of its constructors.
     * @type {string}
     * @memberof JvmType
     */
    'constructorName'?: string;
    /**
     * 
     * @type {JvmObject}
     * @memberof JvmType
     */
    'invocationTarget'?: JvmObject;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JvmTypeKind = {
    Primitive: 'PRIMITIVE',
    Reference: 'REFERENCE'
} as const;

export type JvmTypeKind = typeof JvmTypeKind[keyof typeof JvmTypeKind];


/**
 * 
 * @export
 * @interface ListCpiV1Request
 */
export interface ListCpiV1Request {
    /**
     * 
     * @type {string}
     * @memberof ListCpiV1Request
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof ListCpiV1Request
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListCpiV1Request
     */
    'rejectUnauthorized': boolean;
}
/**
 * 
 * @export
 * @interface ListCpiV1Response
 */
export interface ListCpiV1Response {
    /**
     * 
     * @type {Array<ListCpiV1ResponseCpisInner>}
     * @memberof ListCpiV1Response
     */
    'cpis'?: Array<ListCpiV1ResponseCpisInner>;
}
/**
 * 
 * @export
 * @interface ListCpiV1ResponseCpisInner
 */
export interface ListCpiV1ResponseCpisInner {
    /**
     * 
     * @type {string}
     * @memberof ListCpiV1ResponseCpisInner
     */
    'cpiFileChecksum'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListCpiV1ResponseCpisInner
     */
    'cpiFileFullChecksum'?: string;
    /**
     * 
     * @type {Array<ListCpiV1ResponseCpisInnerCpksInner>}
     * @memberof ListCpiV1ResponseCpisInner
     */
    'cpks'?: Array<ListCpiV1ResponseCpisInnerCpksInner>;
    /**
     * 
     * @type {string}
     * @memberof ListCpiV1ResponseCpisInner
     */
    'groupPolicy'?: string | null;
    /**
     * 
     * @type {CPIIDV1}
     * @memberof ListCpiV1ResponseCpisInner
     */
    'id'?: CPIIDV1;
    /**
     * 
     * @type {string}
     * @memberof ListCpiV1ResponseCpisInner
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface ListCpiV1ResponseCpisInnerCpksInner
 */
export interface ListCpiV1ResponseCpisInnerCpksInner {
    /**
     * 
     * @type {string}
     * @memberof ListCpiV1ResponseCpisInnerCpksInner
     */
    'hash'?: string;
    /**
     * 
     * @type {CPIIDV1}
     * @memberof ListCpiV1ResponseCpisInnerCpksInner
     */
    'id'?: CPIIDV1;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListCpiV1ResponseCpisInnerCpksInner
     */
    'libraries'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListCpiV1ResponseCpisInnerCpksInner
     */
    'mainBundle'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListCpiV1ResponseCpisInnerCpksInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListCpiV1ResponseCpisInnerCpksInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ListFlowsV1Request
 */
export interface ListFlowsV1Request {
    /**
     * 
     * @type {string}
     * @memberof ListFlowsV1Request
     */
    'filter'?: string;
}
/**
 * 
 * @export
 * @interface ListFlowsV1Response
 */
export interface ListFlowsV1Response {
    /**
     * An array of strings storing the names of the flows as returned by the flowList Corda RPC.
     * @type {Array<string>}
     * @memberof ListFlowsV1Response
     */
    'flowNames': Array<string>;
}
/**
 * 
 * @export
 * @interface NetworkHostAndPort
 */
export interface NetworkHostAndPort {
    /**
     * 
     * @type {string}
     * @memberof NetworkHostAndPort
     */
    'host': string;
    /**
     * 
     * @type {number}
     * @memberof NetworkHostAndPort
     */
    'port': number;
}
/**
 * A NodeDiagnosticInfo holds information about the current node version.
 * @export
 * @interface NodeDiagnosticInfo
 */
export interface NodeDiagnosticInfo {
    /**
     * A list of CorDapps currently installed on this node
     * @type {Array<CordappInfo>}
     * @memberof NodeDiagnosticInfo
     */
    'cordapps': Array<CordappInfo>;
    /**
     * The platform version of this node. This number represents a released API version, and should be used to make functionality decisions (e.g. enabling an app feature only if an underlying platform feature exists)
     * @type {number}
     * @memberof NodeDiagnosticInfo
     */
    'platformVersion': number;
    /**
     * The git commit hash this node was built from
     * @type {string}
     * @memberof NodeDiagnosticInfo
     */
    'revision': string;
    /**
     * The vendor of this node
     * @type {string}
     * @memberof NodeDiagnosticInfo
     */
    'vendor': string;
    /**
     * The current node version string, e.g. 4.3, 4.4-SNAPSHOT. Note that this string is effectively freeform, and so should only be used for providing diagnostic information. It should not be used to make functionality decisions (the platformVersion is a better fit for this).
     * @type {string}
     * @memberof NodeDiagnosticInfo
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface NodeInfo
 */
export interface NodeInfo {
    /**
     * 
     * @type {Array<NetworkHostAndPort>}
     * @memberof NodeInfo
     */
    'addresses': Array<NetworkHostAndPort>;
    /**
     * 
     * @type {number}
     * @memberof NodeInfo
     */
    'platformVersion': number;
    /**
     * 
     * @type {number}
     * @memberof NodeInfo
     */
    'serial': number;
    /**
     * 
     * @type {Array<Party>}
     * @memberof NodeInfo
     */
    'legalIdentities': Array<Party>;
    /**
     * 
     * @type {Array<object>}
     * @memberof NodeInfo
     */
    'legalIdentitiesAndCerts': Array<object>;
}
/**
 * 
 * @export
 * @interface Party
 */
export interface Party {
    /**
     * 
     * @type {CordaX500Name}
     * @memberof Party
     */
    'name': CordaX500Name;
    /**
     * 
     * @type {PublicKey}
     * @memberof Party
     */
    'owningKey': PublicKey;
}
/**
 * An instance of a java.security.PublicKey (which is an interface) implementation such as org.hyperledger.cactus.plugin.ledger.connector.corda.server.impl.PublicKeyImpl
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'algorithm': string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'format': string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'encoded': string;
}
/**
 * SHA-256 is part of the SHA-2 hash function family. Generated hash is fixed size, 256-bits (32-bytes).
 * @export
 * @interface SHA256
 */
export interface SHA256 {
    /**
     * 
     * @type {string}
     * @memberof SHA256
     */
    'bytes': string;
    /**
     * 
     * @type {number}
     * @memberof SHA256
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof SHA256
     */
    'size': number;
}
/**
 * This method starts a new instance for the specified flow for the specified holding identity.
 * @export
 * @interface StartFlowV1Request
 */
export interface StartFlowV1Request {
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1Request
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1Request
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof StartFlowV1Request
     */
    'rejectUnauthorized': boolean;
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1Request
     */
    'holdingIDShortHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1Request
     */
    'clientRequestId': string;
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1Request
     */
    'flowClassName': string;
    /**
     * 
     * @type {StartFlowV1RequestRequestBody}
     * @memberof StartFlowV1Request
     */
    'requestBody': StartFlowV1RequestRequestBody;
}
/**
 * 
 * @export
 * @interface StartFlowV1RequestRequestBody
 */
export interface StartFlowV1RequestRequestBody {
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1RequestRequestBody
     */
    'chatName'?: string;
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1RequestRequestBody
     */
    'otherMember'?: string;
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1RequestRequestBody
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1RequestRequestBody
     */
    'numberOfRecords'?: string;
}
/**
 * 
 * @export
 * @interface StartFlowV1Response
 */
export interface StartFlowV1Response {
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1Response
     */
    'clientRequestId'?: string | null;
    /**
     * 
     * @type {FlowV1Error}
     * @memberof StartFlowV1Response
     */
    'flowError'?: FlowV1Error;
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1Response
     */
    'flowId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1Response
     */
    'flowResult'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1Response
     */
    'flowStatus': string;
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1Response
     */
    'holdingIDShortHash': string;
    /**
     * 
     * @type {string}
     * @memberof StartFlowV1Response
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface StartMonitorV1Request
 */
export interface StartMonitorV1Request {
    /**
     * ID of a client application that wants to monitor the state changes
     * @type {string}
     * @memberof StartMonitorV1Request
     */
    'clientAppId': string;
    /**
     * The fully qualified name of the Corda state to monitor
     * @type {string}
     * @memberof StartMonitorV1Request
     */
    'stateFullClassName': string;
}
/**
 * 
 * @export
 * @interface StartMonitorV1Response
 */
export interface StartMonitorV1Response {
    /**
     * Flag set to true if monitoring started correctly.
     * @type {boolean}
     * @memberof StartMonitorV1Response
     */
    'success': boolean;
    /**
     * Message describing operation status or any errors that occurred.
     * @type {string}
     * @memberof StartMonitorV1Response
     */
    'msg': string;
}
/**
 * 
 * @export
 * @interface StopMonitorV1Request
 */
export interface StopMonitorV1Request {
    /**
     * ID of a client application that wants to monitor the state changes
     * @type {string}
     * @memberof StopMonitorV1Request
     */
    'clientAppId': string;
    /**
     * The fully qualified name of the Corda state to monitor
     * @type {string}
     * @memberof StopMonitorV1Request
     */
    'stateFullClassName': string;
}
/**
 * 
 * @export
 * @interface StopMonitorV1Response
 */
export interface StopMonitorV1Response {
    /**
     * Flag set to true if operation completed correctly.
     * @type {boolean}
     * @memberof StopMonitorV1Response
     */
    'success': boolean;
    /**
     * Message describing operation status or any errors that occurred.
     * @type {string}
     * @memberof StopMonitorV1Response
     */
    'msg': string;
}
/**
 * 
 * @export
 * @interface VaultQueryV1Request
 */
export interface VaultQueryV1Request {
    /**
     * Valid, fully qualified JVM class name which will be fed into Class.forName(...)
     * @type {string}
     * @memberof VaultQueryV1Request
     */
    'contractStateType'?: string;
}
/**
 * 
 * @export
 * @interface X500Principal
 */
export interface X500Principal {
    /**
     * 
     * @type {string}
     * @memberof X500Principal
     */
    'name': string;
    /**
     * Base64 encoded public key
     * @type {string}
     * @memberof X500Principal
     */
    'encoded': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear transactions from internal store so they\'ll not be available by GetMonitorTransactionsV1 anymore.
         * @param {ClearMonitorTransactionsV1Request} clearMonitorTransactionsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearMonitorTransactionsV1: async (clearMonitorTransactionsV1Request: ClearMonitorTransactionsV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clearMonitorTransactionsV1Request' is not null or undefined
            assertParamExists('clearMonitorTransactionsV1', 'clearMonitorTransactionsV1Request', clearMonitorTransactionsV1Request)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/clear-monitor-transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clearMonitorTransactionsV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deploys a set of jar files (Cordapps, e.g. the contracts in Corda speak).
         * @param {DeployContractJarsV1Request} deployContractJarsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractJarsV1: async (deployContractJarsV1Request: DeployContractJarsV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deployContractJarsV1Request' is not null or undefined
            assertParamExists('deployContractJarsV1', 'deployContractJarsV1Request', deployContractJarsV1Request)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/deploy-contract-jars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployContractJarsV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Responds with diagnostic information about the Corda node
         * @param {DiagnoseNodeV1Request} [diagnoseNodeV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseNodeV1: async (diagnoseNodeV1Request?: DiagnoseNodeV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/diagnose-node`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(diagnoseNodeV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This method gets the current status of the specified flow instance.
         * @param {GetFlowCidV1Request} getFlowCidV1Request This method gets the current status of the specified flow instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlowV1: async (getFlowCidV1Request: GetFlowCidV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getFlowCidV1Request' is not null or undefined
            assertParamExists('getFlowV1', 'getFlowCidV1Request', getFlowCidV1Request)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/get-flow-cid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getFlowCidV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transactions for monitored state classes.
         * @param {GetMonitorTransactionsV1Request} getMonitorTransactionsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitorTransactionsV1: async (getMonitorTransactionsV1Request: GetMonitorTransactionsV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getMonitorTransactionsV1Request' is not null or undefined
            assertParamExists('getMonitorTransactionsV1', 'getMonitorTransactionsV1Request', getMonitorTransactionsV1Request)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/get-monitor-transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getMonitorTransactionsV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrometheusMetricsV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/get-prometheus-exporter-metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invokes a contract on a Corda ledger (e.g. a flow)
         * @param {InvokeContractV1Request} invokeContractV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeContractV1: async (invokeContractV1Request: InvokeContractV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invokeContractV1Request' is not null or undefined
            assertParamExists('invokeContractV1', 'invokeContractV1Request', invokeContractV1Request)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/invoke-contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invokeContractV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all CPIs uploaded to the cluster
         * @param {ListCpiV1Request} listCpiV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCpiV1: async (listCpiV1Request: ListCpiV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listCpiV1Request' is not null or undefined
            assertParamExists('listCpiV1', 'listCpiV1Request', listCpiV1Request)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/list-cpi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listCpiV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This method returns an array containing the statuses of all flows running for a specified holding identity. An empty array is returned if there are no flows running.
         * @param {GetFlowCidV1Request} getFlowCidV1Request This method gets the current status of the specified flow instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlowV1: async (getFlowCidV1Request: GetFlowCidV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getFlowCidV1Request' is not null or undefined
            assertParamExists('listFlowV1', 'getFlowCidV1Request', getFlowCidV1Request)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/list-flow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getFlowCidV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Responds with a list of the flows on the Corda node.
         * @param {ListFlowsV1Request} [listFlowsV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlowsV1: async (listFlowsV1Request?: ListFlowsV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/list-flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listFlowsV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Responds with a snapshot of the network map as provided by the Corda RPC call: net.corda.core.messaging.CordaRPCOps public abstract fun networkMapSnapshot(): List<NodeInfo>
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkMapV1: async (body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/network-map`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This method starts a new instance for the specified flow for the specified holding identity.
         * @param {StartFlowV1Request} startFlowV1Request Request body for starting a flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startFlowV1: async (startFlowV1Request: StartFlowV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startFlowV1Request' is not null or undefined
            assertParamExists('startFlowV1', 'startFlowV1Request', startFlowV1Request)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/start-flow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startFlowV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start monitoring corda changes (transactions) of given state class
         * @param {StartMonitorV1Request} startMonitorV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startMonitorV1: async (startMonitorV1Request: StartMonitorV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startMonitorV1Request' is not null or undefined
            assertParamExists('startMonitorV1', 'startMonitorV1Request', startMonitorV1Request)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/start-monitor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startMonitorV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop monitoring corda changes (transactions) of given state class
         * @param {StopMonitorV1Request} stopMonitorV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopMonitorV1: async (stopMonitorV1Request: StopMonitorV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stopMonitorV1Request' is not null or undefined
            assertParamExists('stopMonitorV1', 'stopMonitorV1Request', stopMonitorV1Request)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/stop-monitor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stopMonitorV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queryes the vault service for state references based on JVM class names. Custom filters are not supported by this endpoint.
         * @param {VaultQueryV1Request} vaultQueryV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultQueryV1: async (vaultQueryV1Request: VaultQueryV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultQueryV1Request' is not null or undefined
            assertParamExists('vaultQueryV1', 'vaultQueryV1Request', vaultQueryV1Request)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/vault-query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vaultQueryV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clear transactions from internal store so they\'ll not be available by GetMonitorTransactionsV1 anymore.
         * @param {ClearMonitorTransactionsV1Request} clearMonitorTransactionsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearMonitorTransactionsV1(clearMonitorTransactionsV1Request: ClearMonitorTransactionsV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClearMonitorTransactionsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearMonitorTransactionsV1(clearMonitorTransactionsV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deploys a set of jar files (Cordapps, e.g. the contracts in Corda speak).
         * @param {DeployContractJarsV1Request} deployContractJarsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployContractJarsV1(deployContractJarsV1Request: DeployContractJarsV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContractJarsSuccessV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployContractJarsV1(deployContractJarsV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Responds with diagnostic information about the Corda node
         * @param {DiagnoseNodeV1Request} [diagnoseNodeV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseNodeV1(diagnoseNodeV1Request?: DiagnoseNodeV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiagnoseNodeV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseNodeV1(diagnoseNodeV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary This method gets the current status of the specified flow instance.
         * @param {GetFlowCidV1Request} getFlowCidV1Request This method gets the current status of the specified flow instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlowV1(getFlowCidV1Request: GetFlowCidV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFlowCidV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlowV1(getFlowCidV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get transactions for monitored state classes.
         * @param {GetMonitorTransactionsV1Request} getMonitorTransactionsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMonitorTransactionsV1(getMonitorTransactionsV1Request: GetMonitorTransactionsV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMonitorTransactionsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMonitorTransactionsV1(getMonitorTransactionsV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrometheusMetricsV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrometheusMetricsV1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invokes a contract on a Corda ledger (e.g. a flow)
         * @param {InvokeContractV1Request} invokeContractV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeContractV1(invokeContractV1Request: InvokeContractV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvokeContractV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invokeContractV1(invokeContractV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all CPIs uploaded to the cluster
         * @param {ListCpiV1Request} listCpiV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCpiV1(listCpiV1Request: ListCpiV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCpiV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCpiV1(listCpiV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary This method returns an array containing the statuses of all flows running for a specified holding identity. An empty array is returned if there are no flows running.
         * @param {GetFlowCidV1Request} getFlowCidV1Request This method gets the current status of the specified flow instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFlowV1(getFlowCidV1Request: GetFlowCidV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowStatusV1Responses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFlowV1(getFlowCidV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Responds with a list of the flows on the Corda node.
         * @param {ListFlowsV1Request} [listFlowsV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFlowsV1(listFlowsV1Request?: ListFlowsV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFlowsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFlowsV1(listFlowsV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Responds with a snapshot of the network map as provided by the Corda RPC call: net.corda.core.messaging.CordaRPCOps public abstract fun networkMapSnapshot(): List<NodeInfo>
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkMapV1(body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkMapV1(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary This method starts a new instance for the specified flow for the specified holding identity.
         * @param {StartFlowV1Request} startFlowV1Request Request body for starting a flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startFlowV1(startFlowV1Request: StartFlowV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartFlowV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startFlowV1(startFlowV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start monitoring corda changes (transactions) of given state class
         * @param {StartMonitorV1Request} startMonitorV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startMonitorV1(startMonitorV1Request: StartMonitorV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartMonitorV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startMonitorV1(startMonitorV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop monitoring corda changes (transactions) of given state class
         * @param {StopMonitorV1Request} stopMonitorV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopMonitorV1(stopMonitorV1Request: StopMonitorV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopMonitorV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopMonitorV1(stopMonitorV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Queryes the vault service for state references based on JVM class names. Custom filters are not supported by this endpoint.
         * @param {VaultQueryV1Request} vaultQueryV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vaultQueryV1(vaultQueryV1Request: VaultQueryV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vaultQueryV1(vaultQueryV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Clear transactions from internal store so they\'ll not be available by GetMonitorTransactionsV1 anymore.
         * @param {ClearMonitorTransactionsV1Request} clearMonitorTransactionsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearMonitorTransactionsV1(clearMonitorTransactionsV1Request: ClearMonitorTransactionsV1Request, options?: any): AxiosPromise<ClearMonitorTransactionsV1Response> {
            return localVarFp.clearMonitorTransactionsV1(clearMonitorTransactionsV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deploys a set of jar files (Cordapps, e.g. the contracts in Corda speak).
         * @param {DeployContractJarsV1Request} deployContractJarsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractJarsV1(deployContractJarsV1Request: DeployContractJarsV1Request, options?: any): AxiosPromise<DeployContractJarsSuccessV1Response> {
            return localVarFp.deployContractJarsV1(deployContractJarsV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds with diagnostic information about the Corda node
         * @param {DiagnoseNodeV1Request} [diagnoseNodeV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseNodeV1(diagnoseNodeV1Request?: DiagnoseNodeV1Request, options?: any): AxiosPromise<DiagnoseNodeV1Response> {
            return localVarFp.diagnoseNodeV1(diagnoseNodeV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This method gets the current status of the specified flow instance.
         * @param {GetFlowCidV1Request} getFlowCidV1Request This method gets the current status of the specified flow instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlowV1(getFlowCidV1Request: GetFlowCidV1Request, options?: any): AxiosPromise<GetFlowCidV1Response> {
            return localVarFp.getFlowV1(getFlowCidV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transactions for monitored state classes.
         * @param {GetMonitorTransactionsV1Request} getMonitorTransactionsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitorTransactionsV1(getMonitorTransactionsV1Request: GetMonitorTransactionsV1Request, options?: any): AxiosPromise<GetMonitorTransactionsV1Response> {
            return localVarFp.getMonitorTransactionsV1(getMonitorTransactionsV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrometheusMetricsV1(options?: any): AxiosPromise<string> {
            return localVarFp.getPrometheusMetricsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invokes a contract on a Corda ledger (e.g. a flow)
         * @param {InvokeContractV1Request} invokeContractV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeContractV1(invokeContractV1Request: InvokeContractV1Request, options?: any): AxiosPromise<InvokeContractV1Response> {
            return localVarFp.invokeContractV1(invokeContractV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all CPIs uploaded to the cluster
         * @param {ListCpiV1Request} listCpiV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCpiV1(listCpiV1Request: ListCpiV1Request, options?: any): AxiosPromise<ListCpiV1Response> {
            return localVarFp.listCpiV1(listCpiV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This method returns an array containing the statuses of all flows running for a specified holding identity. An empty array is returned if there are no flows running.
         * @param {GetFlowCidV1Request} getFlowCidV1Request This method gets the current status of the specified flow instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlowV1(getFlowCidV1Request: GetFlowCidV1Request, options?: any): AxiosPromise<FlowStatusV1Responses> {
            return localVarFp.listFlowV1(getFlowCidV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds with a list of the flows on the Corda node.
         * @param {ListFlowsV1Request} [listFlowsV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlowsV1(listFlowsV1Request?: ListFlowsV1Request, options?: any): AxiosPromise<ListFlowsV1Response> {
            return localVarFp.listFlowsV1(listFlowsV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds with a snapshot of the network map as provided by the Corda RPC call: net.corda.core.messaging.CordaRPCOps public abstract fun networkMapSnapshot(): List<NodeInfo>
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkMapV1(body?: object, options?: any): AxiosPromise<Array<NodeInfo>> {
            return localVarFp.networkMapV1(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This method starts a new instance for the specified flow for the specified holding identity.
         * @param {StartFlowV1Request} startFlowV1Request Request body for starting a flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startFlowV1(startFlowV1Request: StartFlowV1Request, options?: any): AxiosPromise<StartFlowV1Response> {
            return localVarFp.startFlowV1(startFlowV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start monitoring corda changes (transactions) of given state class
         * @param {StartMonitorV1Request} startMonitorV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startMonitorV1(startMonitorV1Request: StartMonitorV1Request, options?: any): AxiosPromise<StartMonitorV1Response> {
            return localVarFp.startMonitorV1(startMonitorV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop monitoring corda changes (transactions) of given state class
         * @param {StopMonitorV1Request} stopMonitorV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopMonitorV1(stopMonitorV1Request: StopMonitorV1Request, options?: any): AxiosPromise<StopMonitorV1Response> {
            return localVarFp.stopMonitorV1(stopMonitorV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Queryes the vault service for state references based on JVM class names. Custom filters are not supported by this endpoint.
         * @param {VaultQueryV1Request} vaultQueryV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultQueryV1(vaultQueryV1Request: VaultQueryV1Request, options?: any): AxiosPromise<object> {
            return localVarFp.vaultQueryV1(vaultQueryV1Request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Clear transactions from internal store so they\'ll not be available by GetMonitorTransactionsV1 anymore.
     * @param {ClearMonitorTransactionsV1Request} clearMonitorTransactionsV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clearMonitorTransactionsV1(clearMonitorTransactionsV1Request: ClearMonitorTransactionsV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clearMonitorTransactionsV1(clearMonitorTransactionsV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deploys a set of jar files (Cordapps, e.g. the contracts in Corda speak).
     * @param {DeployContractJarsV1Request} deployContractJarsV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deployContractJarsV1(deployContractJarsV1Request: DeployContractJarsV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deployContractJarsV1(deployContractJarsV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Responds with diagnostic information about the Corda node
     * @param {DiagnoseNodeV1Request} [diagnoseNodeV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public diagnoseNodeV1(diagnoseNodeV1Request?: DiagnoseNodeV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).diagnoseNodeV1(diagnoseNodeV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This method gets the current status of the specified flow instance.
     * @param {GetFlowCidV1Request} getFlowCidV1Request This method gets the current status of the specified flow instance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFlowV1(getFlowCidV1Request: GetFlowCidV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFlowV1(getFlowCidV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transactions for monitored state classes.
     * @param {GetMonitorTransactionsV1Request} getMonitorTransactionsV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMonitorTransactionsV1(getMonitorTransactionsV1Request: GetMonitorTransactionsV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMonitorTransactionsV1(getMonitorTransactionsV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Prometheus Metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPrometheusMetricsV1(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPrometheusMetricsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invokes a contract on a Corda ledger (e.g. a flow)
     * @param {InvokeContractV1Request} invokeContractV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public invokeContractV1(invokeContractV1Request: InvokeContractV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).invokeContractV1(invokeContractV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all CPIs uploaded to the cluster
     * @param {ListCpiV1Request} listCpiV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listCpiV1(listCpiV1Request: ListCpiV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listCpiV1(listCpiV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This method returns an array containing the statuses of all flows running for a specified holding identity. An empty array is returned if there are no flows running.
     * @param {GetFlowCidV1Request} getFlowCidV1Request This method gets the current status of the specified flow instance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listFlowV1(getFlowCidV1Request: GetFlowCidV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listFlowV1(getFlowCidV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Responds with a list of the flows on the Corda node.
     * @param {ListFlowsV1Request} [listFlowsV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listFlowsV1(listFlowsV1Request?: ListFlowsV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listFlowsV1(listFlowsV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Responds with a snapshot of the network map as provided by the Corda RPC call: net.corda.core.messaging.CordaRPCOps public abstract fun networkMapSnapshot(): List<NodeInfo>
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkMapV1(body?: object, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).networkMapV1(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This method starts a new instance for the specified flow for the specified holding identity.
     * @param {StartFlowV1Request} startFlowV1Request Request body for starting a flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startFlowV1(startFlowV1Request: StartFlowV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startFlowV1(startFlowV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start monitoring corda changes (transactions) of given state class
     * @param {StartMonitorV1Request} startMonitorV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startMonitorV1(startMonitorV1Request: StartMonitorV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startMonitorV1(startMonitorV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop monitoring corda changes (transactions) of given state class
     * @param {StopMonitorV1Request} stopMonitorV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stopMonitorV1(stopMonitorV1Request: StopMonitorV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).stopMonitorV1(stopMonitorV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Queryes the vault service for state references based on JVM class names. Custom filters are not supported by this endpoint.
     * @param {VaultQueryV1Request} vaultQueryV1Request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public vaultQueryV1(vaultQueryV1Request: VaultQueryV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).vaultQueryV1(vaultQueryV1Request, options).then((request) => request(this.axios, this.basePath));
    }
}


