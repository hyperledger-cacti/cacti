/* tslint:disable */
/* eslint-disable */
/**
 * Hyperledger Cactus Plugin - Connector Corda
 * Can perform basic tasks on a Corda ledger
 *
 * The version of the OpenAPI document: 0.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CordaX500Name
 */
export interface CordaX500Name {
    /**
     * 
     * @type {string}
     * @memberof CordaX500Name
     */
    commonName?: string;
    /**
     * 
     * @type {string}
     * @memberof CordaX500Name
     */
    organisationUnit?: string;
    /**
     * 
     * @type {string}
     * @memberof CordaX500Name
     */
    organisation: string;
    /**
     * 
     * @type {string}
     * @memberof CordaX500Name
     */
    locality: string;
    /**
     * 
     * @type {string}
     * @memberof CordaX500Name
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof CordaX500Name
     */
    country: string;
    /**
     * 
     * @type {X500Principal}
     * @memberof CordaX500Name
     */
    x500Principal: X500Principal;
}
/**
 * 
 * @export
 * @interface DeployContractJarsBadRequestV1Response
 */
export interface DeployContractJarsBadRequestV1Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployContractJarsBadRequestV1Response
     */
    errors: Array<string>;
}
/**
 * 
 * @export
 * @interface DeployContractJarsSuccessV1Response
 */
export interface DeployContractJarsSuccessV1Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployContractJarsSuccessV1Response
     */
    deployedJarFiles: Array<string>;
}
/**
 * 
 * @export
 * @interface DeployContractJarsV1Request
 */
export interface DeployContractJarsV1Request {
    /**
     * 
     * @type {Array<JarFile>}
     * @memberof DeployContractJarsV1Request
     */
    jarFiles: Array<JarFile>;
}
/**
 * Determines which flow starting method will be used on the back-end when invoking the flow. Based on the value here the plugin back-end might invoke the rpc.startFlowDynamic() method or the rpc.startTrackedFlowDynamic() method. Streamed responses are aggregated and returned in a single response to HTTP callers who are not equipped to handle streams like WebSocket/gRPC/etc. do.
 * @export
 * @enum {string}
 */
export enum FlowInvocationType {
    TRACKEDFLOWDYNAMIC = 'TRACKED_FLOW_DYNAMIC',
    FLOWDYNAMIC = 'FLOW_DYNAMIC'
}

/**
 * 
 * @export
 * @interface InvokeContractV1Request
 */
export interface InvokeContractV1Request {
    /**
     * The fully qualified name of the Corda flow to invoke
     * @type {string}
     * @memberof InvokeContractV1Request
     */
    flowFullClassName: string;
    /**
     * 
     * @type {FlowInvocationType}
     * @memberof InvokeContractV1Request
     */
    flowInvocationType: FlowInvocationType;
    /**
     * The list of arguments to pass in to the contract method being invoked.
     * @type {Array<JvmObject>}
     * @memberof InvokeContractV1Request
     */
    params: Array<JvmObject>;
    /**
     * The amount of milliseconds to wait for a transaction receipt beforegiving up and crashing.
     * @type {number}
     * @memberof InvokeContractV1Request
     */
    timeoutMs?: number;
}
/**
 * 
 * @export
 * @interface InvokeContractV1Response
 */
export interface InvokeContractV1Response {
    /**
     * 
     * @type {object}
     * @memberof InvokeContractV1Response
     */
    returnValue?: object;
    /**
     * The net.corda.core.flows.StateMachineRunId value returned by the flow execution.
     * @type {string}
     * @memberof InvokeContractV1Response
     */
    id: string;
    /**
     * An array of strings representing the aggregated stream of progress updates provided by a *tracked* flow invocation. If the flow invocation was not tracked, this array is still returned, but as empty.
     * @type {Array<string>}
     * @memberof InvokeContractV1Response
     */
    progress: Array<string>;
}
/**
 * 
 * @export
 * @interface JarFile
 */
export interface JarFile {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof JarFile
     */
    filename: string;
    /**
     * 
     * @type {string}
     * @memberof JarFile
     */
    contentBase64: string;
}
/**
 * Can represent JVM primitive and reference types as well. The jvmTypeKind field indicates which one is being stored. If the jvmTypeKind field is set to REFERENCE then the jvmCtorArgs array is expected to be filled, otherwise (e.g. PRIMITIVE jvmTypeKind) it is expected that the primitiveValue property is filled with a primitive data type supported by the JSON standard such as strings, booleans, numbers, etc.
 * @export
 * @interface JvmObject
 */
export interface JvmObject {
    /**
     * 
     * @type {JvmTypeKind}
     * @memberof JvmObject
     */
    jvmTypeKind: JvmTypeKind;
    /**
     * 
     * @type {object}
     * @memberof JvmObject
     */
    primitiveValue?: object;
    /**
     * 
     * @type {Array<JvmObject>}
     * @memberof JvmObject
     */
    jvmCtorArgs?: Array<JvmObject>;
    /**
     * 
     * @type {JvmType}
     * @memberof JvmObject
     */
    jvmType: JvmType;
}
/**
 * Represents a reference to a JVM type (such as a Java class)
 * @export
 * @interface JvmType
 */
export interface JvmType {
    /**
     * 
     * @type {string}
     * @memberof JvmType
     */
    fqClassName: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum JvmTypeKind {
    PRIMITIVE = 'PRIMITIVE',
    REFERENCE = 'REFERENCE'
}

/**
 * 
 * @export
 * @interface NetworkHostAndPort
 */
export interface NetworkHostAndPort {
    /**
     * 
     * @type {string}
     * @memberof NetworkHostAndPort
     */
    host: string;
    /**
     * 
     * @type {number}
     * @memberof NetworkHostAndPort
     */
    port: number;
}
/**
 * 
 * @export
 * @interface NodeInfo
 */
export interface NodeInfo {
    /**
     * 
     * @type {Array<NetworkHostAndPort>}
     * @memberof NodeInfo
     */
    addresses: Array<NetworkHostAndPort>;
    /**
     * 
     * @type {number}
     * @memberof NodeInfo
     */
    platformVersion: number;
    /**
     * 
     * @type {number}
     * @memberof NodeInfo
     */
    serial: number;
    /**
     * 
     * @type {Array<Party>}
     * @memberof NodeInfo
     */
    legalIdentities: Array<Party>;
    /**
     * 
     * @type {Array<object>}
     * @memberof NodeInfo
     */
    legalIdentitiesAndCerts: Array<object>;
}
/**
 * 
 * @export
 * @interface Party
 */
export interface Party {
    /**
     * 
     * @type {CordaX500Name}
     * @memberof Party
     */
    name: CordaX500Name;
    /**
     * 
     * @type {PublicKey}
     * @memberof Party
     */
    owningKey: PublicKey;
}
/**
 * An instance of a java.security.PublicKey (which is an interface) implementation such as org.hyperledger.cactus.plugin.ledger.connector.corda.server.impl.PublicKeyImpl
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    algorithm: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    format: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    encoded: string;
}
/**
 * 
 * @export
 * @interface X500Principal
 */
export interface X500Principal {
    /**
     * 
     * @type {string}
     * @memberof X500Principal
     */
    name: string;
    /**
     * Base64 encoded public key
     * @type {string}
     * @memberof X500Principal
     */
    encoded: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploys a set of jar files (Cordapps, e.g. the contracts in Corda speak).
         * @param {DeployContractJarsV1Request} [deployContractJarsV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractJarsV1: async (deployContractJarsV1Request?: DeployContractJarsV1Request, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/deploy-contract-jars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deployContractJarsV1Request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deployContractJarsV1Request !== undefined ? deployContractJarsV1Request : {}) : (deployContractJarsV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invokes a contract on a Corda ledger (e.g. a flow)
         * @param {InvokeContractV1Request} [invokeContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeContractV1: async (invokeContractV1Request?: InvokeContractV1Request, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/invoke-contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof invokeContractV1Request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(invokeContractV1Request !== undefined ? invokeContractV1Request : {}) : (invokeContractV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Responds with a snapshot of the network map as provided by the Corda RPC call: net.corda.core.messaging.CordaRPCOps public abstract fun networkMapSnapshot(): List<NodeInfo>
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkMapV1: async (body?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-corda/network-map`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploys a set of jar files (Cordapps, e.g. the contracts in Corda speak).
         * @param {DeployContractJarsV1Request} [deployContractJarsV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployContractJarsV1(deployContractJarsV1Request?: DeployContractJarsV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContractJarsSuccessV1Response>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deployContractJarsV1(deployContractJarsV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Invokes a contract on a Corda ledger (e.g. a flow)
         * @param {InvokeContractV1Request} [invokeContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeContractV1(invokeContractV1Request?: InvokeContractV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvokeContractV1Response>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).invokeContractV1(invokeContractV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Responds with a snapshot of the network map as provided by the Corda RPC call: net.corda.core.messaging.CordaRPCOps public abstract fun networkMapSnapshot(): List<NodeInfo>
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkMapV1(body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeInfo>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).networkMapV1(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deploys a set of jar files (Cordapps, e.g. the contracts in Corda speak).
         * @param {DeployContractJarsV1Request} [deployContractJarsV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractJarsV1(deployContractJarsV1Request?: DeployContractJarsV1Request, options?: any): AxiosPromise<DeployContractJarsSuccessV1Response> {
            return DefaultApiFp(configuration).deployContractJarsV1(deployContractJarsV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invokes a contract on a Corda ledger (e.g. a flow)
         * @param {InvokeContractV1Request} [invokeContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeContractV1(invokeContractV1Request?: InvokeContractV1Request, options?: any): AxiosPromise<InvokeContractV1Response> {
            return DefaultApiFp(configuration).invokeContractV1(invokeContractV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds with a snapshot of the network map as provided by the Corda RPC call: net.corda.core.messaging.CordaRPCOps public abstract fun networkMapSnapshot(): List<NodeInfo>
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkMapV1(body?: object, options?: any): AxiosPromise<Array<NodeInfo>> {
            return DefaultApiFp(configuration).networkMapV1(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Deploys a set of jar files (Cordapps, e.g. the contracts in Corda speak).
     * @param {DeployContractJarsV1Request} [deployContractJarsV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deployContractJarsV1(deployContractJarsV1Request?: DeployContractJarsV1Request, options?: any) {
        return DefaultApiFp(this.configuration).deployContractJarsV1(deployContractJarsV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invokes a contract on a Corda ledger (e.g. a flow)
     * @param {InvokeContractV1Request} [invokeContractV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public invokeContractV1(invokeContractV1Request?: InvokeContractV1Request, options?: any) {
        return DefaultApiFp(this.configuration).invokeContractV1(invokeContractV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Responds with a snapshot of the network map as provided by the Corda RPC call: net.corda.core.messaging.CordaRPCOps public abstract fun networkMapSnapshot(): List<NodeInfo>
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkMapV1(body?: object, options?: any) {
        return DefaultApiFp(this.configuration).networkMapV1(body, options).then((request) => request(this.axios, this.basePath));
    }
}


