/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.ClientV1Request
import org.openapitools.client.models.CommitFinalV1Request
import org.openapitools.client.models.CommitFinalV1Response
import org.openapitools.client.models.CommitPreparationV1Request
import org.openapitools.client.models.CommitPreparationV1Response
import org.openapitools.client.models.LockEvidenceV1Request
import org.openapitools.client.models.LockEvidenceV1Response
import org.openapitools.client.models.RecoverSuccessV1Message
import org.openapitools.client.models.RecoverUpdateAckV1Message
import org.openapitools.client.models.RecoverUpdateV1Message
import org.openapitools.client.models.RecoverV1Message
import org.openapitools.client.models.RollbackAckV1Message
import org.openapitools.client.models.RollbackV1Message
import org.openapitools.client.models.TransferCommenceV1Request
import org.openapitools.client.models.TransferCommenceV1Response
import org.openapitools.client.models.TransferCompleteV1Request
import org.openapitools.client.models.TransferInitializationV1Request
import org.openapitools.client.models.TransferInitializationV1Response

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * 
     * 
     * @param clientV1Request  (optional)
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRequestV1(clientV1Request: ClientV1Request? = null) : kotlin.Any {
        val localVarResponse = clientRequestV1WithHttpInfo(clientV1Request = clientV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param clientV1Request  (optional)
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun clientRequestV1WithHttpInfo(clientV1Request: ClientV1Request?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = clientRequestV1RequestConfig(clientV1Request = clientV1Request)

        return request<ClientV1Request, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation clientRequestV1
     *
     * @param clientV1Request  (optional)
     * @return RequestConfig
     */
    fun clientRequestV1RequestConfig(clientV1Request: ClientV1Request?) : RequestConfig<ClientV1Request> {
        val localVariableBody = clientV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/clientrequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param transferInitializationV1Request  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase1TransferInitiationRequestV1(transferInitializationV1Request: TransferInitializationV1Request? = null) : Unit {
        val localVarResponse = phase1TransferInitiationRequestV1WithHttpInfo(transferInitializationV1Request = transferInitializationV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param transferInitializationV1Request  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun phase1TransferInitiationRequestV1WithHttpInfo(transferInitializationV1Request: TransferInitializationV1Request?) : ApiResponse<Unit?> {
        val localVariableConfig = phase1TransferInitiationRequestV1RequestConfig(transferInitializationV1Request = transferInitializationV1Request)

        return request<TransferInitializationV1Request, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation phase1TransferInitiationRequestV1
     *
     * @param transferInitializationV1Request  (optional)
     * @return RequestConfig
     */
    fun phase1TransferInitiationRequestV1RequestConfig(transferInitializationV1Request: TransferInitializationV1Request?) : RequestConfig<TransferInitializationV1Request> {
        val localVariableBody = transferInitializationV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/phase1/transferinitiationrequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param transferInitializationV1Response  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase1TransferInitiationResponseV1(transferInitializationV1Response: TransferInitializationV1Response? = null) : Unit {
        val localVarResponse = phase1TransferInitiationResponseV1WithHttpInfo(transferInitializationV1Response = transferInitializationV1Response)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param transferInitializationV1Response  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun phase1TransferInitiationResponseV1WithHttpInfo(transferInitializationV1Response: TransferInitializationV1Response?) : ApiResponse<Unit?> {
        val localVariableConfig = phase1TransferInitiationResponseV1RequestConfig(transferInitializationV1Response = transferInitializationV1Response)

        return request<TransferInitializationV1Response, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation phase1TransferInitiationResponseV1
     *
     * @param transferInitializationV1Response  (optional)
     * @return RequestConfig
     */
    fun phase1TransferInitiationResponseV1RequestConfig(transferInitializationV1Response: TransferInitializationV1Response?) : RequestConfig<TransferInitializationV1Response> {
        val localVariableBody = transferInitializationV1Response
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/phase1/transferinitiationresponse",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param lockEvidenceV1Request  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase2LockEvidenceRequestV1(lockEvidenceV1Request: LockEvidenceV1Request? = null) : Unit {
        val localVarResponse = phase2LockEvidenceRequestV1WithHttpInfo(lockEvidenceV1Request = lockEvidenceV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param lockEvidenceV1Request  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun phase2LockEvidenceRequestV1WithHttpInfo(lockEvidenceV1Request: LockEvidenceV1Request?) : ApiResponse<Unit?> {
        val localVariableConfig = phase2LockEvidenceRequestV1RequestConfig(lockEvidenceV1Request = lockEvidenceV1Request)

        return request<LockEvidenceV1Request, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation phase2LockEvidenceRequestV1
     *
     * @param lockEvidenceV1Request  (optional)
     * @return RequestConfig
     */
    fun phase2LockEvidenceRequestV1RequestConfig(lockEvidenceV1Request: LockEvidenceV1Request?) : RequestConfig<LockEvidenceV1Request> {
        val localVariableBody = lockEvidenceV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/phase2/lockevidencerequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param lockEvidenceV1Response  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase2LockEvidenceResponseV1(lockEvidenceV1Response: LockEvidenceV1Response? = null) : Unit {
        val localVarResponse = phase2LockEvidenceResponseV1WithHttpInfo(lockEvidenceV1Response = lockEvidenceV1Response)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param lockEvidenceV1Response  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun phase2LockEvidenceResponseV1WithHttpInfo(lockEvidenceV1Response: LockEvidenceV1Response?) : ApiResponse<Unit?> {
        val localVariableConfig = phase2LockEvidenceResponseV1RequestConfig(lockEvidenceV1Response = lockEvidenceV1Response)

        return request<LockEvidenceV1Response, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation phase2LockEvidenceResponseV1
     *
     * @param lockEvidenceV1Response  (optional)
     * @return RequestConfig
     */
    fun phase2LockEvidenceResponseV1RequestConfig(lockEvidenceV1Response: LockEvidenceV1Response?) : RequestConfig<LockEvidenceV1Response> {
        val localVariableBody = lockEvidenceV1Response
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/phase2/lockevidenceresponse",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param transferCommenceV1Request  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase2TransferCommenceRequestV1(transferCommenceV1Request: TransferCommenceV1Request? = null) : Unit {
        val localVarResponse = phase2TransferCommenceRequestV1WithHttpInfo(transferCommenceV1Request = transferCommenceV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param transferCommenceV1Request  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun phase2TransferCommenceRequestV1WithHttpInfo(transferCommenceV1Request: TransferCommenceV1Request?) : ApiResponse<Unit?> {
        val localVariableConfig = phase2TransferCommenceRequestV1RequestConfig(transferCommenceV1Request = transferCommenceV1Request)

        return request<TransferCommenceV1Request, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation phase2TransferCommenceRequestV1
     *
     * @param transferCommenceV1Request  (optional)
     * @return RequestConfig
     */
    fun phase2TransferCommenceRequestV1RequestConfig(transferCommenceV1Request: TransferCommenceV1Request?) : RequestConfig<TransferCommenceV1Request> {
        val localVariableBody = transferCommenceV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/phase2/transfercommencerequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param transferCommenceV1Response  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase2TransferCommenceResponseV1(transferCommenceV1Response: TransferCommenceV1Response? = null) : Unit {
        val localVarResponse = phase2TransferCommenceResponseV1WithHttpInfo(transferCommenceV1Response = transferCommenceV1Response)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param transferCommenceV1Response  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun phase2TransferCommenceResponseV1WithHttpInfo(transferCommenceV1Response: TransferCommenceV1Response?) : ApiResponse<Unit?> {
        val localVariableConfig = phase2TransferCommenceResponseV1RequestConfig(transferCommenceV1Response = transferCommenceV1Response)

        return request<TransferCommenceV1Response, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation phase2TransferCommenceResponseV1
     *
     * @param transferCommenceV1Response  (optional)
     * @return RequestConfig
     */
    fun phase2TransferCommenceResponseV1RequestConfig(transferCommenceV1Response: TransferCommenceV1Response?) : RequestConfig<TransferCommenceV1Response> {
        val localVariableBody = transferCommenceV1Response
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/phase2/transfercommenceresponse",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param commitFinalV1Request  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase3CommitFinalRequestV1(commitFinalV1Request: CommitFinalV1Request? = null) : Unit {
        val localVarResponse = phase3CommitFinalRequestV1WithHttpInfo(commitFinalV1Request = commitFinalV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param commitFinalV1Request  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun phase3CommitFinalRequestV1WithHttpInfo(commitFinalV1Request: CommitFinalV1Request?) : ApiResponse<Unit?> {
        val localVariableConfig = phase3CommitFinalRequestV1RequestConfig(commitFinalV1Request = commitFinalV1Request)

        return request<CommitFinalV1Request, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation phase3CommitFinalRequestV1
     *
     * @param commitFinalV1Request  (optional)
     * @return RequestConfig
     */
    fun phase3CommitFinalRequestV1RequestConfig(commitFinalV1Request: CommitFinalV1Request?) : RequestConfig<CommitFinalV1Request> {
        val localVariableBody = commitFinalV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/phase3/commitfinalrequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param commitFinalV1Response  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase3CommitFinalResponseV1(commitFinalV1Response: CommitFinalV1Response? = null) : Unit {
        val localVarResponse = phase3CommitFinalResponseV1WithHttpInfo(commitFinalV1Response = commitFinalV1Response)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param commitFinalV1Response  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun phase3CommitFinalResponseV1WithHttpInfo(commitFinalV1Response: CommitFinalV1Response?) : ApiResponse<Unit?> {
        val localVariableConfig = phase3CommitFinalResponseV1RequestConfig(commitFinalV1Response = commitFinalV1Response)

        return request<CommitFinalV1Response, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation phase3CommitFinalResponseV1
     *
     * @param commitFinalV1Response  (optional)
     * @return RequestConfig
     */
    fun phase3CommitFinalResponseV1RequestConfig(commitFinalV1Response: CommitFinalV1Response?) : RequestConfig<CommitFinalV1Response> {
        val localVariableBody = commitFinalV1Response
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/phase3/commitfinalresponse",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param commitPreparationV1Request  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase3CommitPreparationRequestV1(commitPreparationV1Request: CommitPreparationV1Request? = null) : Unit {
        val localVarResponse = phase3CommitPreparationRequestV1WithHttpInfo(commitPreparationV1Request = commitPreparationV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param commitPreparationV1Request  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun phase3CommitPreparationRequestV1WithHttpInfo(commitPreparationV1Request: CommitPreparationV1Request?) : ApiResponse<Unit?> {
        val localVariableConfig = phase3CommitPreparationRequestV1RequestConfig(commitPreparationV1Request = commitPreparationV1Request)

        return request<CommitPreparationV1Request, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation phase3CommitPreparationRequestV1
     *
     * @param commitPreparationV1Request  (optional)
     * @return RequestConfig
     */
    fun phase3CommitPreparationRequestV1RequestConfig(commitPreparationV1Request: CommitPreparationV1Request?) : RequestConfig<CommitPreparationV1Request> {
        val localVariableBody = commitPreparationV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/phase3/commitpreparationrequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param commitPreparationV1Response  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase3CommitPreparationResponseV1(commitPreparationV1Response: CommitPreparationV1Response? = null) : Unit {
        val localVarResponse = phase3CommitPreparationResponseV1WithHttpInfo(commitPreparationV1Response = commitPreparationV1Response)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param commitPreparationV1Response  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun phase3CommitPreparationResponseV1WithHttpInfo(commitPreparationV1Response: CommitPreparationV1Response?) : ApiResponse<Unit?> {
        val localVariableConfig = phase3CommitPreparationResponseV1RequestConfig(commitPreparationV1Response = commitPreparationV1Response)

        return request<CommitPreparationV1Response, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation phase3CommitPreparationResponseV1
     *
     * @param commitPreparationV1Response  (optional)
     * @return RequestConfig
     */
    fun phase3CommitPreparationResponseV1RequestConfig(commitPreparationV1Response: CommitPreparationV1Response?) : RequestConfig<CommitPreparationV1Response> {
        val localVariableBody = commitPreparationV1Response
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/phase3/commitpreparationresponse",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param transferCompleteV1Request  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase3TransferCompleteRequestV1(transferCompleteV1Request: TransferCompleteV1Request? = null) : Unit {
        val localVarResponse = phase3TransferCompleteRequestV1WithHttpInfo(transferCompleteV1Request = transferCompleteV1Request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param transferCompleteV1Request  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun phase3TransferCompleteRequestV1WithHttpInfo(transferCompleteV1Request: TransferCompleteV1Request?) : ApiResponse<Unit?> {
        val localVariableConfig = phase3TransferCompleteRequestV1RequestConfig(transferCompleteV1Request = transferCompleteV1Request)

        return request<TransferCompleteV1Request, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation phase3TransferCompleteRequestV1
     *
     * @param transferCompleteV1Request  (optional)
     * @return RequestConfig
     */
    fun phase3TransferCompleteRequestV1RequestConfig(transferCompleteV1Request: TransferCompleteV1Request?) : RequestConfig<TransferCompleteV1Request> {
        val localVariableBody = transferCompleteV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/phase3/transfercompleterequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param recoverUpdateAckV1Message  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun recoverUpdateAckV1Message(recoverUpdateAckV1Message: RecoverUpdateAckV1Message? = null) : Unit {
        val localVarResponse = recoverUpdateAckV1MessageWithHttpInfo(recoverUpdateAckV1Message = recoverUpdateAckV1Message)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param recoverUpdateAckV1Message  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun recoverUpdateAckV1MessageWithHttpInfo(recoverUpdateAckV1Message: RecoverUpdateAckV1Message?) : ApiResponse<Unit?> {
        val localVariableConfig = recoverUpdateAckV1MessageRequestConfig(recoverUpdateAckV1Message = recoverUpdateAckV1Message)

        return request<RecoverUpdateAckV1Message, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation recoverUpdateAckV1Message
     *
     * @param recoverUpdateAckV1Message  (optional)
     * @return RequestConfig
     */
    fun recoverUpdateAckV1MessageRequestConfig(recoverUpdateAckV1Message: RecoverUpdateAckV1Message?) : RequestConfig<RecoverUpdateAckV1Message> {
        val localVariableBody = recoverUpdateAckV1Message
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/recoverupdateackmessage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param recoverUpdateV1Message  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun recoverUpdateV1Message(recoverUpdateV1Message: RecoverUpdateV1Message? = null) : Unit {
        val localVarResponse = recoverUpdateV1MessageWithHttpInfo(recoverUpdateV1Message = recoverUpdateV1Message)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param recoverUpdateV1Message  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun recoverUpdateV1MessageWithHttpInfo(recoverUpdateV1Message: RecoverUpdateV1Message?) : ApiResponse<Unit?> {
        val localVariableConfig = recoverUpdateV1MessageRequestConfig(recoverUpdateV1Message = recoverUpdateV1Message)

        return request<RecoverUpdateV1Message, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation recoverUpdateV1Message
     *
     * @param recoverUpdateV1Message  (optional)
     * @return RequestConfig
     */
    fun recoverUpdateV1MessageRequestConfig(recoverUpdateV1Message: RecoverUpdateV1Message?) : RequestConfig<RecoverUpdateV1Message> {
        val localVariableBody = recoverUpdateV1Message
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/recoverupdatemessage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param recoverV1Message  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun recoverV1Message(recoverV1Message: RecoverV1Message? = null) : Unit {
        val localVarResponse = recoverV1MessageWithHttpInfo(recoverV1Message = recoverV1Message)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param recoverV1Message  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun recoverV1MessageWithHttpInfo(recoverV1Message: RecoverV1Message?) : ApiResponse<Unit?> {
        val localVariableConfig = recoverV1MessageRequestConfig(recoverV1Message = recoverV1Message)

        return request<RecoverV1Message, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation recoverV1Message
     *
     * @param recoverV1Message  (optional)
     * @return RequestConfig
     */
    fun recoverV1MessageRequestConfig(recoverV1Message: RecoverV1Message?) : RequestConfig<RecoverV1Message> {
        val localVariableBody = recoverV1Message
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/recovermessage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param recoverSuccessV1Message  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun recoverV1Success(recoverSuccessV1Message: RecoverSuccessV1Message? = null) : Unit {
        val localVarResponse = recoverV1SuccessWithHttpInfo(recoverSuccessV1Message = recoverSuccessV1Message)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param recoverSuccessV1Message  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun recoverV1SuccessWithHttpInfo(recoverSuccessV1Message: RecoverSuccessV1Message?) : ApiResponse<Unit?> {
        val localVariableConfig = recoverV1SuccessRequestConfig(recoverSuccessV1Message = recoverSuccessV1Message)

        return request<RecoverSuccessV1Message, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation recoverV1Success
     *
     * @param recoverSuccessV1Message  (optional)
     * @return RequestConfig
     */
    fun recoverV1SuccessRequestConfig(recoverSuccessV1Message: RecoverSuccessV1Message?) : RequestConfig<RecoverSuccessV1Message> {
        val localVariableBody = recoverSuccessV1Message
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/recoversuccessmessage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param rollbackAckV1Message  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rollbackAckV1Message(rollbackAckV1Message: RollbackAckV1Message? = null) : Unit {
        val localVarResponse = rollbackAckV1MessageWithHttpInfo(rollbackAckV1Message = rollbackAckV1Message)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param rollbackAckV1Message  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun rollbackAckV1MessageWithHttpInfo(rollbackAckV1Message: RollbackAckV1Message?) : ApiResponse<Unit?> {
        val localVariableConfig = rollbackAckV1MessageRequestConfig(rollbackAckV1Message = rollbackAckV1Message)

        return request<RollbackAckV1Message, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rollbackAckV1Message
     *
     * @param rollbackAckV1Message  (optional)
     * @return RequestConfig
     */
    fun rollbackAckV1MessageRequestConfig(rollbackAckV1Message: RollbackAckV1Message?) : RequestConfig<RollbackAckV1Message> {
        val localVariableBody = rollbackAckV1Message
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/rollbackackmessage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param rollbackV1Message  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rollbackV1Message(rollbackV1Message: RollbackV1Message? = null) : Unit {
        val localVarResponse = rollbackV1MessageWithHttpInfo(rollbackV1Message = rollbackV1Message)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param rollbackV1Message  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun rollbackV1MessageWithHttpInfo(rollbackV1Message: RollbackV1Message?) : ApiResponse<Unit?> {
        val localVariableConfig = rollbackV1MessageRequestConfig(rollbackV1Message = rollbackV1Message)

        return request<RollbackV1Message, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rollbackV1Message
     *
     * @param rollbackV1Message  (optional)
     * @return RequestConfig
     */
    fun rollbackV1MessageRequestConfig(rollbackV1Message: RollbackV1Message?) : RequestConfig<RollbackV1Message> {
        val localVariableBody = rollbackV1Message
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-satp-hermes/rollbackmessage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
