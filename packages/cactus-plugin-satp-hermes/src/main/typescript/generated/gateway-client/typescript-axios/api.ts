/* tslint:disable */
/* eslint-disable */
/**
 * SATP Gateway Client (Business Logic Orchestrator)
 * SATP is a protocol operating between two gateways that conducts the transfer of a digital asset from one gateway to another. The protocol establishes a secure channel between the endpoints and implements a 2-phase commit to ensure the properties of transfer atomicity, consistency, isolation and durability.  This API defines the gateway client facing API (business logic orchestrator, or BLO), which is named API-Type 1 in the SATP-Core specification.  **Additional Resources**: - [Proposed SATP Charter](https://datatracker.ietf.org/doc/charter-ietf-satp/) - [SATP Core draft](https://datatracker.ietf.org/doc/draft-ietf-satp-core) - [SATP Crash Recovery draft](https://datatracker.ietf.org/doc/draft-belchior-satp-gateway-recovery/) - [SATP Architecture draft](https://datatracker.ietf.org/doc/draft-ietf-satp-architecture/) - [SATP Use-Cases draft](https://datatracker.ietf.org/doc/draft-ramakrishna-sat-use-cases/) - [SATP Data sharing draft](https://datatracker.ietf.org/doc/draft-ramakrishna-satp-data-sharing) - [SATP View Addresses draft](https://datatracker.ietf.org/doc/draft-ramakrishna-satp-views-addresses)
 *
 * The version of the OpenAPI document: 0.0.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * An Error
 * @export
 * @interface APIError
 */
export interface APIError {
    /**
     * HTTP error type
     * @type {string}
     * @memberof APIError
     */
    'type': string;
    /**
     * Numeric error code
     * @type {number}
     * @memberof APIError
     */
    'code': number;
    /**
     * HTTP status of the error
     * @type {number}
     * @memberof APIError
     */
    'status': number;
    /**
     * Long error description
     * @type {string}
     * @memberof APIError
     */
    'message': string;
    /**
     * Timestamp of the error
     * @type {string}
     * @memberof APIError
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof Action
     */
    'fromToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The amount of \'fromToken\' to be transferred, specified as a string to maintain precision.
     * @type {string}
     * @memberof Action
     */
    'fromAmount'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof Action
     */
    'toToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The maximum acceptable difference between the expected price of the \'toToken\' and the price at the time of the transfer.
     * @type {number}
     * @memberof Action
     */
    'slippage'?: number;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof Action
     */
    'fromAddress'?: string;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof Action
     */
    'toAddress'?: string;
}
/**
 * Response schema for adding a counterparty.
 * @export
 * @interface AddCounterparty200Response
 */
export interface AddCounterparty200Response {
    /**
     * The status of the request.
     * @type {boolean}
     * @memberof AddCounterparty200Response
     */
    'status'?: boolean;
}
/**
 * Request schema for adding a counterparty.
 * @export
 * @interface AddCounterpartyGatewayRequest
 */
export interface AddCounterpartyGatewayRequest {
    /**
     * 
     * @type {AddCounterpartyRequestCounterparty}
     * @memberof AddCounterpartyGatewayRequest
     */
    'counterparty': AddCounterpartyRequestCounterparty;
}
/**
 * Response schema for adding a counterparty.
 * @export
 * @interface AddCounterpartyGatewayResponse
 */
export interface AddCounterpartyGatewayResponse {
    /**
     * The status of the request.
     * @type {boolean}
     * @memberof AddCounterpartyGatewayResponse
     */
    'status'?: boolean;
}
/**
 * Request schema for adding a counterparty.
 * @export
 * @interface AddCounterpartyRequest
 */
export interface AddCounterpartyRequest {
    /**
     * 
     * @type {AddCounterpartyRequestCounterparty}
     * @memberof AddCounterpartyRequest
     */
    'counterparty': AddCounterpartyRequestCounterparty;
}
/**
 * The identity of the gateway.
 * @export
 * @interface AddCounterpartyRequestCounterparty
 */
export interface AddCounterpartyRequestCounterparty {
    /**
     * The unique identifier for the gateway.
     * @type {string}
     * @memberof AddCounterpartyRequestCounterparty
     */
    'id': string;
    /**
     * The public key of the gateway.
     * @type {string}
     * @memberof AddCounterpartyRequestCounterparty
     */
    'pubKey': string;
    /**
     * The name of the gateway.
     * @type {string}
     * @memberof AddCounterpartyRequestCounterparty
     */
    'name': string;
    /**
     * The draft versions supported by the gateway.
     * @type {Array<AddCounterpartyRequestCounterpartyVersionInner>}
     * @memberof AddCounterpartyRequestCounterparty
     */
    'version': Array<AddCounterpartyRequestCounterpartyVersionInner>;
    /**
     * The list of connected DLT networks.
     * @type {Array<TransactRequestSourceAssetNetworkId>}
     * @memberof AddCounterpartyRequestCounterparty
     */
    'connectedDLTs': Array<TransactRequestSourceAssetNetworkId>;
    /**
     * The proof ID associated with the gateway.
     * @type {string}
     * @memberof AddCounterpartyRequestCounterparty
     */
    'proofID': string;
    /**
     * The server port of the gateway.
     * @type {number}
     * @memberof AddCounterpartyRequestCounterparty
     */
    'gatewayServerPort': number;
    /**
     * The client port of the gateway.
     * @type {number}
     * @memberof AddCounterpartyRequestCounterparty
     */
    'gatewayClientPort': number;
    /**
     * The OpenAPI port of the gateway.
     * @type {number}
     * @memberof AddCounterpartyRequestCounterparty
     */
    'gatewayOapiPort'?: number;
    /**
     * The UI port of the gateway.
     * @type {number}
     * @memberof AddCounterpartyRequestCounterparty
     */
    'gatewayUIPort'?: number;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof AddCounterpartyRequestCounterparty
     */
    'address': string;
}
/**
 * The draft versions supported by the gateway.
 * @export
 * @interface AddCounterpartyRequestCounterpartyVersionInner
 */
export interface AddCounterpartyRequestCounterpartyVersionInner {
    /**
     * Core functionality or component.
     * @type {string}
     * @memberof AddCounterpartyRequestCounterpartyVersionInner
     */
    'Core'?: string;
    /**
     * System architecture or design.
     * @type {string}
     * @memberof AddCounterpartyRequestCounterpartyVersionInner
     */
    'Architecture'?: string;
    /**
     * Crash or failure scenario.
     * @type {string}
     * @memberof AddCounterpartyRequestCounterpartyVersionInner
     */
    'Crash'?: string;
}
/**
 * An asset
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'contractName': string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'contractAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'mspId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'channelName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'amount'?: string;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof Asset
     */
    'networkId': TransactRequestSourceAssetNetworkId;
    /**
     * The type of token.
     * @type {string}
     * @memberof Asset
     */
    'tokenType': AssetTokenTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'referenceId': string;
}

export const AssetTokenTypeEnum = {
    Erc20: 'ERC20',
    Erc721: 'ERC721',
    Erc1155: 'ERC1155',
    NonstandardFungible: 'NONSTANDARD_FUNGIBLE',
    NonstandardNonfungible: 'NONSTANDARD_NONFUNGIBLE'
} as const;

export type AssetTokenTypeEnum = typeof AssetTokenTypeEnum[keyof typeof AssetTokenTypeEnum];

/**
 * Response schema for an audit request. Contains the proofs generated during the audit period and the start and end datetimes.
 * @export
 * @interface AuditRequest
 */
export interface AuditRequest {
    /**
     * The start timestamp for the audit period, as a Unix timestamp (milliseconds since epoch).
     * @type {number}
     * @memberof AuditRequest
     */
    'startTimestamp': number;
    /**
     * The end timestamp for the audit period, as a Unix timestamp (milliseconds since epoch).
     * @type {number}
     * @memberof AuditRequest
     */
    'endTimestamp': number;
}
/**
 * Response schema for an audit request. Contains the proofs generated during the audit period and the start and end datetimes.
 * @export
 * @interface AuditResponse
 */
export interface AuditResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof AuditResponse
     */
    'sessions'?: Array<string>;
    /**
     * The start timestamp for the audit period, as a Unix timestamp (milliseconds since epoch).
     * @type {number}
     * @memberof AuditResponse
     */
    'startTimestamp'?: number;
    /**
     * The end timestamp for the audit period, as a Unix timestamp (milliseconds since epoch).
     * @type {number}
     * @memberof AuditResponse
     */
    'endTimestamp'?: number;
}
/**
 * Stores global constants related to the authorization of the application. Specifically enumerates the claims to validate for as per RFC 7519, section 4.1. See: https://tools.ietf.org/html/rfc7519#section-4.1
 * @export
 * @enum {string}
 */

export const AuthzJwtClaim = {
    /**
    * The &quot;iss&quot; (issuer) claim identifies the principal that issued the JWT. The processing of this claim is generally application specific. The &quot;iss&quot; value is a case-sensitive string containing a StringOrURI value. Use of this claim is OPTIONAL.
    */
    iss: 'Hyperledger Labs - Carbon Accounting Tool'
} as const;

export type AuthzJwtClaim = typeof AuthzJwtClaim[keyof typeof AuthzJwtClaim];


/**
 * 
 * @export
 * @enum {string}
 */

export const AuthzScope = {
    /**
    * Identities with the group:admin scope are administrators of the system.
    */
    GroupAdmin: 'group:admin',
    /**
    * Identities with the group:user scope are end users of the system who only have authorization to perform a limited set of actions.
    */
    GroupUser: 'group:user'
} as const;

export type AuthzScope = typeof AuthzScope[keyof typeof AuthzScope];


/**
 * Information about the bridge used for the token transfer.
 * @export
 * @interface BridgeInfo
 */
export interface BridgeInfo {
    /**
     * The address of the token being transferred.
     * @type {string}
     * @memberof BridgeInfo
     */
    'tokenAddress'?: string;
}
/**
 * Represents a business logic contract with its associated metadata and method details.
 * @export
 * @interface BusinessLogicContract
 */
export interface BusinessLogicContract {
    /**
     * The name of the contract.
     * @type {string}
     * @memberof BusinessLogicContract
     */
    'contractName'?: string;
    /**
     * The address of the contract.
     * @type {string}
     * @memberof BusinessLogicContract
     */
    'contractAddress'?: string | null;
    /**
     * The ABI (Application Binary Interface) of the contract.
     * @type {Array<object>}
     * @memberof BusinessLogicContract
     */
    'contractAbi'?: Array<object> | null;
    /**
     * The bytecode of the contract.
     * @type {string}
     * @memberof BusinessLogicContract
     */
    'contractBytecode'?: string | null;
    /**
     * The name of the method to be invoked on the contract.
     * @type {string}
     * @memberof BusinessLogicContract
     */
    'methodName'?: string;
    /**
     * The parameters to be passed to the contract method.
     * @type {Array<ExecuteOracleTaskRequestSourceContractParamsInner>}
     * @memberof BusinessLogicContract
     */
    'params'?: Array<ExecuteOracleTaskRequestSourceContractParamsInner>;
}
/**
 * Response for a cancel transaction request. Indicates whether the cancel action was successful and includes the current session status.
 * @export
 * @interface Cancel200Response
 */
export interface Cancel200Response {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof Cancel200Response
     */
    'statusResponse': Transact200ResponseStatusResponse;
    /**
     * Indicates whether the cancel operation was successful.
     * @type {boolean}
     * @memberof Cancel200Response
     */
    'cancelSuccessful': boolean;
}
/**
 * Request to cancel an ongoing transaction session, identified by the session ID.
 * @export
 * @interface CancelRequest
 */
export interface CancelRequest {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof CancelRequest
     */
    'sessionID': string;
}
/**
 * Response for a cancel transaction request. Indicates whether the cancel action was successful and includes the current session status.
 * @export
 * @interface CancelResponse
 */
export interface CancelResponse {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof CancelResponse
     */
    'statusResponse': Transact200ResponseStatusResponse;
    /**
     * Indicates whether the cancel operation was successful.
     * @type {boolean}
     * @memberof CancelResponse
     */
    'cancelSuccessful': boolean;
}
/**
 * Response schema for a continue request, returning the status of the SATP session.
 * @export
 * @interface Continue200Response
 */
export interface Continue200Response {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof Continue200Response
     */
    'statusResponse': Transact200ResponseStatusResponse;
}
/**
 * Schema for a request to continue a paused transaction session.
 * @export
 * @interface ContinueRequest
 */
export interface ContinueRequest {
    /**
     * A unique identifier for the transaction session to be continued.
     * @type {string}
     * @memberof ContinueRequest
     */
    'sessionId': string;
    /**
     * A unique identifier for the transaction context.
     * @type {string}
     * @memberof ContinueRequest
     */
    'contextId': string;
}
/**
 * Response schema for a continue request, returning the status of the SATP session.
 * @export
 * @interface ContinueResponse
 */
export interface ContinueResponse {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof ContinueResponse
     */
    'statusResponse': Transact200ResponseStatusResponse;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CredentialProfile = {
    Saml: 'SAML',
    Oauth: 'OAUTH',
    X509: 'X509'
} as const;

export type CredentialProfile = typeof CredentialProfile[keyof typeof CredentialProfile];


/**
 * Supported DLT protocols.
 * @export
 * @enum {string}
 */

export const DLTProtocol = {
    HyperledgerFabric: 'HyperledgerFabric',
    HyperledgerBesu: 'HyperledgerBesu'
} as const;

export type DLTProtocol = typeof DLTProtocol[keyof typeof DLTProtocol];


/**
 * The draft versions supported by the gateway.
 * @export
 * @interface DraftVersions
 */
export interface DraftVersions {
    /**
     * Core functionality or component.
     * @type {string}
     * @memberof DraftVersions
     */
    'Core'?: string;
    /**
     * System architecture or design.
     * @type {string}
     * @memberof DraftVersions
     */
    'Architecture'?: string;
    /**
     * Crash or failure scenario.
     * @type {string}
     * @memberof DraftVersions
     */
    'Crash'?: string;
}
/**
 * Provides an estimation for a transaction, including costs, amounts, and execution duration.
 * @export
 * @interface Estimate
 */
export interface Estimate {
    /**
     * A blockchain address.
     * @type {string}
     * @memberof Estimate
     */
    'approvalAddress'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof Estimate
     */
    'toAmountMin'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof Estimate
     */
    'toAmount'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof Estimate
     */
    'fromAmount'?: string;
    /**
     * A collection of fee costs associated with the transaction.
     * @type {Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner>}
     * @memberof Estimate
     */
    'feeCosts'?: Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner>;
    /**
     * A collection of estimated gas costs for executing the transaction.
     * @type {Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner>}
     * @memberof Estimate
     */
    'gasCosts'?: Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner>;
    /**
     * The estimated duration for the transaction execution in seconds.
     * @type {number}
     * @memberof Estimate
     */
    'executionDuration'?: number;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof Estimate
     */
    'fromAmountUSD'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof Estimate
     */
    'toAmountUSD'?: string;
    /**
     * The tool or service used to generate this estimate.
     * @type {string}
     * @memberof Estimate
     */
    'tool'?: string;
}
/**
 * Response schema for executing a data transfer task. Includes the task ID and status of the execution.
 * @export
 * @interface ExecuteOracleTask200Response
 */
export interface ExecuteOracleTask200Response {
    /**
     * The unique identifier of the task.
     * @type {string}
     * @memberof ExecuteOracleTask200Response
     */
    'taskID': string;
    /**
     * The type of the Oracle task.
     * @type {string}
     * @memberof ExecuteOracleTask200Response
     */
    'type': ExecuteOracleTask200ResponseTypeEnum;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof ExecuteOracleTask200Response
     */
    'srcNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseSrcContract}
     * @memberof ExecuteOracleTask200Response
     */
    'srcContract': ExecuteOracleTask200ResponseSrcContract;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof ExecuteOracleTask200Response
     */
    'dstNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseDstContract}
     * @memberof ExecuteOracleTask200Response
     */
    'dstContract': ExecuteOracleTask200ResponseDstContract;
    /**
     * The timestamp when the Oracle task was created or last updated.
     * @type {number}
     * @memberof ExecuteOracleTask200Response
     */
    'timestamp': number;
    /**
     * The list of operations performed by the Oracle task.
     * @type {Array<ExecuteOracleTask200ResponseOperationsInner>}
     * @memberof ExecuteOracleTask200Response
     */
    'operations': Array<ExecuteOracleTask200ResponseOperationsInner>;
    /**
     * The current status of the Oracle task.
     * @type {string}
     * @memberof ExecuteOracleTask200Response
     */
    'status': ExecuteOracleTask200ResponseStatusEnum;
    /**
     * The mode of operation for registered tasks.
     * @type {string}
     * @memberof ExecuteOracleTask200Response
     */
    'mode': ExecuteOracleTask200ResponseModeEnum;
    /**
     * The interval for polling in milliseconds. Only if taskMode is POLLING.
     * @type {number}
     * @memberof ExecuteOracleTask200Response
     */
    'pollingInterval'?: number;
}

export const ExecuteOracleTask200ResponseTypeEnum = {
    Read: 'READ',
    Update: 'UPDATE',
    ReadAndUpdate: 'READ_AND_UPDATE'
} as const;

export type ExecuteOracleTask200ResponseTypeEnum = typeof ExecuteOracleTask200ResponseTypeEnum[keyof typeof ExecuteOracleTask200ResponseTypeEnum];
export const ExecuteOracleTask200ResponseStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type ExecuteOracleTask200ResponseStatusEnum = typeof ExecuteOracleTask200ResponseStatusEnum[keyof typeof ExecuteOracleTask200ResponseStatusEnum];
export const ExecuteOracleTask200ResponseModeEnum = {
    Polling: 'POLLING',
    EventListening: 'EVENT_LISTENING',
    Immediate: 'IMMEDIATE'
} as const;

export type ExecuteOracleTask200ResponseModeEnum = typeof ExecuteOracleTask200ResponseModeEnum[keyof typeof ExecuteOracleTask200ResponseModeEnum];

/**
 * The destination contract details for the Oracle task.
 * @export
 * @interface ExecuteOracleTask200ResponseDstContract
 */
export interface ExecuteOracleTask200ResponseDstContract {
    /**
     * The name of the contract.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseDstContract
     */
    'contractName'?: string;
    /**
     * The address of the contract.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseDstContract
     */
    'contractAddress'?: string | null;
    /**
     * The ABI (Application Binary Interface) of the contract.
     * @type {Array<object>}
     * @memberof ExecuteOracleTask200ResponseDstContract
     */
    'contractAbi'?: Array<object> | null;
    /**
     * The bytecode of the contract.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseDstContract
     */
    'contractBytecode'?: string | null;
    /**
     * The name of the method to be invoked on the contract.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseDstContract
     */
    'methodName'?: string;
    /**
     * The parameters to be passed to the contract method.
     * @type {Array<ExecuteOracleTaskRequestSourceContractParamsInner>}
     * @memberof ExecuteOracleTask200ResponseDstContract
     */
    'params'?: Array<ExecuteOracleTaskRequestSourceContractParamsInner>;
}
/**
 * Represents an operation performed by the Oracle, including its type, network, contract, status, and optional output.
 * @export
 * @interface ExecuteOracleTask200ResponseOperationsInner
 */
export interface ExecuteOracleTask200ResponseOperationsInner {
    /**
     * A unique identifier for the Oracle operation.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseOperationsInner
     */
    'id': string;
    /**
     * The type of the Oracle operation.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseOperationsInner
     */
    'type': ExecuteOracleTask200ResponseOperationsInnerTypeEnum;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof ExecuteOracleTask200ResponseOperationsInner
     */
    'networkId': TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseOperationsInnerContract}
     * @memberof ExecuteOracleTask200ResponseOperationsInner
     */
    'contract': ExecuteOracleTask200ResponseOperationsInnerContract;
    /**
     * The current status of the Oracle operation.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseOperationsInner
     */
    'status': ExecuteOracleTask200ResponseOperationsInnerStatusEnum;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseOperationsInnerOutput}
     * @memberof ExecuteOracleTask200ResponseOperationsInner
     */
    'output'?: ExecuteOracleTask200ResponseOperationsInnerOutput;
    /**
     * The timestamp when the Oracle operation was created or last updated.
     * @type {number}
     * @memberof ExecuteOracleTask200ResponseOperationsInner
     */
    'timestamp': number;
}

export const ExecuteOracleTask200ResponseOperationsInnerTypeEnum = {
    Read: 'READ',
    Update: 'UPDATE'
} as const;

export type ExecuteOracleTask200ResponseOperationsInnerTypeEnum = typeof ExecuteOracleTask200ResponseOperationsInnerTypeEnum[keyof typeof ExecuteOracleTask200ResponseOperationsInnerTypeEnum];
export const ExecuteOracleTask200ResponseOperationsInnerStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type ExecuteOracleTask200ResponseOperationsInnerStatusEnum = typeof ExecuteOracleTask200ResponseOperationsInnerStatusEnum[keyof typeof ExecuteOracleTask200ResponseOperationsInnerStatusEnum];

/**
 * The contract associated with the Oracle operation.
 * @export
 * @interface ExecuteOracleTask200ResponseOperationsInnerContract
 */
export interface ExecuteOracleTask200ResponseOperationsInnerContract {
    /**
     * The name of the contract.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseOperationsInnerContract
     */
    'contractName'?: string;
    /**
     * The address of the contract.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseOperationsInnerContract
     */
    'contractAddress'?: string | null;
    /**
     * The ABI (Application Binary Interface) of the contract.
     * @type {Array<object>}
     * @memberof ExecuteOracleTask200ResponseOperationsInnerContract
     */
    'contractAbi'?: Array<object> | null;
    /**
     * The bytecode of the contract.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseOperationsInnerContract
     */
    'contractBytecode'?: string | null;
    /**
     * The name of the method to be invoked on the contract.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseOperationsInnerContract
     */
    'methodName'?: string;
    /**
     * The parameters to be passed to the contract method.
     * @type {Array<ExecuteOracleTaskRequestSourceContractParamsInner>}
     * @memberof ExecuteOracleTask200ResponseOperationsInnerContract
     */
    'params'?: Array<ExecuteOracleTaskRequestSourceContractParamsInner>;
}
/**
 * Optional output generated by the Oracle operation.
 * @export
 * @interface ExecuteOracleTask200ResponseOperationsInnerOutput
 */
export interface ExecuteOracleTask200ResponseOperationsInnerOutput {
    /**
     * The unique identifier for the transaction.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseOperationsInnerOutput
     */
    'transactionId'?: string;
    /**
     * The receipt of the transaction, providing proof of execution.
     * @type {object}
     * @memberof ExecuteOracleTask200ResponseOperationsInnerOutput
     */
    'transactionReceipt'?: object;
    /**
     * The output of the Oracle operation execution.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseOperationsInnerOutput
     */
    'output'?: string;
    /**
     * Proof of the Oracle operation execution.
     * @type {object}
     * @memberof ExecuteOracleTask200ResponseOperationsInnerOutput
     */
    'proof'?: object;
}
/**
 * The source contract details for the Oracle task.
 * @export
 * @interface ExecuteOracleTask200ResponseSrcContract
 */
export interface ExecuteOracleTask200ResponseSrcContract {
    /**
     * The name of the contract.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseSrcContract
     */
    'contractName'?: string;
    /**
     * The address of the contract.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseSrcContract
     */
    'contractAddress'?: string | null;
    /**
     * The ABI (Application Binary Interface) of the contract.
     * @type {Array<object>}
     * @memberof ExecuteOracleTask200ResponseSrcContract
     */
    'contractAbi'?: Array<object> | null;
    /**
     * The bytecode of the contract.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseSrcContract
     */
    'contractBytecode'?: string | null;
    /**
     * The name of the method to be invoked on the contract.
     * @type {string}
     * @memberof ExecuteOracleTask200ResponseSrcContract
     */
    'methodName'?: string;
    /**
     * The parameters to be passed to the contract method.
     * @type {Array<ExecuteOracleTaskRequestSourceContractParamsInner>}
     * @memberof ExecuteOracleTask200ResponseSrcContract
     */
    'params'?: Array<ExecuteOracleTaskRequestSourceContractParamsInner>;
}
/**
 * Request schema for triggering an immediate transfer task. Includes the task ID, payload, and destination network and contract details.
 * @export
 * @interface ExecuteOracleTaskRequest
 */
export interface ExecuteOracleTaskRequest {
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof ExecuteOracleTaskRequest
     */
    'sourceNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof ExecuteOracleTaskRequest
     */
    'destinationNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTaskRequestSourceContract}
     * @memberof ExecuteOracleTaskRequest
     */
    'sourceContract'?: ExecuteOracleTaskRequestSourceContract;
    /**
     * 
     * @type {ExecuteOracleTaskRequestDestinationContract}
     * @memberof ExecuteOracleTaskRequest
     */
    'destinationContract'?: ExecuteOracleTaskRequestDestinationContract;
    /**
     * The type of task to be registered.
     * @type {string}
     * @memberof ExecuteOracleTaskRequest
     */
    'taskType'?: ExecuteOracleTaskRequestTaskTypeEnum;
}

export const ExecuteOracleTaskRequestTaskTypeEnum = {
    Read: 'READ',
    Update: 'UPDATE',
    ReadAndUpdate: 'READ_AND_UPDATE'
} as const;

export type ExecuteOracleTaskRequestTaskTypeEnum = typeof ExecuteOracleTaskRequestTaskTypeEnum[keyof typeof ExecuteOracleTaskRequestTaskTypeEnum];

/**
 * The contract data on the destination blockchain. Only if taskType is UPDATE or READ_AND_UPDATE.
 * @export
 * @interface ExecuteOracleTaskRequestDestinationContract
 */
export interface ExecuteOracleTaskRequestDestinationContract {
    /**
     * The name of the contract.
     * @type {string}
     * @memberof ExecuteOracleTaskRequestDestinationContract
     */
    'contractName'?: string;
    /**
     * The address of the contract.
     * @type {string}
     * @memberof ExecuteOracleTaskRequestDestinationContract
     */
    'contractAddress'?: string | null;
    /**
     * The ABI (Application Binary Interface) of the contract.
     * @type {Array<object>}
     * @memberof ExecuteOracleTaskRequestDestinationContract
     */
    'contractAbi'?: Array<object> | null;
    /**
     * The bytecode of the contract.
     * @type {string}
     * @memberof ExecuteOracleTaskRequestDestinationContract
     */
    'contractBytecode'?: string | null;
    /**
     * The name of the method to be invoked on the contract.
     * @type {string}
     * @memberof ExecuteOracleTaskRequestDestinationContract
     */
    'methodName'?: string;
    /**
     * The parameters to be passed to the contract method.
     * @type {Array<ExecuteOracleTaskRequestSourceContractParamsInner>}
     * @memberof ExecuteOracleTaskRequestDestinationContract
     */
    'params'?: Array<ExecuteOracleTaskRequestSourceContractParamsInner>;
}
/**
 * The contract data on the source blockchain. Only if taskType is READ or READ_AND_UPDATE.
 * @export
 * @interface ExecuteOracleTaskRequestSourceContract
 */
export interface ExecuteOracleTaskRequestSourceContract {
    /**
     * The name of the contract.
     * @type {string}
     * @memberof ExecuteOracleTaskRequestSourceContract
     */
    'contractName'?: string;
    /**
     * The address of the contract.
     * @type {string}
     * @memberof ExecuteOracleTaskRequestSourceContract
     */
    'contractAddress'?: string | null;
    /**
     * The ABI (Application Binary Interface) of the contract.
     * @type {Array<object>}
     * @memberof ExecuteOracleTaskRequestSourceContract
     */
    'contractAbi'?: Array<object> | null;
    /**
     * The bytecode of the contract.
     * @type {string}
     * @memberof ExecuteOracleTaskRequestSourceContract
     */
    'contractBytecode'?: string | null;
    /**
     * The name of the method to be invoked on the contract.
     * @type {string}
     * @memberof ExecuteOracleTaskRequestSourceContract
     */
    'methodName'?: string;
    /**
     * The parameters to be passed to the contract method.
     * @type {Array<ExecuteOracleTaskRequestSourceContractParamsInner>}
     * @memberof ExecuteOracleTaskRequestSourceContract
     */
    'params'?: Array<ExecuteOracleTaskRequestSourceContractParamsInner>;
}
/**
 * @type ExecuteOracleTaskRequestSourceContractParamsInner
 * @export
 */
export type ExecuteOracleTaskRequestSourceContractParamsInner = number | string;

/**
 * Details about a specific fee cost associated with the transaction.
 * @export
 * @interface FeeCost
 */
export interface FeeCost {
    /**
     * Name of the fee cost.
     * @type {string}
     * @memberof FeeCost
     */
    'name'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof FeeCost
     */
    'amount'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof FeeCost
     */
    'amountUSD'?: string;
    /**
     * The symbol of a token
     * @type {string}
     * @memberof FeeCost
     */
    'token'?: string;
    /**
     * Indicates if the fee is included in the transaction amount.
     * @type {boolean}
     * @memberof FeeCost
     */
    'included'?: boolean;
}
/**
 * 
 * @export
 * @interface GasCost
 */
export interface GasCost {
    /**
     * The type of the gas cost.
     * @type {string}
     * @memberof GasCost
     */
    'type'?: string;
    /**
     * The gas price, specified as a string to maintain precision.
     * @type {string}
     * @memberof GasCost
     */
    'price'?: string;
    /**
     * The estimated gas required, specified as a string to maintain precision.
     * @type {string}
     * @memberof GasCost
     */
    'estimate'?: string;
    /**
     * The gas limit for the transaction, specified as a string to maintain precision.
     * @type {string}
     * @memberof GasCost
     */
    'limit'?: string;
    /**
     * The amount of gas required in the gas currency.
     * @type {string}
     * @memberof GasCost
     */
    'amount'?: string;
    /**
     * The amount of gas required in USD.
     * @type {string}
     * @memberof GasCost
     */
    'amountUSD'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof GasCost
     */
    'token'?: GetRoutes200ResponseRoutesInnerFromToken;
}
/**
 * The identity of the gateway.
 * @export
 * @interface GatewayIdentity
 */
export interface GatewayIdentity {
    /**
     * The unique identifier for the gateway.
     * @type {string}
     * @memberof GatewayIdentity
     */
    'id': string;
    /**
     * The public key of the gateway.
     * @type {string}
     * @memberof GatewayIdentity
     */
    'pubKey': string;
    /**
     * The name of the gateway.
     * @type {string}
     * @memberof GatewayIdentity
     */
    'name': string;
    /**
     * The draft versions supported by the gateway.
     * @type {Array<AddCounterpartyRequestCounterpartyVersionInner>}
     * @memberof GatewayIdentity
     */
    'version': Array<AddCounterpartyRequestCounterpartyVersionInner>;
    /**
     * The list of connected DLT networks.
     * @type {Array<TransactRequestSourceAssetNetworkId>}
     * @memberof GatewayIdentity
     */
    'connectedDLTs': Array<TransactRequestSourceAssetNetworkId>;
    /**
     * The proof ID associated with the gateway.
     * @type {string}
     * @memberof GatewayIdentity
     */
    'proofID': string;
    /**
     * The server port of the gateway.
     * @type {number}
     * @memberof GatewayIdentity
     */
    'gatewayServerPort': number;
    /**
     * The client port of the gateway.
     * @type {number}
     * @memberof GatewayIdentity
     */
    'gatewayClientPort': number;
    /**
     * The OpenAPI port of the gateway.
     * @type {number}
     * @memberof GatewayIdentity
     */
    'gatewayOapiPort'?: number;
    /**
     * The UI port of the gateway.
     * @type {number}
     * @memberof GatewayIdentity
     */
    'gatewayUIPort'?: number;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof GatewayIdentity
     */
    'address': string;
}
/**
 * Response schema for getting the address to approve the token transfer.
 * @export
 * @interface GetApproveAddress200Response
 */
export interface GetApproveAddress200Response {
    /**
     * The address to approve the token transfer.
     * @type {string}
     * @memberof GetApproveAddress200Response
     */
    'approveAddress': string;
}
/**
 * Request schema for getting the address to approve the token transfer.
 * @export
 * @interface GetApproveAddressRequest
 */
export interface GetApproveAddressRequest {
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof GetApproveAddressRequest
     */
    'networkId': TransactRequestSourceAssetNetworkId;
    /**
     * The type of token.
     * @type {string}
     * @memberof GetApproveAddressRequest
     */
    'tokenType': GetApproveAddressRequestTokenTypeEnum;
}

export const GetApproveAddressRequestTokenTypeEnum = {
    Erc20: 'ERC20',
    Erc721: 'ERC721',
    Erc1155: 'ERC1155',
    NonstandardFungible: 'NONSTANDARD_FUNGIBLE',
    NonstandardNonfungible: 'NONSTANDARD_NONFUNGIBLE'
} as const;

export type GetApproveAddressRequestTokenTypeEnum = typeof GetApproveAddressRequestTokenTypeEnum[keyof typeof GetApproveAddressRequestTokenTypeEnum];

/**
 * Response schema for getting the address to approve the token transfer.
 * @export
 * @interface GetApproveAddressResponse
 */
export interface GetApproveAddressResponse {
    /**
     * The address to approve the token transfer.
     * @type {string}
     * @memberof GetApproveAddressResponse
     */
    'approveAddress': string;
}
/**
 * 
 * @export
 * @interface GetHealthCheck200Response
 */
export interface GetHealthCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof GetHealthCheck200Response
     */
    'status'?: GetHealthCheck200ResponseStatusEnum;
}

export const GetHealthCheck200ResponseStatusEnum = {
    Available: 'AVAILABLE',
    Unavailable: 'UNAVAILABLE'
} as const;

export type GetHealthCheck200ResponseStatusEnum = typeof GetHealthCheck200ResponseStatusEnum[keyof typeof GetHealthCheck200ResponseStatusEnum];

/**
 * List of chains or systems and related metadata
 * @export
 * @interface GetIntegrations200Response
 */
export interface GetIntegrations200Response {
    /**
     * 
     * @type {Array<GetIntegrations200ResponseIntegrationsInner>}
     * @memberof GetIntegrations200Response
     */
    'integrations': Array<GetIntegrations200ResponseIntegrationsInner>;
}
/**
 * 
 * @export
 * @interface GetIntegrations200ResponseIntegrationsInner
 */
export interface GetIntegrations200ResponseIntegrationsInner {
    /**
     * A unique identifier for the blockchain network/system.
     * @type {string}
     * @memberof GetIntegrations200ResponseIntegrationsInner
     */
    'id': string;
    /**
     * The name of the blockchain network/system.
     * @type {string}
     * @memberof GetIntegrations200ResponseIntegrationsInner
     */
    'name': string;
    /**
     * The type of network (e.g., \'evm\', \'fabric\', \'SQL Database\').
     * @type {string}
     * @memberof GetIntegrations200ResponseIntegrationsInner
     */
    'type': string;
    /**
     * The specific network name (e.g., \'mainnet\', \'testnet\').
     * @type {string}
     * @memberof GetIntegrations200ResponseIntegrationsInner
     */
    'environment'?: string;
}
/**
 * Response schema for checking the status of a data transfer task. Includes the task ID and status of the task.
 * @export
 * @interface GetOracleTaskStatus200Response
 */
export interface GetOracleTaskStatus200Response {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof GetOracleTaskStatus200Response
     */
    'taskID': string;
    /**
     * The type of the Oracle task.
     * @type {string}
     * @memberof GetOracleTaskStatus200Response
     */
    'type': GetOracleTaskStatus200ResponseTypeEnum;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof GetOracleTaskStatus200Response
     */
    'srcNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseSrcContract}
     * @memberof GetOracleTaskStatus200Response
     */
    'srcContract': ExecuteOracleTask200ResponseSrcContract;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof GetOracleTaskStatus200Response
     */
    'dstNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseDstContract}
     * @memberof GetOracleTaskStatus200Response
     */
    'dstContract': ExecuteOracleTask200ResponseDstContract;
    /**
     * The timestamp when the Oracle task was created or last updated.
     * @type {number}
     * @memberof GetOracleTaskStatus200Response
     */
    'timestamp': number;
    /**
     * The list of operations performed by the Oracle task.
     * @type {Array<ExecuteOracleTask200ResponseOperationsInner>}
     * @memberof GetOracleTaskStatus200Response
     */
    'operations': Array<ExecuteOracleTask200ResponseOperationsInner>;
    /**
     * The current status of the Oracle task.
     * @type {string}
     * @memberof GetOracleTaskStatus200Response
     */
    'status': GetOracleTaskStatus200ResponseStatusEnum;
    /**
     * The mode of operation for registered tasks.
     * @type {string}
     * @memberof GetOracleTaskStatus200Response
     */
    'mode': GetOracleTaskStatus200ResponseModeEnum;
    /**
     * The interval for polling in milliseconds. Only if taskMode is POLLING.
     * @type {number}
     * @memberof GetOracleTaskStatus200Response
     */
    'pollingInterval'?: number;
}

export const GetOracleTaskStatus200ResponseTypeEnum = {
    Read: 'READ',
    Update: 'UPDATE',
    ReadAndUpdate: 'READ_AND_UPDATE'
} as const;

export type GetOracleTaskStatus200ResponseTypeEnum = typeof GetOracleTaskStatus200ResponseTypeEnum[keyof typeof GetOracleTaskStatus200ResponseTypeEnum];
export const GetOracleTaskStatus200ResponseStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type GetOracleTaskStatus200ResponseStatusEnum = typeof GetOracleTaskStatus200ResponseStatusEnum[keyof typeof GetOracleTaskStatus200ResponseStatusEnum];
export const GetOracleTaskStatus200ResponseModeEnum = {
    Polling: 'POLLING',
    EventListening: 'EVENT_LISTENING',
    Immediate: 'IMMEDIATE'
} as const;

export type GetOracleTaskStatus200ResponseModeEnum = typeof GetOracleTaskStatus200ResponseModeEnum[keyof typeof GetOracleTaskStatus200ResponseModeEnum];

/**
 * A collection of available and unavailable routes
 * @export
 * @interface GetRoutes200Response
 */
export interface GetRoutes200Response {
    /**
     * A collection of route objects
     * @type {Array<GetRoutes200ResponseRoutesInner>}
     * @memberof GetRoutes200Response
     */
    'routes': Array<GetRoutes200ResponseRoutesInner>;
}
/**
 * 
 * @export
 * @interface GetRoutes200ResponseRoutesInner
 */
export interface GetRoutes200ResponseRoutesInner {
    /**
     * A unique identifier of the route.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'id': string;
    /**
     * A unique identifier for the gateway.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'gatewayID': string;
    /**
     * The mode of operation for this route - \'data\' for arbitrary payload handling, \'transfer\' for asset transfer.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'mode': GetRoutes200ResponseRoutesInnerModeEnum;
    /**
     * The ID of the DLT Network where the operation will originate.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'fromDLTNetworkID'?: string;
    /**
     * The amount of \'fromToken\' to be transferred in USD, specified as a string to maintain precision.
     * @type {number}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'fromAmountUSD'?: number;
    /**
     * The amount that should be sent including all decimals (e.g., 1000000 for 1 USDC (6 decimals)).
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'fromAmount'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'fromToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The ID of the DLT Network where the operation will end.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'toDLTNetworkID'?: string;
    /**
     * The expected amount to be received in USD.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'toAmountUSD'?: string;
    /**
     * The expected amount to be received including all decimals (e.g., 1000000 for 1 USDC (6 decimals)).
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'toAmount'?: string;
    /**
     * The minimum expected amount to be received including all decimals (e.g., 1000000 for 1 USDC (6 decimals)).
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'toAmountMin'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'toToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The expected gas cost in USD.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'gasCostUSD'?: string;
    /**
     * Whether chain switching is enabled or not.
     * @type {boolean}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'containsSwitchChain'?: boolean;
    /**
     * List of steps involved in this route, adjusted for mode.
     * @type {Array<GetRoutes200ResponseRoutesInnerStepsInner>}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'steps'?: Array<GetRoutes200ResponseRoutesInnerStepsInner>;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerInsurance}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'insurance'?: GetRoutes200ResponseRoutesInnerInsurance;
    /**
     * List of tags identifiers providing additional context or categorization.
     * @type {Array<string>}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'tags'?: Array<string>;
}

export const GetRoutes200ResponseRoutesInnerModeEnum = {
    Data: 'data',
    Transfer: 'transfer'
} as const;

export type GetRoutes200ResponseRoutesInnerModeEnum = typeof GetRoutes200ResponseRoutesInnerModeEnum[keyof typeof GetRoutes200ResponseRoutesInnerModeEnum];

/**
 * Metadata detailing a supported token
 * @export
 * @interface GetRoutes200ResponseRoutesInnerFromToken
 */
export interface GetRoutes200ResponseRoutesInnerFromToken {
    /**
     * The network of the DLT being interacted with. TODO: implement network identification draft
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'chainID': string;
    /**
     * Supported DLT protocols.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'chainType': GetRoutes200ResponseRoutesInnerFromTokenChainTypeEnum;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'address': string;
    /**
     * The name of the token.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'name'?: string;
    /**
     * The symbol of the token.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'symbol': string;
    /**
     * How many decimals the token supports.
     * @type {number}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'decimals': number;
    /**
     * The logo of a token, chain, dex etc.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'logoURI'?: string;
    /**
     * List of tags identifiers providing additional context or categorization.
     * @type {Array<string>}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'tags'?: Array<string>;
    /**
     * The current price of the token in USD.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'priceUSD'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromTokenExtensions}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'extensions'?: GetRoutes200ResponseRoutesInnerFromTokenExtensions;
}

export const GetRoutes200ResponseRoutesInnerFromTokenChainTypeEnum = {
    HyperledgerFabric: 'HyperledgerFabric',
    HyperledgerBesu: 'HyperledgerBesu'
} as const;

export type GetRoutes200ResponseRoutesInnerFromTokenChainTypeEnum = typeof GetRoutes200ResponseRoutesInnerFromTokenChainTypeEnum[keyof typeof GetRoutes200ResponseRoutesInnerFromTokenChainTypeEnum];

/**
 * 
 * @export
 * @interface GetRoutes200ResponseRoutesInnerFromTokenExtensions
 */
export interface GetRoutes200ResponseRoutesInnerFromTokenExtensions {
    /**
     * 
     * @type {{ [key: string]: GetRoutes200ResponseRoutesInnerFromTokenExtensionsBridgeInfoValue; }}
     * @memberof GetRoutes200ResponseRoutesInnerFromTokenExtensions
     */
    'bridgeInfo'?: { [key: string]: GetRoutes200ResponseRoutesInnerFromTokenExtensionsBridgeInfoValue; };
    /**
     * Indicates whether the token is verified.
     * @type {boolean}
     * @memberof GetRoutes200ResponseRoutesInnerFromTokenExtensions
     */
    'verified'?: boolean;
}
/**
 * Information about the bridge used for the token transfer.
 * @export
 * @interface GetRoutes200ResponseRoutesInnerFromTokenExtensionsBridgeInfoValue
 */
export interface GetRoutes200ResponseRoutesInnerFromTokenExtensionsBridgeInfoValue {
    /**
     * The address of the token being transferred.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromTokenExtensionsBridgeInfoValue
     */
    'tokenAddress'?: string;
}
/**
 * 
 * @export
 * @interface GetRoutes200ResponseRoutesInnerInsurance
 */
export interface GetRoutes200ResponseRoutesInnerInsurance {
    /**
     * The state of insurance applicability for the transaction.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerInsurance
     */
    'state'?: GetRoutes200ResponseRoutesInnerInsuranceStateEnum;
    /**
     * The fee amount for insurance, represented in USD.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerInsurance
     */
    'feeAmountUsd'?: string;
}

export const GetRoutes200ResponseRoutesInnerInsuranceStateEnum = {
    NotInsurable: 'NOT_INSURABLE',
    Insurable: 'INSURABLE',
    Insured: 'INSURED'
} as const;

export type GetRoutes200ResponseRoutesInnerInsuranceStateEnum = typeof GetRoutes200ResponseRoutesInnerInsuranceStateEnum[keyof typeof GetRoutes200ResponseRoutesInnerInsuranceStateEnum];

/**
 * Details a single step within a route including actions and estimates.
 * @export
 * @interface GetRoutes200ResponseRoutesInnerStepsInner
 */
export interface GetRoutes200ResponseRoutesInnerStepsInner {
    /**
     * Id of the step
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'id'?: string;
    /**
     * Type of the step, typically describing the action, e.g., \'swap\'.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'type'?: string;
    /**
     * Tool used in the step, e.g., \'stargate\'.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'tool'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerAction}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'action'?: GetRoutes200ResponseRoutesInnerStepsInnerAction;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerEstimate}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'estimate'?: GetRoutes200ResponseRoutesInnerStepsInnerEstimate;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerToolDetails}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'toolDetails'?: GetRoutes200ResponseRoutesInnerStepsInnerToolDetails;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerToolDetails}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'integrationDetails'?: GetRoutes200ResponseRoutesInnerStepsInnerToolDetails;
    /**
     * IDs of further steps included within this step, allowing for nested actions without direct recursion.
     * @type {Array<string>}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'includedStepIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetRoutes200ResponseRoutesInnerStepsInnerAction
 */
export interface GetRoutes200ResponseRoutesInnerStepsInnerAction {
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerAction
     */
    'fromToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The amount of \'fromToken\' to be transferred, specified as a string to maintain precision.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerAction
     */
    'fromAmount'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerAction
     */
    'toToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The maximum acceptable difference between the expected price of the \'toToken\' and the price at the time of the transfer.
     * @type {number}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerAction
     */
    'slippage'?: number;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerAction
     */
    'fromAddress'?: string;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerAction
     */
    'toAddress'?: string;
}
/**
 * Provides an estimation for a transaction, including costs, amounts, and execution duration.
 * @export
 * @interface GetRoutes200ResponseRoutesInnerStepsInnerEstimate
 */
export interface GetRoutes200ResponseRoutesInnerStepsInnerEstimate {
    /**
     * A blockchain address.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'approvalAddress'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'toAmountMin'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'toAmount'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'fromAmount'?: string;
    /**
     * A collection of fee costs associated with the transaction.
     * @type {Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner>}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'feeCosts'?: Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner>;
    /**
     * A collection of estimated gas costs for executing the transaction.
     * @type {Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner>}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'gasCosts'?: Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner>;
    /**
     * The estimated duration for the transaction execution in seconds.
     * @type {number}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'executionDuration'?: number;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'fromAmountUSD'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'toAmountUSD'?: string;
    /**
     * The tool or service used to generate this estimate.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'tool'?: string;
}
/**
 * Details about a specific fee cost associated with the transaction.
 * @export
 * @interface GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner
 */
export interface GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner {
    /**
     * Name of the fee cost.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner
     */
    'name'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner
     */
    'amount'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner
     */
    'amountUSD'?: string;
    /**
     * The symbol of a token
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner
     */
    'token'?: string;
    /**
     * Indicates if the fee is included in the transaction amount.
     * @type {boolean}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner
     */
    'included'?: boolean;
}
/**
 * 
 * @export
 * @interface GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
 */
export interface GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner {
    /**
     * The type of the gas cost.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'type'?: string;
    /**
     * The gas price, specified as a string to maintain precision.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'price'?: string;
    /**
     * The estimated gas required, specified as a string to maintain precision.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'estimate'?: string;
    /**
     * The gas limit for the transaction, specified as a string to maintain precision.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'limit'?: string;
    /**
     * The amount of gas required in the gas currency.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'amount'?: string;
    /**
     * The amount of gas required in USD.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'amountUSD'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'token'?: GetRoutes200ResponseRoutesInnerFromToken;
}
/**
 * Describes integration or tool details such as bridges or exchanges involved in the transaction.
 * @export
 * @interface GetRoutes200ResponseRoutesInnerStepsInnerToolDetails
 */
export interface GetRoutes200ResponseRoutesInnerStepsInnerToolDetails {
    /**
     * A unique identifier for the integration or tool.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerToolDetails
     */
    'key': string;
    /**
     * The name of the integration or tool.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerToolDetails
     */
    'name': string;
    /**
     * URL to the logo of the integration or tool.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerToolDetails
     */
    'logoURI': string;
}
/**
 * 
 * @export
 * @interface HealthCheckResponse
 */
export interface HealthCheckResponse {
    /**
     * 
     * @type {string}
     * @memberof HealthCheckResponse
     */
    'status'?: HealthCheckResponseStatusEnum;
}

export const HealthCheckResponseStatusEnum = {
    Available: 'AVAILABLE',
    Unavailable: 'UNAVAILABLE'
} as const;

export type HealthCheckResponseStatusEnum = typeof HealthCheckResponseStatusEnum[keyof typeof HealthCheckResponseStatusEnum];

/**
 * Details a single step within a route including actions and estimates.
 * @export
 * @interface IncludedStep
 */
export interface IncludedStep {
    /**
     * Id of the step
     * @type {string}
     * @memberof IncludedStep
     */
    'id'?: string;
    /**
     * Type of the step, typically describing the action, e.g., \'swap\'.
     * @type {string}
     * @memberof IncludedStep
     */
    'type'?: string;
    /**
     * Tool used in the step, e.g., \'stargate\'.
     * @type {string}
     * @memberof IncludedStep
     */
    'tool'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerAction}
     * @memberof IncludedStep
     */
    'action'?: GetRoutes200ResponseRoutesInnerStepsInnerAction;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerEstimate}
     * @memberof IncludedStep
     */
    'estimate'?: GetRoutes200ResponseRoutesInnerStepsInnerEstimate;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerToolDetails}
     * @memberof IncludedStep
     */
    'toolDetails'?: GetRoutes200ResponseRoutesInnerStepsInnerToolDetails;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerToolDetails}
     * @memberof IncludedStep
     */
    'integrationDetails'?: GetRoutes200ResponseRoutesInnerStepsInnerToolDetails;
    /**
     * IDs of further steps included within this step, allowing for nested actions without direct recursion.
     * @type {Array<string>}
     * @memberof IncludedStep
     */
    'includedStepIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Insurance
 */
export interface Insurance {
    /**
     * The state of insurance applicability for the transaction.
     * @type {string}
     * @memberof Insurance
     */
    'state'?: InsuranceStateEnum;
    /**
     * The fee amount for insurance, represented in USD.
     * @type {string}
     * @memberof Insurance
     */
    'feeAmountUsd'?: string;
}

export const InsuranceStateEnum = {
    NotInsurable: 'NOT_INSURABLE',
    Insurable: 'INSURABLE',
    Insured: 'INSURED'
} as const;

export type InsuranceStateEnum = typeof InsuranceStateEnum[keyof typeof InsuranceStateEnum];

/**
 * 
 * @export
 * @interface Integration
 */
export interface Integration {
    /**
     * A unique identifier for the blockchain network/system.
     * @type {string}
     * @memberof Integration
     */
    'id': string;
    /**
     * The name of the blockchain network/system.
     * @type {string}
     * @memberof Integration
     */
    'name': string;
    /**
     * The type of network (e.g., \'evm\', \'fabric\', \'SQL Database\').
     * @type {string}
     * @memberof Integration
     */
    'type': string;
    /**
     * The specific network name (e.g., \'mainnet\', \'testnet\').
     * @type {string}
     * @memberof Integration
     */
    'environment'?: string;
}
/**
 * Describes integration or tool details such as bridges or exchanges involved in the transaction.
 * @export
 * @interface IntegrationDetails
 */
export interface IntegrationDetails {
    /**
     * A unique identifier for the integration or tool.
     * @type {string}
     * @memberof IntegrationDetails
     */
    'key': string;
    /**
     * The name of the integration or tool.
     * @type {string}
     * @memberof IntegrationDetails
     */
    'name': string;
    /**
     * URL to the logo of the integration or tool.
     * @type {string}
     * @memberof IntegrationDetails
     */
    'logoURI': string;
}
/**
 * List of chains or systems and related metadata
 * @export
 * @interface IntegrationsResponse
 */
export interface IntegrationsResponse {
    /**
     * 
     * @type {Array<GetIntegrations200ResponseIntegrationsInner>}
     * @memberof IntegrationsResponse
     */
    'integrations': Array<GetIntegrations200ResponseIntegrationsInner>;
}
/**
 * The network of the DLT being interacted with.
 * @export
 * @interface NetworkId
 */
export interface NetworkId {
    /**
     * The network of the DLT being interacted with.
     * @type {string}
     * @memberof NetworkId
     */
    'id': string;
    /**
     * Enumerates the different ledger vendors and their major versions encoded within the name of the LedgerType. For example \"BESU_1X\" involves all of the [1.0.0;2.0.0) where 1.0.0 is included and anything up until, but not 2.0.0. See: https://stackoverflow.com/a/4396303/698470 for further explanation.
     * @type {string}
     * @memberof NetworkId
     */
    'ledgerType': NetworkIdLedgerTypeEnum;
}

export const NetworkIdLedgerTypeEnum = {
    Besu1X: 'BESU_1X',
    Besu2X: 'BESU_2X',
    Burrow0X: 'BURROW_0X',
    Corda4X: 'CORDA_4X',
    Ethereum: 'ETHEREUM',
    Fabric2: 'FABRIC_2',
    Sawtooth1X: 'SAWTOOTH_1X'
} as const;

export type NetworkIdLedgerTypeEnum = typeof NetworkIdLedgerTypeEnum[keyof typeof NetworkIdLedgerTypeEnum];

/**
 * Request schema for triggering an immediate transfer task. Includes the task ID, payload, and destination network and contract details.
 * @export
 * @interface OracleExecuteRequest
 */
export interface OracleExecuteRequest {
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof OracleExecuteRequest
     */
    'sourceNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof OracleExecuteRequest
     */
    'destinationNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTaskRequestSourceContract}
     * @memberof OracleExecuteRequest
     */
    'sourceContract'?: ExecuteOracleTaskRequestSourceContract;
    /**
     * 
     * @type {ExecuteOracleTaskRequestDestinationContract}
     * @memberof OracleExecuteRequest
     */
    'destinationContract'?: ExecuteOracleTaskRequestDestinationContract;
    /**
     * The type of task to be registered.
     * @type {string}
     * @memberof OracleExecuteRequest
     */
    'taskType'?: OracleExecuteRequestTaskTypeEnum;
}

export const OracleExecuteRequestTaskTypeEnum = {
    Read: 'READ',
    Update: 'UPDATE',
    ReadAndUpdate: 'READ_AND_UPDATE'
} as const;

export type OracleExecuteRequestTaskTypeEnum = typeof OracleExecuteRequestTaskTypeEnum[keyof typeof OracleExecuteRequestTaskTypeEnum];

/**
 * Response schema for executing a data transfer task. Includes the task ID and status of the execution.
 * @export
 * @interface OracleExecuteResponse
 */
export interface OracleExecuteResponse {
    /**
     * The unique identifier of the task.
     * @type {string}
     * @memberof OracleExecuteResponse
     */
    'taskID': string;
    /**
     * The type of the Oracle task.
     * @type {string}
     * @memberof OracleExecuteResponse
     */
    'type': OracleExecuteResponseTypeEnum;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof OracleExecuteResponse
     */
    'srcNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseSrcContract}
     * @memberof OracleExecuteResponse
     */
    'srcContract': ExecuteOracleTask200ResponseSrcContract;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof OracleExecuteResponse
     */
    'dstNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseDstContract}
     * @memberof OracleExecuteResponse
     */
    'dstContract': ExecuteOracleTask200ResponseDstContract;
    /**
     * The timestamp when the Oracle task was created or last updated.
     * @type {number}
     * @memberof OracleExecuteResponse
     */
    'timestamp': number;
    /**
     * The list of operations performed by the Oracle task.
     * @type {Array<ExecuteOracleTask200ResponseOperationsInner>}
     * @memberof OracleExecuteResponse
     */
    'operations': Array<ExecuteOracleTask200ResponseOperationsInner>;
    /**
     * The current status of the Oracle task.
     * @type {string}
     * @memberof OracleExecuteResponse
     */
    'status': OracleExecuteResponseStatusEnum;
    /**
     * The mode of operation for registered tasks.
     * @type {string}
     * @memberof OracleExecuteResponse
     */
    'mode': OracleExecuteResponseModeEnum;
    /**
     * The interval for polling in milliseconds. Only if taskMode is POLLING.
     * @type {number}
     * @memberof OracleExecuteResponse
     */
    'pollingInterval'?: number;
}

export const OracleExecuteResponseTypeEnum = {
    Read: 'READ',
    Update: 'UPDATE',
    ReadAndUpdate: 'READ_AND_UPDATE'
} as const;

export type OracleExecuteResponseTypeEnum = typeof OracleExecuteResponseTypeEnum[keyof typeof OracleExecuteResponseTypeEnum];
export const OracleExecuteResponseStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type OracleExecuteResponseStatusEnum = typeof OracleExecuteResponseStatusEnum[keyof typeof OracleExecuteResponseStatusEnum];
export const OracleExecuteResponseModeEnum = {
    Polling: 'POLLING',
    EventListening: 'EVENT_LISTENING',
    Immediate: 'IMMEDIATE'
} as const;

export type OracleExecuteResponseModeEnum = typeof OracleExecuteResponseModeEnum[keyof typeof OracleExecuteResponseModeEnum];

/**
 * Represents an operation performed by the Oracle, including its type, network, contract, status, and optional output.
 * @export
 * @interface OracleOperation
 */
export interface OracleOperation {
    /**
     * A unique identifier for the Oracle operation.
     * @type {string}
     * @memberof OracleOperation
     */
    'id': string;
    /**
     * The type of the Oracle operation.
     * @type {string}
     * @memberof OracleOperation
     */
    'type': OracleOperationTypeEnum;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof OracleOperation
     */
    'networkId': TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseOperationsInnerContract}
     * @memberof OracleOperation
     */
    'contract': ExecuteOracleTask200ResponseOperationsInnerContract;
    /**
     * The current status of the Oracle operation.
     * @type {string}
     * @memberof OracleOperation
     */
    'status': OracleOperationStatusEnum;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseOperationsInnerOutput}
     * @memberof OracleOperation
     */
    'output'?: ExecuteOracleTask200ResponseOperationsInnerOutput;
    /**
     * The timestamp when the Oracle operation was created or last updated.
     * @type {number}
     * @memberof OracleOperation
     */
    'timestamp': number;
}

export const OracleOperationTypeEnum = {
    Read: 'READ',
    Update: 'UPDATE'
} as const;

export type OracleOperationTypeEnum = typeof OracleOperationTypeEnum[keyof typeof OracleOperationTypeEnum];
export const OracleOperationStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type OracleOperationStatusEnum = typeof OracleOperationStatusEnum[keyof typeof OracleOperationStatusEnum];

/**
 * Request schema for registering a repeatable task.
 * @export
 * @interface OracleRegisterRequest
 */
export interface OracleRegisterRequest {
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof OracleRegisterRequest
     */
    'sourceNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof OracleRegisterRequest
     */
    'destinationNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {RegisterOracleTaskRequestSourceContract}
     * @memberof OracleRegisterRequest
     */
    'sourceContract'?: RegisterOracleTaskRequestSourceContract;
    /**
     * 
     * @type {RegisterOracleTaskRequestDestinationContract}
     * @memberof OracleRegisterRequest
     */
    'destinationContract'?: RegisterOracleTaskRequestDestinationContract;
    /**
     * The mode of operation for the repeatable task.
     * @type {string}
     * @memberof OracleRegisterRequest
     */
    'taskMode': OracleRegisterRequestTaskModeEnum;
    /**
     * The interval for polling in milliseconds. Only if taskMode is POLLING.
     * @type {number}
     * @memberof OracleRegisterRequest
     */
    'pollingInterval'?: number;
    /**
     * 
     * @type {RegisterOracleTaskRequestListeningOptions}
     * @memberof OracleRegisterRequest
     */
    'listeningOptions'?: RegisterOracleTaskRequestListeningOptions;
    /**
     * The type of task to be registered.
     * @type {string}
     * @memberof OracleRegisterRequest
     */
    'taskType': OracleRegisterRequestTaskTypeEnum;
}

export const OracleRegisterRequestTaskModeEnum = {
    Polling: 'POLLING',
    EventListening: 'EVENT_LISTENING'
} as const;

export type OracleRegisterRequestTaskModeEnum = typeof OracleRegisterRequestTaskModeEnum[keyof typeof OracleRegisterRequestTaskModeEnum];
export const OracleRegisterRequestTaskTypeEnum = {
    Read: 'READ',
    Update: 'UPDATE',
    ReadAndUpdate: 'READ_AND_UPDATE'
} as const;

export type OracleRegisterRequestTaskTypeEnum = typeof OracleRegisterRequestTaskTypeEnum[keyof typeof OracleRegisterRequestTaskTypeEnum];

/**
 * Response schema for registering a repeatable task. Includes the task ID and status of the registration.
 * @export
 * @interface OracleRegisterResponse
 */
export interface OracleRegisterResponse {
    /**
     * The unique identifier of the task.
     * @type {string}
     * @memberof OracleRegisterResponse
     */
    'taskID'?: string;
    /**
     * 
     * @type {string}
     * @memberof OracleRegisterResponse
     */
    'status'?: OracleRegisterResponseStatusEnum;
}

export const OracleRegisterResponseStatusEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type OracleRegisterResponseStatusEnum = typeof OracleRegisterResponseStatusEnum[keyof typeof OracleRegisterResponseStatusEnum];

/**
 * Represents the response from an Oracle task execution, including transaction details and outputs.
 * @export
 * @interface OracleResponse
 */
export interface OracleResponse {
    /**
     * The unique identifier for the transaction.
     * @type {string}
     * @memberof OracleResponse
     */
    'transactionId'?: string;
    /**
     * The receipt of the transaction, providing proof of execution.
     * @type {object}
     * @memberof OracleResponse
     */
    'transactionReceipt'?: object;
    /**
     * The output of the Oracle operation execution.
     * @type {string}
     * @memberof OracleResponse
     */
    'output'?: string;
    /**
     * Proof of the Oracle operation execution.
     * @type {object}
     * @memberof OracleResponse
     */
    'proof'?: object;
}
/**
 * Request schema for checking the status of a data transfer task.
 * @export
 * @interface OracleStatusRequest
 */
export interface OracleStatusRequest {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof OracleStatusRequest
     */
    'taskID': string;
}
/**
 * Response schema for checking the status of a data transfer task. Includes the task ID and status of the task.
 * @export
 * @interface OracleStatusResponse
 */
export interface OracleStatusResponse {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof OracleStatusResponse
     */
    'taskID': string;
    /**
     * The type of the Oracle task.
     * @type {string}
     * @memberof OracleStatusResponse
     */
    'type': OracleStatusResponseTypeEnum;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof OracleStatusResponse
     */
    'srcNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseSrcContract}
     * @memberof OracleStatusResponse
     */
    'srcContract': ExecuteOracleTask200ResponseSrcContract;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof OracleStatusResponse
     */
    'dstNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseDstContract}
     * @memberof OracleStatusResponse
     */
    'dstContract': ExecuteOracleTask200ResponseDstContract;
    /**
     * The timestamp when the Oracle task was created or last updated.
     * @type {number}
     * @memberof OracleStatusResponse
     */
    'timestamp': number;
    /**
     * The list of operations performed by the Oracle task.
     * @type {Array<ExecuteOracleTask200ResponseOperationsInner>}
     * @memberof OracleStatusResponse
     */
    'operations': Array<ExecuteOracleTask200ResponseOperationsInner>;
    /**
     * The current status of the Oracle task.
     * @type {string}
     * @memberof OracleStatusResponse
     */
    'status': OracleStatusResponseStatusEnum;
    /**
     * The mode of operation for registered tasks.
     * @type {string}
     * @memberof OracleStatusResponse
     */
    'mode': OracleStatusResponseModeEnum;
    /**
     * The interval for polling in milliseconds. Only if taskMode is POLLING.
     * @type {number}
     * @memberof OracleStatusResponse
     */
    'pollingInterval'?: number;
}

export const OracleStatusResponseTypeEnum = {
    Read: 'READ',
    Update: 'UPDATE',
    ReadAndUpdate: 'READ_AND_UPDATE'
} as const;

export type OracleStatusResponseTypeEnum = typeof OracleStatusResponseTypeEnum[keyof typeof OracleStatusResponseTypeEnum];
export const OracleStatusResponseStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type OracleStatusResponseStatusEnum = typeof OracleStatusResponseStatusEnum[keyof typeof OracleStatusResponseStatusEnum];
export const OracleStatusResponseModeEnum = {
    Polling: 'POLLING',
    EventListening: 'EVENT_LISTENING',
    Immediate: 'IMMEDIATE'
} as const;

export type OracleStatusResponseModeEnum = typeof OracleStatusResponseModeEnum[keyof typeof OracleStatusResponseModeEnum];

/**
 * Represents a repeatable Oracle task with additional properties for mode, polling interval, and source event signature.
 * @export
 * @interface OracleTask
 */
export interface OracleTask {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof OracleTask
     */
    'taskID': string;
    /**
     * The type of the Oracle task.
     * @type {string}
     * @memberof OracleTask
     */
    'type': OracleTaskTypeEnum;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof OracleTask
     */
    'srcNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseSrcContract}
     * @memberof OracleTask
     */
    'srcContract': ExecuteOracleTask200ResponseSrcContract;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof OracleTask
     */
    'dstNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {ExecuteOracleTask200ResponseDstContract}
     * @memberof OracleTask
     */
    'dstContract': ExecuteOracleTask200ResponseDstContract;
    /**
     * The timestamp when the Oracle task was created or last updated.
     * @type {number}
     * @memberof OracleTask
     */
    'timestamp': number;
    /**
     * The list of operations performed by the Oracle task.
     * @type {Array<ExecuteOracleTask200ResponseOperationsInner>}
     * @memberof OracleTask
     */
    'operations': Array<ExecuteOracleTask200ResponseOperationsInner>;
    /**
     * The current status of the Oracle task.
     * @type {string}
     * @memberof OracleTask
     */
    'status': OracleTaskStatusEnum;
    /**
     * The mode of operation for registered tasks.
     * @type {string}
     * @memberof OracleTask
     */
    'mode': OracleTaskModeEnum;
    /**
     * The interval for polling in milliseconds. Only if taskMode is POLLING.
     * @type {number}
     * @memberof OracleTask
     */
    'pollingInterval'?: number;
    /**
     * 
     * @type {RegisterOracleTaskRequestListeningOptions}
     * @memberof OracleTask
     */
    'listeningOptions'?: RegisterOracleTaskRequestListeningOptions;
}

export const OracleTaskTypeEnum = {
    Read: 'READ',
    Update: 'UPDATE',
    ReadAndUpdate: 'READ_AND_UPDATE'
} as const;

export type OracleTaskTypeEnum = typeof OracleTaskTypeEnum[keyof typeof OracleTaskTypeEnum];
export const OracleTaskStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type OracleTaskStatusEnum = typeof OracleTaskStatusEnum[keyof typeof OracleTaskStatusEnum];
export const OracleTaskModeEnum = {
    Polling: 'POLLING',
    EventListening: 'EVENT_LISTENING',
    Immediate: 'IMMEDIATE'
} as const;

export type OracleTaskModeEnum = typeof OracleTaskModeEnum[keyof typeof OracleTaskModeEnum];

/**
 * Request schema for unregistering a data transfer task. Includes the context ID of the task to be unregistered.
 * @export
 * @interface OracleUnregisterRequest
 */
export interface OracleUnregisterRequest {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof OracleUnregisterRequest
     */
    'taskID': string;
}
/**
 * Response schema for unregistering a data transfer task. Includes the task ID and status of the unregistration.
 * @export
 * @interface OracleUnregisterResponse
 */
export interface OracleUnregisterResponse {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof OracleUnregisterResponse
     */
    'taskID'?: string;
    /**
     * 
     * @type {string}
     * @memberof OracleUnregisterResponse
     */
    'status'?: OracleUnregisterResponseStatusEnum;
}

export const OracleUnregisterResponseStatusEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type OracleUnregisterResponseStatusEnum = typeof OracleUnregisterResponseStatusEnum[keyof typeof OracleUnregisterResponseStatusEnum];

/**
 * Response for a pause transaction request. Returns the current status of the SATP session post-pause action.
 * @export
 * @interface Pause200Response
 */
export interface Pause200Response {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof Pause200Response
     */
    'statusResponse': Transact200ResponseStatusResponse;
}
/**
 * Request to temporarily pause an ongoing transaction session, identified by the session and context IDs.
 * @export
 * @interface PauseRequest
 */
export interface PauseRequest {
    /**
     * 
     * @type {string}
     * @memberof PauseRequest
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PauseRequest
     */
    'contextId'?: string;
}
/**
 * Response for a pause transaction request. Returns the current status of the SATP session post-pause action.
 * @export
 * @interface PauseResponse
 */
export interface PauseResponse {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof PauseResponse
     */
    'statusResponse': Transact200ResponseStatusResponse;
}
/**
 * Response schema for an audit request. Contains the proofs generated during the audit period and the start and end datetimes.
 * @export
 * @interface PerformAudit200Response
 */
export interface PerformAudit200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof PerformAudit200Response
     */
    'sessions'?: Array<string>;
    /**
     * The start timestamp for the audit period, as a Unix timestamp (milliseconds since epoch).
     * @type {number}
     * @memberof PerformAudit200Response
     */
    'startTimestamp'?: number;
    /**
     * The end timestamp for the audit period, as a Unix timestamp (milliseconds since epoch).
     * @type {number}
     * @memberof PerformAudit200Response
     */
    'endTimestamp'?: number;
}
/**
 * Response schema for registering a repeatable task. Includes the task ID and status of the registration.
 * @export
 * @interface RegisterOracleTask200Response
 */
export interface RegisterOracleTask200Response {
    /**
     * The unique identifier of the task.
     * @type {string}
     * @memberof RegisterOracleTask200Response
     */
    'taskID'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterOracleTask200Response
     */
    'status'?: RegisterOracleTask200ResponseStatusEnum;
}

export const RegisterOracleTask200ResponseStatusEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type RegisterOracleTask200ResponseStatusEnum = typeof RegisterOracleTask200ResponseStatusEnum[keyof typeof RegisterOracleTask200ResponseStatusEnum];

/**
 * Request schema for registering a repeatable task.
 * @export
 * @interface RegisterOracleTaskRequest
 */
export interface RegisterOracleTaskRequest {
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof RegisterOracleTaskRequest
     */
    'sourceNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof RegisterOracleTaskRequest
     */
    'destinationNetworkId'?: TransactRequestSourceAssetNetworkId;
    /**
     * 
     * @type {RegisterOracleTaskRequestSourceContract}
     * @memberof RegisterOracleTaskRequest
     */
    'sourceContract'?: RegisterOracleTaskRequestSourceContract;
    /**
     * 
     * @type {RegisterOracleTaskRequestDestinationContract}
     * @memberof RegisterOracleTaskRequest
     */
    'destinationContract'?: RegisterOracleTaskRequestDestinationContract;
    /**
     * The mode of operation for the repeatable task.
     * @type {string}
     * @memberof RegisterOracleTaskRequest
     */
    'taskMode': RegisterOracleTaskRequestTaskModeEnum;
    /**
     * The interval for polling in milliseconds. Only if taskMode is POLLING.
     * @type {number}
     * @memberof RegisterOracleTaskRequest
     */
    'pollingInterval'?: number;
    /**
     * 
     * @type {RegisterOracleTaskRequestListeningOptions}
     * @memberof RegisterOracleTaskRequest
     */
    'listeningOptions'?: RegisterOracleTaskRequestListeningOptions;
    /**
     * The type of task to be registered.
     * @type {string}
     * @memberof RegisterOracleTaskRequest
     */
    'taskType': RegisterOracleTaskRequestTaskTypeEnum;
}

export const RegisterOracleTaskRequestTaskModeEnum = {
    Polling: 'POLLING',
    EventListening: 'EVENT_LISTENING'
} as const;

export type RegisterOracleTaskRequestTaskModeEnum = typeof RegisterOracleTaskRequestTaskModeEnum[keyof typeof RegisterOracleTaskRequestTaskModeEnum];
export const RegisterOracleTaskRequestTaskTypeEnum = {
    Read: 'READ',
    Update: 'UPDATE',
    ReadAndUpdate: 'READ_AND_UPDATE'
} as const;

export type RegisterOracleTaskRequestTaskTypeEnum = typeof RegisterOracleTaskRequestTaskTypeEnum[keyof typeof RegisterOracleTaskRequestTaskTypeEnum];

/**
 * The contract address on the destination blockchain. Only if taskType is UPDATE or READ_AND_UPDATE.
 * @export
 * @interface RegisterOracleTaskRequestDestinationContract
 */
export interface RegisterOracleTaskRequestDestinationContract {
    /**
     * The name of the contract.
     * @type {string}
     * @memberof RegisterOracleTaskRequestDestinationContract
     */
    'contractName'?: string;
    /**
     * The address of the contract.
     * @type {string}
     * @memberof RegisterOracleTaskRequestDestinationContract
     */
    'contractAddress'?: string | null;
    /**
     * The ABI (Application Binary Interface) of the contract.
     * @type {Array<object>}
     * @memberof RegisterOracleTaskRequestDestinationContract
     */
    'contractAbi'?: Array<object> | null;
    /**
     * The bytecode of the contract.
     * @type {string}
     * @memberof RegisterOracleTaskRequestDestinationContract
     */
    'contractBytecode'?: string | null;
    /**
     * The name of the method to be invoked on the contract.
     * @type {string}
     * @memberof RegisterOracleTaskRequestDestinationContract
     */
    'methodName'?: string;
    /**
     * The parameters to be passed to the contract method.
     * @type {Array<ExecuteOracleTaskRequestSourceContractParamsInner>}
     * @memberof RegisterOracleTaskRequestDestinationContract
     */
    'params'?: Array<ExecuteOracleTaskRequestSourceContractParamsInner>;
}
/**
 * Options for event listening. Only if taskMode is EVENT_LISTENING.
 * @export
 * @interface RegisterOracleTaskRequestListeningOptions
 */
export interface RegisterOracleTaskRequestListeningOptions {
    /**
     * The event signature to listen for on the source network. Only if taskMode is EVENT_LISTENING.
     * @type {string}
     * @memberof RegisterOracleTaskRequestListeningOptions
     */
    'eventSignature': string;
    /**
     * The parameters to filter in the captured events.
     * @type {Array<string>}
     * @memberof RegisterOracleTaskRequestListeningOptions
     */
    'filterParams'?: Array<string>;
}
/**
 * The contract address on the source blockchain. Only if taskType is READ or READ_AND_UPDATE.
 * @export
 * @interface RegisterOracleTaskRequestSourceContract
 */
export interface RegisterOracleTaskRequestSourceContract {
    /**
     * The name of the contract.
     * @type {string}
     * @memberof RegisterOracleTaskRequestSourceContract
     */
    'contractName'?: string;
    /**
     * The address of the contract.
     * @type {string}
     * @memberof RegisterOracleTaskRequestSourceContract
     */
    'contractAddress'?: string | null;
    /**
     * The ABI (Application Binary Interface) of the contract.
     * @type {Array<object>}
     * @memberof RegisterOracleTaskRequestSourceContract
     */
    'contractAbi'?: Array<object> | null;
    /**
     * The bytecode of the contract.
     * @type {string}
     * @memberof RegisterOracleTaskRequestSourceContract
     */
    'contractBytecode'?: string | null;
    /**
     * The name of the method to be invoked on the contract.
     * @type {string}
     * @memberof RegisterOracleTaskRequestSourceContract
     */
    'methodName'?: string;
    /**
     * The parameters to be passed to the contract method.
     * @type {Array<ExecuteOracleTaskRequestSourceContractParamsInner>}
     * @memberof RegisterOracleTaskRequestSourceContract
     */
    'params'?: Array<ExecuteOracleTaskRequestSourceContractParamsInner>;
}
/**
 * 
 * @export
 * @interface Route
 */
export interface Route {
    /**
     * A unique identifier of the route.
     * @type {string}
     * @memberof Route
     */
    'id': string;
    /**
     * A unique identifier for the gateway.
     * @type {string}
     * @memberof Route
     */
    'gatewayID': string;
    /**
     * The mode of operation for this route - \'data\' for arbitrary payload handling, \'transfer\' for asset transfer.
     * @type {string}
     * @memberof Route
     */
    'mode': RouteModeEnum;
    /**
     * The ID of the DLT Network where the operation will originate.
     * @type {string}
     * @memberof Route
     */
    'fromDLTNetworkID'?: string;
    /**
     * The amount of \'fromToken\' to be transferred in USD, specified as a string to maintain precision.
     * @type {number}
     * @memberof Route
     */
    'fromAmountUSD'?: number;
    /**
     * The amount that should be sent including all decimals (e.g., 1000000 for 1 USDC (6 decimals)).
     * @type {string}
     * @memberof Route
     */
    'fromAmount'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof Route
     */
    'fromToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The ID of the DLT Network where the operation will end.
     * @type {string}
     * @memberof Route
     */
    'toDLTNetworkID'?: string;
    /**
     * The expected amount to be received in USD.
     * @type {string}
     * @memberof Route
     */
    'toAmountUSD'?: string;
    /**
     * The expected amount to be received including all decimals (e.g., 1000000 for 1 USDC (6 decimals)).
     * @type {string}
     * @memberof Route
     */
    'toAmount'?: string;
    /**
     * The minimum expected amount to be received including all decimals (e.g., 1000000 for 1 USDC (6 decimals)).
     * @type {string}
     * @memberof Route
     */
    'toAmountMin'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof Route
     */
    'toToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The expected gas cost in USD.
     * @type {string}
     * @memberof Route
     */
    'gasCostUSD'?: string;
    /**
     * Whether chain switching is enabled or not.
     * @type {boolean}
     * @memberof Route
     */
    'containsSwitchChain'?: boolean;
    /**
     * List of steps involved in this route, adjusted for mode.
     * @type {Array<GetRoutes200ResponseRoutesInnerStepsInner>}
     * @memberof Route
     */
    'steps'?: Array<GetRoutes200ResponseRoutesInnerStepsInner>;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerInsurance}
     * @memberof Route
     */
    'insurance'?: GetRoutes200ResponseRoutesInnerInsurance;
    /**
     * List of tags identifiers providing additional context or categorization.
     * @type {Array<string>}
     * @memberof Route
     */
    'tags'?: Array<string>;
}

export const RouteModeEnum = {
    Data: 'data',
    Transfer: 'transfer'
} as const;

export type RouteModeEnum = typeof RouteModeEnum[keyof typeof RouteModeEnum];

/**
 * A collection of available and unavailable routes
 * @export
 * @interface RoutesResponse
 */
export interface RoutesResponse {
    /**
     * A collection of route objects
     * @type {Array<GetRoutes200ResponseRoutesInner>}
     * @memberof RoutesResponse
     */
    'routes': Array<GetRoutes200ResponseRoutesInner>;
}
/**
 * Request for retrieving the current status of a session, identified by the session ID.
 * @export
 * @interface StatusRequest
 */
export interface StatusRequest {
    /**
     * The ID of the session for which the status is being requested.
     * @type {string}
     * @memberof StatusRequest
     */
    'sessionID': string;
}
/**
 * Provides the current status of the SATP session including detailed information on the progress, such as substatus, stage, and step, along with the session start time and chain information.
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'status': StatusResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'substatus': StatusResponseSubstatusEnum;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'stage': StatusResponseStageEnum;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'step': StatusResponseStepEnum;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'startTime': string;
    /**
     * 
     * @type {Transact200ResponseStatusResponseOriginNetwork}
     * @memberof StatusResponse
     */
    'originNetwork': Transact200ResponseStatusResponseOriginNetwork;
    /**
     * 
     * @type {Transact200ResponseStatusResponseDestinationNetwork}
     * @memberof StatusResponse
     */
    'destinationNetwork': Transact200ResponseStatusResponseDestinationNetwork;
}

export const StatusResponseStatusEnum = {
    NotFound: 'NOT_FOUND',
    Invalid: 'INVALID',
    Pending: 'PENDING',
    Done: 'DONE',
    Failed: 'FAILED'
} as const;

export type StatusResponseStatusEnum = typeof StatusResponseStatusEnum[keyof typeof StatusResponseStatusEnum];
export const StatusResponseSubstatusEnum = {
    WaitSourceConfirmations: 'WAIT_SOURCE_CONFIRMATIONS',
    WaitDestinationTransaction: 'WAIT_DESTINATION_TRANSACTION',
    BridgeNotAvailable: 'BRIDGE_NOT_AVAILABLE',
    ChainNotAvailable: 'CHAIN_NOT_AVAILABLE',
    RefundInProgress: 'REFUND_IN_PROGRESS',
    UnknownError: 'UNKNOWN_ERROR',
    Completed: 'COMPLETED',
    Partial: 'PARTIAL',
    Refunded: 'REFUNDED',
    NotProcessableRefundNeeded: 'NOT_PROCESSABLE_REFUND_NEEDED',
    Recovering: 'RECOVERING',
    Recovered: 'RECOVERED',
    RecoveryFailed: 'RECOVERY_FAILED',
    Rejected: 'REJECTED'
} as const;

export type StatusResponseSubstatusEnum = typeof StatusResponseSubstatusEnum[keyof typeof StatusResponseSubstatusEnum];
export const StatusResponseStageEnum = {
    _0: 'STAGE_0',
    _1: 'STAGE_1',
    _2: 'STAGE_2',
    _3: 'STAGE_3'
} as const;

export type StatusResponseStageEnum = typeof StatusResponseStageEnum[keyof typeof StatusResponseStageEnum];
export const StatusResponseStepEnum = {
    TransferInitializationClaims: 'transfer-initialization-claims',
    ConveyanceOfNetworkCapabilitiesAndParameters: 'conveyance-of-network-capabilities-and-parameters',
    TransferProposalMessage: 'transfer-proposal-message',
    TransferProposalReceiptMessage: 'transfer-proposal-receipt-message',
    TransferProposalRejectAndConditionalRejectMessage: 'transfer-proposal-reject-and-conditional-reject-message',
    TransferCommenceMessage: 'transfer-commence-message',
    CommenceResponseMessage: 'commence-response-message',
    LockAssertionMessage: 'lock-assertion-message',
    LockAssertionReceiptMessage: 'lock-assertion-receipt-message',
    CommitPreparationMessage: 'commit-preparation-message',
    CommitReadyMessage: 'commit-ready-message',
    CommitFinalAssertionMessage: 'commit-final-assertion-message',
    CommitFinalAcknowledgementReceiptMessage: 'commit-final-acknowledgement-receipt-message',
    TransferCompleteMessage: 'transfer-complete-message',
    RollbackTransferInitializationClaims: 'rollback-transfer-initialization-claims',
    RollbackConveyanceOfNetworkCapabilitiesAndParameters: 'rollback-conveyance-of-network-capabilities-and-parameters',
    RollbackTransferProposalMessage: 'rollback-transfer-proposal-message',
    RollbackTransferProposalReceiptMessage: 'rollback-transfer-proposal-receipt-message',
    RollbackTransferProposalRejectAndConditionalRejectMessage: 'rollback-transfer-proposal-reject-and-conditional-reject-message',
    RollbackTransferCommenceMessage: 'rollback-transfer-commence-message',
    RollbackCommenceResponseMessage: 'rollback-commence-response-message',
    RollbackLockAssertionMessage: 'rollback-lock-assertion-message',
    RollbackLockAssertionReceiptMessage: 'rollback-lock-assertion-receipt-message',
    RollbackCommitPreparationMessage: 'rollback-commit-preparation-message',
    RollbackCommitReadyMessage: 'rollback-commit-ready-message',
    RollbackCommitFinalAssertionMessage: 'rollback-commit-final-assertion-message',
    RollbackCommitFinalAcknowledgementReceiptMessage: 'rollback-commit-final-acknowledgement-receipt-message',
    RollbackTransferCompleteMessage: 'rollback-transfer-complete-message'
} as const;

export type StatusResponseStepEnum = typeof StatusResponseStepEnum[keyof typeof StatusResponseStepEnum];

/**
 * Metadata detailing a supported token
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * The network of the DLT being interacted with. TODO: implement network identification draft
     * @type {string}
     * @memberof Token
     */
    'chainID': string;
    /**
     * Supported DLT protocols.
     * @type {string}
     * @memberof Token
     */
    'chainType': TokenChainTypeEnum;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof Token
     */
    'address': string;
    /**
     * The name of the token.
     * @type {string}
     * @memberof Token
     */
    'name'?: string;
    /**
     * The symbol of the token.
     * @type {string}
     * @memberof Token
     */
    'symbol': string;
    /**
     * How many decimals the token supports.
     * @type {number}
     * @memberof Token
     */
    'decimals': number;
    /**
     * The logo of a token, chain, dex etc.
     * @type {string}
     * @memberof Token
     */
    'logoURI'?: string;
    /**
     * List of tags identifiers providing additional context or categorization.
     * @type {Array<string>}
     * @memberof Token
     */
    'tags'?: Array<string>;
    /**
     * The current price of the token in USD.
     * @type {string}
     * @memberof Token
     */
    'priceUSD'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromTokenExtensions}
     * @memberof Token
     */
    'extensions'?: GetRoutes200ResponseRoutesInnerFromTokenExtensions;
}

export const TokenChainTypeEnum = {
    HyperledgerFabric: 'HyperledgerFabric',
    HyperledgerBesu: 'HyperledgerBesu'
} as const;

export type TokenChainTypeEnum = typeof TokenChainTypeEnum[keyof typeof TokenChainTypeEnum];

/**
 * The type of token.
 * @export
 * @enum {string}
 */

export const TokenType = {
    Erc20: 'ERC20',
    Erc721: 'ERC721',
    Erc1155: 'ERC1155',
    NonstandardFungible: 'NONSTANDARD_FUNGIBLE',
    NonstandardNonfungible: 'NONSTANDARD_NONFUNGIBLE'
} as const;

export type TokenType = typeof TokenType[keyof typeof TokenType];


/**
 * Response schema for a transaction request. Includes the session ID and the current status of the transaction.
 * @export
 * @interface Transact200Response
 */
export interface Transact200Response {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof Transact200Response
     */
    'sessionID': string;
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof Transact200Response
     */
    'statusResponse': Transact200ResponseStatusResponse;
}
/**
 * Provides the current status of the SATP session including detailed information on the progress, such as substatus, stage, and step, along with the session start time and chain information.
 * @export
 * @interface Transact200ResponseStatusResponse
 */
export interface Transact200ResponseStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof Transact200ResponseStatusResponse
     */
    'status': Transact200ResponseStatusResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Transact200ResponseStatusResponse
     */
    'substatus': Transact200ResponseStatusResponseSubstatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Transact200ResponseStatusResponse
     */
    'stage': Transact200ResponseStatusResponseStageEnum;
    /**
     * 
     * @type {string}
     * @memberof Transact200ResponseStatusResponse
     */
    'step': Transact200ResponseStatusResponseStepEnum;
    /**
     * 
     * @type {string}
     * @memberof Transact200ResponseStatusResponse
     */
    'startTime': string;
    /**
     * 
     * @type {Transact200ResponseStatusResponseOriginNetwork}
     * @memberof Transact200ResponseStatusResponse
     */
    'originNetwork': Transact200ResponseStatusResponseOriginNetwork;
    /**
     * 
     * @type {Transact200ResponseStatusResponseDestinationNetwork}
     * @memberof Transact200ResponseStatusResponse
     */
    'destinationNetwork': Transact200ResponseStatusResponseDestinationNetwork;
}

export const Transact200ResponseStatusResponseStatusEnum = {
    NotFound: 'NOT_FOUND',
    Invalid: 'INVALID',
    Pending: 'PENDING',
    Done: 'DONE',
    Failed: 'FAILED'
} as const;

export type Transact200ResponseStatusResponseStatusEnum = typeof Transact200ResponseStatusResponseStatusEnum[keyof typeof Transact200ResponseStatusResponseStatusEnum];
export const Transact200ResponseStatusResponseSubstatusEnum = {
    WaitSourceConfirmations: 'WAIT_SOURCE_CONFIRMATIONS',
    WaitDestinationTransaction: 'WAIT_DESTINATION_TRANSACTION',
    BridgeNotAvailable: 'BRIDGE_NOT_AVAILABLE',
    ChainNotAvailable: 'CHAIN_NOT_AVAILABLE',
    RefundInProgress: 'REFUND_IN_PROGRESS',
    UnknownError: 'UNKNOWN_ERROR',
    Completed: 'COMPLETED',
    Partial: 'PARTIAL',
    Refunded: 'REFUNDED',
    NotProcessableRefundNeeded: 'NOT_PROCESSABLE_REFUND_NEEDED',
    Recovering: 'RECOVERING',
    Recovered: 'RECOVERED',
    RecoveryFailed: 'RECOVERY_FAILED',
    Rejected: 'REJECTED'
} as const;

export type Transact200ResponseStatusResponseSubstatusEnum = typeof Transact200ResponseStatusResponseSubstatusEnum[keyof typeof Transact200ResponseStatusResponseSubstatusEnum];
export const Transact200ResponseStatusResponseStageEnum = {
    _0: 'STAGE_0',
    _1: 'STAGE_1',
    _2: 'STAGE_2',
    _3: 'STAGE_3'
} as const;

export type Transact200ResponseStatusResponseStageEnum = typeof Transact200ResponseStatusResponseStageEnum[keyof typeof Transact200ResponseStatusResponseStageEnum];
export const Transact200ResponseStatusResponseStepEnum = {
    TransferInitializationClaims: 'transfer-initialization-claims',
    ConveyanceOfNetworkCapabilitiesAndParameters: 'conveyance-of-network-capabilities-and-parameters',
    TransferProposalMessage: 'transfer-proposal-message',
    TransferProposalReceiptMessage: 'transfer-proposal-receipt-message',
    TransferProposalRejectAndConditionalRejectMessage: 'transfer-proposal-reject-and-conditional-reject-message',
    TransferCommenceMessage: 'transfer-commence-message',
    CommenceResponseMessage: 'commence-response-message',
    LockAssertionMessage: 'lock-assertion-message',
    LockAssertionReceiptMessage: 'lock-assertion-receipt-message',
    CommitPreparationMessage: 'commit-preparation-message',
    CommitReadyMessage: 'commit-ready-message',
    CommitFinalAssertionMessage: 'commit-final-assertion-message',
    CommitFinalAcknowledgementReceiptMessage: 'commit-final-acknowledgement-receipt-message',
    TransferCompleteMessage: 'transfer-complete-message',
    RollbackTransferInitializationClaims: 'rollback-transfer-initialization-claims',
    RollbackConveyanceOfNetworkCapabilitiesAndParameters: 'rollback-conveyance-of-network-capabilities-and-parameters',
    RollbackTransferProposalMessage: 'rollback-transfer-proposal-message',
    RollbackTransferProposalReceiptMessage: 'rollback-transfer-proposal-receipt-message',
    RollbackTransferProposalRejectAndConditionalRejectMessage: 'rollback-transfer-proposal-reject-and-conditional-reject-message',
    RollbackTransferCommenceMessage: 'rollback-transfer-commence-message',
    RollbackCommenceResponseMessage: 'rollback-commence-response-message',
    RollbackLockAssertionMessage: 'rollback-lock-assertion-message',
    RollbackLockAssertionReceiptMessage: 'rollback-lock-assertion-receipt-message',
    RollbackCommitPreparationMessage: 'rollback-commit-preparation-message',
    RollbackCommitReadyMessage: 'rollback-commit-ready-message',
    RollbackCommitFinalAssertionMessage: 'rollback-commit-final-assertion-message',
    RollbackCommitFinalAcknowledgementReceiptMessage: 'rollback-commit-final-acknowledgement-receipt-message',
    RollbackTransferCompleteMessage: 'rollback-transfer-complete-message'
} as const;

export type Transact200ResponseStatusResponseStepEnum = typeof Transact200ResponseStatusResponseStepEnum[keyof typeof Transact200ResponseStatusResponseStepEnum];

/**
 * 
 * @export
 * @interface Transact200ResponseStatusResponseDestinationNetwork
 */
export interface Transact200ResponseStatusResponseDestinationNetwork {
    /**
     * The unique identifier of the origin network.
     * @type {string}
     * @memberof Transact200ResponseStatusResponseDestinationNetwork
     */
    'id'?: string;
    /**
     * 
     * @type {any}
     * @memberof Transact200ResponseStatusResponseDestinationNetwork
     */
    'dltProtocol'?: any;
    /**
     * 
     * @type {any}
     * @memberof Transact200ResponseStatusResponseDestinationNetwork
     */
    'dltSubnetworkID'?: any;
}
/**
 * 
 * @export
 * @interface Transact200ResponseStatusResponseOriginNetwork
 */
export interface Transact200ResponseStatusResponseOriginNetwork {
    /**
     * The unique identifier of the origin network.
     * @type {string}
     * @memberof Transact200ResponseStatusResponseOriginNetwork
     */
    'id'?: string;
    /**
     * 
     * @type {any}
     * @memberof Transact200ResponseStatusResponseOriginNetwork
     */
    'dltProtocol'?: any;
    /**
     * 
     * @type {any}
     * @memberof Transact200ResponseStatusResponseOriginNetwork
     */
    'dltSubnetworkID'?: any;
}
/**
 * An Error
 * @export
 * @interface TransactDefaultResponse
 */
export interface TransactDefaultResponse {
    /**
     * HTTP error type
     * @type {string}
     * @memberof TransactDefaultResponse
     */
    'type': string;
    /**
     * Numeric error code
     * @type {number}
     * @memberof TransactDefaultResponse
     */
    'code': number;
    /**
     * HTTP status of the error
     * @type {number}
     * @memberof TransactDefaultResponse
     */
    'status': number;
    /**
     * Long error description
     * @type {string}
     * @memberof TransactDefaultResponse
     */
    'message': string;
    /**
     * Timestamp of the error
     * @type {string}
     * @memberof TransactDefaultResponse
     */
    'timestamp': string;
}
/**
 * Request schema for initiating a transaction. Includes details such as the transaction context, mode (data or transfer), payload, and information about the source and destination DLT networks.
 * @export
 * @interface TransactRequest
 */
export interface TransactRequest {
    /**
     * The unique identifier of the task.
     * @type {string}
     * @memberof TransactRequest
     */
    'contextID': string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'payload'?: string;
    /**
     * 
     * @type {TransactRequestSourceAsset}
     * @memberof TransactRequest
     */
    'sourceAsset': TransactRequestSourceAsset;
    /**
     * 
     * @type {TransactRequestSourceAsset}
     * @memberof TransactRequest
     */
    'receiverAsset': TransactRequestSourceAsset;
}
/**
 * An asset
 * @export
 * @interface TransactRequestSourceAsset
 */
export interface TransactRequestSourceAsset {
    /**
     * 
     * @type {string}
     * @memberof TransactRequestSourceAsset
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequestSourceAsset
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequestSourceAsset
     */
    'contractName': string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequestSourceAsset
     */
    'contractAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequestSourceAsset
     */
    'mspId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequestSourceAsset
     */
    'channelName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequestSourceAsset
     */
    'amount'?: string;
    /**
     * 
     * @type {TransactRequestSourceAssetNetworkId}
     * @memberof TransactRequestSourceAsset
     */
    'networkId': TransactRequestSourceAssetNetworkId;
    /**
     * The type of token.
     * @type {string}
     * @memberof TransactRequestSourceAsset
     */
    'tokenType': TransactRequestSourceAssetTokenTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactRequestSourceAsset
     */
    'referenceId': string;
}

export const TransactRequestSourceAssetTokenTypeEnum = {
    Erc20: 'ERC20',
    Erc721: 'ERC721',
    Erc1155: 'ERC1155',
    NonstandardFungible: 'NONSTANDARD_FUNGIBLE',
    NonstandardNonfungible: 'NONSTANDARD_NONFUNGIBLE'
} as const;

export type TransactRequestSourceAssetTokenTypeEnum = typeof TransactRequestSourceAssetTokenTypeEnum[keyof typeof TransactRequestSourceAssetTokenTypeEnum];

/**
 * The network of the DLT being interacted with.
 * @export
 * @interface TransactRequestSourceAssetNetworkId
 */
export interface TransactRequestSourceAssetNetworkId {
    /**
     * The network of the DLT being interacted with.
     * @type {string}
     * @memberof TransactRequestSourceAssetNetworkId
     */
    'id': string;
    /**
     * Enumerates the different ledger vendors and their major versions encoded within the name of the LedgerType. For example \"BESU_1X\" involves all of the [1.0.0;2.0.0) where 1.0.0 is included and anything up until, but not 2.0.0. See: https://stackoverflow.com/a/4396303/698470 for further explanation.
     * @type {string}
     * @memberof TransactRequestSourceAssetNetworkId
     */
    'ledgerType': TransactRequestSourceAssetNetworkIdLedgerTypeEnum;
}

export const TransactRequestSourceAssetNetworkIdLedgerTypeEnum = {
    Besu1X: 'BESU_1X',
    Besu2X: 'BESU_2X',
    Burrow0X: 'BURROW_0X',
    Corda4X: 'CORDA_4X',
    Ethereum: 'ETHEREUM',
    Fabric2: 'FABRIC_2',
    Sawtooth1X: 'SAWTOOTH_1X'
} as const;

export type TransactRequestSourceAssetNetworkIdLedgerTypeEnum = typeof TransactRequestSourceAssetNetworkIdLedgerTypeEnum[keyof typeof TransactRequestSourceAssetNetworkIdLedgerTypeEnum];

/**
 * Response schema for a transaction request. Includes the session ID and the current status of the transaction.
 * @export
 * @interface TransactResponse
 */
export interface TransactResponse {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof TransactResponse
     */
    'sessionID': string;
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof TransactResponse
     */
    'statusResponse': Transact200ResponseStatusResponse;
}
/**
 * Response schema for unregistering a data transfer task. Includes the task ID and status of the unregistration.
 * @export
 * @interface UnregisterOracleTask200Response
 */
export interface UnregisterOracleTask200Response {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof UnregisterOracleTask200Response
     */
    'taskID'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnregisterOracleTask200Response
     */
    'status'?: UnregisterOracleTask200ResponseStatusEnum;
}

export const UnregisterOracleTask200ResponseStatusEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type UnregisterOracleTask200ResponseStatusEnum = typeof UnregisterOracleTask200ResponseStatusEnum[keyof typeof UnregisterOracleTask200ResponseStatusEnum];


/**
 * AddCounterpartyApi - axios parameter creator
 * @export
 */
export const AddCounterpartyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a counterparty to the Gateway
         * @summary Add counterparty
         * @param {AddCounterpartyRequest} addCounterpartyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCounterparty: async (addCounterpartyRequest: AddCounterpartyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addCounterpartyRequest' is not null or undefined
            assertParamExists('addCounterparty', 'addCounterpartyRequest', addCounterpartyRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/add-counterparty-gateway`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCounterpartyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddCounterpartyApi - functional programming interface
 * @export
 */
export const AddCounterpartyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddCounterpartyApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a counterparty to the Gateway
         * @summary Add counterparty
         * @param {AddCounterpartyRequest} addCounterpartyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCounterparty(addCounterpartyRequest: AddCounterpartyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddCounterparty200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCounterparty(addCounterpartyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddCounterpartyApi - factory interface
 * @export
 */
export const AddCounterpartyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddCounterpartyApiFp(configuration)
    return {
        /**
         * Add a counterparty to the Gateway
         * @summary Add counterparty
         * @param {AddCounterpartyRequest} addCounterpartyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCounterparty(addCounterpartyRequest: AddCounterpartyRequest, options?: any): AxiosPromise<AddCounterparty200Response> {
            return localVarFp.addCounterparty(addCounterpartyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddCounterpartyApi - object-oriented interface
 * @export
 * @class AddCounterpartyApi
 * @extends {BaseAPI}
 */
export class AddCounterpartyApi extends BaseAPI {
    /**
     * Add a counterparty to the Gateway
     * @summary Add counterparty
     * @param {AddCounterpartyRequest} addCounterpartyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddCounterpartyApi
     */
    public addCounterparty(addCounterpartyRequest: AddCounterpartyRequest, options?: AxiosRequestConfig) {
        return AddCounterpartyApiFp(this.configuration).addCounterparty(addCounterpartyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attempts to continue a previously paused transaction intent, resuming its execution.
         * @summary Continue a paused transaction session
         * @param {ContinueRequest} continueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _continue: async (continueRequest: ContinueRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'continueRequest' is not null or undefined
            assertParamExists('_continue', 'continueRequest', continueRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/continue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(continueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Responds if SATP Hermes is on
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the all SATP session IDs
         * @summary Get SATP session ids
         * @param {object} [sessionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionIds: async (sessionsRequest?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/get-sessions-ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionsRequest !== undefined) {
                localVarQueryParameter['SessionsRequest'] = sessionsRequest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the status of a SATP session
         * @summary Get SATP current session data
         * @param {string} sessionID Unique identifier for the session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (sessionID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionID' is not null or undefined
            assertParamExists('getStatus', 'sessionID', sessionID)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionID !== undefined) {
                localVarQueryParameter['SessionID'] = sessionID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to pause a previously submitted transaction intent, temporarily halting its execution.
         * @summary Pause a transaction session
         * @param {PauseRequest} pauseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause: async (pauseRequest: PauseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pauseRequest' is not null or undefined
            assertParamExists('pause', 'pauseRequest', pauseRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/pause`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pauseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Audits transactions based on provided filters such as start and end dates. Optionally includes proofs generated from each gateway transaction.
         * @summary Audit transactions
         * @param {number} [startTimestamp] The start timestamp for the audit period.
         * @param {number} [endTimestamp] The end timestamp for the audit period.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performAudit: async (startTimestamp?: number, endTimestamp?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/audit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startTimestamp !== undefined) {
                localVarQueryParameter['startTimestamp'] = startTimestamp;
            }

            if (endTimestamp !== undefined) {
                localVarQueryParameter['endTimestamp'] = endTimestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Attempts to continue a previously paused transaction intent, resuming its execution.
         * @summary Continue a paused transaction session
         * @param {ContinueRequest} continueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _continue(continueRequest: ContinueRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Continue200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._continue(continueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Responds if SATP Hermes is on
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealthCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHealthCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the all SATP session IDs
         * @summary Get SATP session ids
         * @param {object} [sessionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionIds(sessionsRequest?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionIds(sessionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the status of a SATP session
         * @summary Get SATP current session data
         * @param {string} sessionID Unique identifier for the session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(sessionID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transact200ResponseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(sessionID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attempts to pause a previously submitted transaction intent, temporarily halting its execution.
         * @summary Pause a transaction session
         * @param {PauseRequest} pauseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pause(pauseRequest: PauseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pause200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pause(pauseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Audits transactions based on provided filters such as start and end dates. Optionally includes proofs generated from each gateway transaction.
         * @summary Audit transactions
         * @param {number} [startTimestamp] The start timestamp for the audit period.
         * @param {number} [endTimestamp] The end timestamp for the audit period.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async performAudit(startTimestamp?: number, endTimestamp?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PerformAudit200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.performAudit(startTimestamp, endTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Attempts to continue a previously paused transaction intent, resuming its execution.
         * @summary Continue a paused transaction session
         * @param {ContinueRequest} continueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _continue(continueRequest: ContinueRequest, options?: any): AxiosPromise<Continue200Response> {
            return localVarFp._continue(continueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds if SATP Hermes is on
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck(options?: any): AxiosPromise<GetHealthCheck200Response> {
            return localVarFp.getHealthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the all SATP session IDs
         * @summary Get SATP session ids
         * @param {object} [sessionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionIds(sessionsRequest?: object, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getSessionIds(sessionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the status of a SATP session
         * @summary Get SATP current session data
         * @param {string} sessionID Unique identifier for the session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(sessionID: string, options?: any): AxiosPromise<Transact200ResponseStatusResponse> {
            return localVarFp.getStatus(sessionID, options).then((request) => request(axios, basePath));
        },
        /**
         * Attempts to pause a previously submitted transaction intent, temporarily halting its execution.
         * @summary Pause a transaction session
         * @param {PauseRequest} pauseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause(pauseRequest: PauseRequest, options?: any): AxiosPromise<Pause200Response> {
            return localVarFp.pause(pauseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Audits transactions based on provided filters such as start and end dates. Optionally includes proofs generated from each gateway transaction.
         * @summary Audit transactions
         * @param {number} [startTimestamp] The start timestamp for the audit period.
         * @param {number} [endTimestamp] The end timestamp for the audit period.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performAudit(startTimestamp?: number, endTimestamp?: number, options?: any): AxiosPromise<PerformAudit200Response> {
            return localVarFp.performAudit(startTimestamp, endTimestamp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Attempts to continue a previously paused transaction intent, resuming its execution.
     * @summary Continue a paused transaction session
     * @param {ContinueRequest} continueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public _continue(continueRequest: ContinueRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration)._continue(continueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Responds if SATP Hermes is on
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getHealthCheck(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the all SATP session IDs
     * @summary Get SATP session ids
     * @param {object} [sessionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getSessionIds(sessionsRequest?: object, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getSessionIds(sessionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the status of a SATP session
     * @summary Get SATP current session data
     * @param {string} sessionID Unique identifier for the session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getStatus(sessionID: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getStatus(sessionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attempts to pause a previously submitted transaction intent, temporarily halting its execution.
     * @summary Pause a transaction session
     * @param {PauseRequest} pauseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public pause(pauseRequest: PauseRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).pause(pauseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Audits transactions based on provided filters such as start and end dates. Optionally includes proofs generated from each gateway transaction.
     * @summary Audit transactions
     * @param {number} [startTimestamp] The start timestamp for the audit period.
     * @param {number} [endTimestamp] The end timestamp for the audit period.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public performAudit(startTimestamp?: number, endTimestamp?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).performAudit(startTimestamp, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GetApproveAddressApi - axios parameter creator
 * @export
 */
export const GetApproveAddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get approve address for the token transfer
         * @summary Get approve address
         * @param {TransactRequestSourceAssetNetworkId} networkId 
         * @param {'ERC20' | 'ERC721' | 'ERC1155' | 'NONSTANDARD_FUNGIBLE' | 'NONSTANDARD_NONFUNGIBLE'} tokenType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApproveAddress: async (networkId: TransactRequestSourceAssetNetworkId, tokenType: 'ERC20' | 'ERC721' | 'ERC1155' | 'NONSTANDARD_FUNGIBLE' | 'NONSTANDARD_NONFUNGIBLE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getApproveAddress', 'networkId', networkId)
            // verify required parameter 'tokenType' is not null or undefined
            assertParamExists('getApproveAddress', 'tokenType', tokenType)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/approve-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (networkId !== undefined) {
                localVarQueryParameter['networkId'] = networkId;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['tokenType'] = tokenType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetApproveAddressApi - functional programming interface
 * @export
 */
export const GetApproveAddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetApproveAddressApiAxiosParamCreator(configuration)
    return {
        /**
         * Get approve address for the token transfer
         * @summary Get approve address
         * @param {TransactRequestSourceAssetNetworkId} networkId 
         * @param {'ERC20' | 'ERC721' | 'ERC1155' | 'NONSTANDARD_FUNGIBLE' | 'NONSTANDARD_NONFUNGIBLE'} tokenType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApproveAddress(networkId: TransactRequestSourceAssetNetworkId, tokenType: 'ERC20' | 'ERC721' | 'ERC1155' | 'NONSTANDARD_FUNGIBLE' | 'NONSTANDARD_NONFUNGIBLE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApproveAddress200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApproveAddress(networkId, tokenType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GetApproveAddressApi - factory interface
 * @export
 */
export const GetApproveAddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetApproveAddressApiFp(configuration)
    return {
        /**
         * Get approve address for the token transfer
         * @summary Get approve address
         * @param {TransactRequestSourceAssetNetworkId} networkId 
         * @param {'ERC20' | 'ERC721' | 'ERC1155' | 'NONSTANDARD_FUNGIBLE' | 'NONSTANDARD_NONFUNGIBLE'} tokenType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApproveAddress(networkId: TransactRequestSourceAssetNetworkId, tokenType: 'ERC20' | 'ERC721' | 'ERC1155' | 'NONSTANDARD_FUNGIBLE' | 'NONSTANDARD_NONFUNGIBLE', options?: any): AxiosPromise<GetApproveAddress200Response> {
            return localVarFp.getApproveAddress(networkId, tokenType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetApproveAddressApi - object-oriented interface
 * @export
 * @class GetApproveAddressApi
 * @extends {BaseAPI}
 */
export class GetApproveAddressApi extends BaseAPI {
    /**
     * Get approve address for the token transfer
     * @summary Get approve address
     * @param {TransactRequestSourceAssetNetworkId} networkId 
     * @param {'ERC20' | 'ERC721' | 'ERC1155' | 'NONSTANDARD_FUNGIBLE' | 'NONSTANDARD_NONFUNGIBLE'} tokenType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetApproveAddressApi
     */
    public getApproveAddress(networkId: TransactRequestSourceAssetNetworkId, tokenType: 'ERC20' | 'ERC721' | 'ERC1155' | 'NONSTANDARD_FUNGIBLE' | 'NONSTANDARD_NONFUNGIBLE', options?: AxiosRequestConfig) {
        return GetApproveAddressApiFp(this.configuration).getApproveAddress(networkId, tokenType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OracleApi - axios parameter creator
 * @export
 */
export const OracleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Execute a registered data transfer task from source to target blockchain
         * @summary Execute data transfer task
         * @param {ExecuteOracleTaskRequest} executeOracleTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeOracleTask: async (executeOracleTaskRequest: ExecuteOracleTaskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'executeOracleTaskRequest' is not null or undefined
            assertParamExists('executeOracleTask', 'executeOracleTaskRequest', executeOracleTaskRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/oracle/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeOracleTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the status of an oracle task
         * @summary Get oracle task status
         * @param {string} taskID Unique identifier for the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOracleTaskStatus: async (taskID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskID' is not null or undefined
            assertParamExists('getOracleTaskStatus', 'taskID', taskID)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/oracle/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskID !== undefined) {
                localVarQueryParameter['taskID'] = taskID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register data transfer from source to target blockchain
         * @summary Register data transfer task
         * @param {RegisterOracleTaskRequest} registerOracleTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOracleTask: async (registerOracleTaskRequest: RegisterOracleTaskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerOracleTaskRequest' is not null or undefined
            assertParamExists('registerOracleTask', 'registerOracleTaskRequest', registerOracleTaskRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/oracle/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerOracleTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unregister data transfer task from source to target blockchain
         * @summary Unregister data transfer task
         * @param {string} taskID Unique identifier for the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterOracleTask: async (taskID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskID' is not null or undefined
            assertParamExists('unregisterOracleTask', 'taskID', taskID)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/oracle/unregister`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskID !== undefined) {
                localVarQueryParameter['taskID'] = taskID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OracleApi - functional programming interface
 * @export
 */
export const OracleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OracleApiAxiosParamCreator(configuration)
    return {
        /**
         * Execute a registered data transfer task from source to target blockchain
         * @summary Execute data transfer task
         * @param {ExecuteOracleTaskRequest} executeOracleTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeOracleTask(executeOracleTaskRequest: ExecuteOracleTaskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteOracleTask200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeOracleTask(executeOracleTaskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the status of an oracle task
         * @summary Get oracle task status
         * @param {string} taskID Unique identifier for the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOracleTaskStatus(taskID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOracleTaskStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOracleTaskStatus(taskID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register data transfer from source to target blockchain
         * @summary Register data transfer task
         * @param {RegisterOracleTaskRequest} registerOracleTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerOracleTask(registerOracleTaskRequest: RegisterOracleTaskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterOracleTask200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerOracleTask(registerOracleTaskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unregister data transfer task from source to target blockchain
         * @summary Unregister data transfer task
         * @param {string} taskID Unique identifier for the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unregisterOracleTask(taskID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnregisterOracleTask200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterOracleTask(taskID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OracleApi - factory interface
 * @export
 */
export const OracleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OracleApiFp(configuration)
    return {
        /**
         * Execute a registered data transfer task from source to target blockchain
         * @summary Execute data transfer task
         * @param {ExecuteOracleTaskRequest} executeOracleTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeOracleTask(executeOracleTaskRequest: ExecuteOracleTaskRequest, options?: any): AxiosPromise<ExecuteOracleTask200Response> {
            return localVarFp.executeOracleTask(executeOracleTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the status of an oracle task
         * @summary Get oracle task status
         * @param {string} taskID Unique identifier for the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOracleTaskStatus(taskID: string, options?: any): AxiosPromise<GetOracleTaskStatus200Response> {
            return localVarFp.getOracleTaskStatus(taskID, options).then((request) => request(axios, basePath));
        },
        /**
         * Register data transfer from source to target blockchain
         * @summary Register data transfer task
         * @param {RegisterOracleTaskRequest} registerOracleTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOracleTask(registerOracleTaskRequest: RegisterOracleTaskRequest, options?: any): AxiosPromise<RegisterOracleTask200Response> {
            return localVarFp.registerOracleTask(registerOracleTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Unregister data transfer task from source to target blockchain
         * @summary Unregister data transfer task
         * @param {string} taskID Unique identifier for the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterOracleTask(taskID: string, options?: any): AxiosPromise<UnregisterOracleTask200Response> {
            return localVarFp.unregisterOracleTask(taskID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OracleApi - object-oriented interface
 * @export
 * @class OracleApi
 * @extends {BaseAPI}
 */
export class OracleApi extends BaseAPI {
    /**
     * Execute a registered data transfer task from source to target blockchain
     * @summary Execute data transfer task
     * @param {ExecuteOracleTaskRequest} executeOracleTaskRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OracleApi
     */
    public executeOracleTask(executeOracleTaskRequest: ExecuteOracleTaskRequest, options?: AxiosRequestConfig) {
        return OracleApiFp(this.configuration).executeOracleTask(executeOracleTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the status of an oracle task
     * @summary Get oracle task status
     * @param {string} taskID Unique identifier for the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OracleApi
     */
    public getOracleTaskStatus(taskID: string, options?: AxiosRequestConfig) {
        return OracleApiFp(this.configuration).getOracleTaskStatus(taskID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register data transfer from source to target blockchain
     * @summary Register data transfer task
     * @param {RegisterOracleTaskRequest} registerOracleTaskRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OracleApi
     */
    public registerOracleTask(registerOracleTaskRequest: RegisterOracleTaskRequest, options?: AxiosRequestConfig) {
        return OracleApiFp(this.configuration).registerOracleTask(registerOracleTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unregister data transfer task from source to target blockchain
     * @summary Unregister data transfer task
     * @param {string} taskID Unique identifier for the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OracleApi
     */
    public unregisterOracleTask(taskID: string, options?: AxiosRequestConfig) {
        return OracleApiFp(this.configuration).unregisterOracleTask(taskID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attempts to cancel a previously submitted transaction intent using its session ID.
         * @summary Cancel a transaction session
         * @param {CancelRequest} cancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (cancelRequest: CancelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelRequest' is not null or undefined
            assertParamExists('cancel', 'cancelRequest', cancelRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves metadata about each supported blockchain networks, chains, and other systems.
         * @summary Get supported integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of possible routes for swapping one asset for another across multiple exchanges
         * @summary Get a list of routes for a gateway-to-gateway asset transfer
         * @param {TransactRequestSourceAssetNetworkId} fromNetworkID The sending DLT Network.
         * @param {string} fromAmount The amount that should be sent including all decimals.
         * @param {string} fromToken The token that should be transferred. Can be the address or the symbol.
         * @param {TransactRequestSourceAssetNetworkId} toDLTNetwork The receiving DLT Network.
         * @param {string} toToken The token that should be transferred to. Can be the address or the symbol.
         * @param {string} fromAddress The sending wallet address.
         * @param {string} toAddress The receiving wallet address. If none is provided, the fromAddress will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes: async (fromNetworkID: TransactRequestSourceAssetNetworkId, fromAmount: string, fromToken: string, toDLTNetwork: TransactRequestSourceAssetNetworkId, toToken: string, fromAddress: string, toAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromNetworkID' is not null or undefined
            assertParamExists('getRoutes', 'fromNetworkID', fromNetworkID)
            // verify required parameter 'fromAmount' is not null or undefined
            assertParamExists('getRoutes', 'fromAmount', fromAmount)
            // verify required parameter 'fromToken' is not null or undefined
            assertParamExists('getRoutes', 'fromToken', fromToken)
            // verify required parameter 'toDLTNetwork' is not null or undefined
            assertParamExists('getRoutes', 'toDLTNetwork', toDLTNetwork)
            // verify required parameter 'toToken' is not null or undefined
            assertParamExists('getRoutes', 'toToken', toToken)
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('getRoutes', 'fromAddress', fromAddress)
            // verify required parameter 'toAddress' is not null or undefined
            assertParamExists('getRoutes', 'toAddress', toAddress)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/routes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fromNetworkID !== undefined) {
                localVarQueryParameter['fromNetworkID'] = fromNetworkID;
            }

            if (fromAmount !== undefined) {
                localVarQueryParameter['fromAmount'] = fromAmount;
            }

            if (fromToken !== undefined) {
                localVarQueryParameter['fromToken'] = fromToken;
            }

            if (toDLTNetwork !== undefined) {
                localVarQueryParameter['toDLTNetwork'] = toDLTNetwork;
            }

            if (toToken !== undefined) {
                localVarQueryParameter['toToken'] = toToken;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }

            if (toAddress !== undefined) {
                localVarQueryParameter['toAddress'] = toAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {TransactRequest} transactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transact: async (transactRequest: TransactRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactRequest' is not null or undefined
            assertParamExists('transact', 'transactRequest', transactRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/transact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Attempts to cancel a previously submitted transaction intent using its session ID.
         * @summary Cancel a transaction session
         * @param {CancelRequest} cancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(cancelRequest: CancelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cancel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(cancelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves metadata about each supported blockchain networks, chains, and other systems.
         * @summary Get supported integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIntegrations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of possible routes for swapping one asset for another across multiple exchanges
         * @summary Get a list of routes for a gateway-to-gateway asset transfer
         * @param {TransactRequestSourceAssetNetworkId} fromNetworkID The sending DLT Network.
         * @param {string} fromAmount The amount that should be sent including all decimals.
         * @param {string} fromToken The token that should be transferred. Can be the address or the symbol.
         * @param {TransactRequestSourceAssetNetworkId} toDLTNetwork The receiving DLT Network.
         * @param {string} toToken The token that should be transferred to. Can be the address or the symbol.
         * @param {string} fromAddress The sending wallet address.
         * @param {string} toAddress The receiving wallet address. If none is provided, the fromAddress will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutes(fromNetworkID: TransactRequestSourceAssetNetworkId, fromAmount: string, fromToken: string, toDLTNetwork: TransactRequestSourceAssetNetworkId, toToken: string, fromAddress: string, toAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRoutes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutes(fromNetworkID, fromAmount, fromToken, toDLTNetwork, toToken, fromAddress, toAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {TransactRequest} transactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transact(transactRequest: TransactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transact(transactRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * Attempts to cancel a previously submitted transaction intent using its session ID.
         * @summary Cancel a transaction session
         * @param {CancelRequest} cancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(cancelRequest: CancelRequest, options?: any): AxiosPromise<Cancel200Response> {
            return localVarFp.cancel(cancelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves metadata about each supported blockchain networks, chains, and other systems.
         * @summary Get supported integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations(options?: any): AxiosPromise<GetIntegrations200Response> {
            return localVarFp.getIntegrations(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of possible routes for swapping one asset for another across multiple exchanges
         * @summary Get a list of routes for a gateway-to-gateway asset transfer
         * @param {TransactRequestSourceAssetNetworkId} fromNetworkID The sending DLT Network.
         * @param {string} fromAmount The amount that should be sent including all decimals.
         * @param {string} fromToken The token that should be transferred. Can be the address or the symbol.
         * @param {TransactRequestSourceAssetNetworkId} toDLTNetwork The receiving DLT Network.
         * @param {string} toToken The token that should be transferred to. Can be the address or the symbol.
         * @param {string} fromAddress The sending wallet address.
         * @param {string} toAddress The receiving wallet address. If none is provided, the fromAddress will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes(fromNetworkID: TransactRequestSourceAssetNetworkId, fromAmount: string, fromToken: string, toDLTNetwork: TransactRequestSourceAssetNetworkId, toToken: string, fromAddress: string, toAddress: string, options?: any): AxiosPromise<GetRoutes200Response> {
            return localVarFp.getRoutes(fromNetworkID, fromAmount, fromToken, toDLTNetwork, toToken, fromAddress, toAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {TransactRequest} transactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transact(transactRequest: TransactRequest, options?: any): AxiosPromise<Transact200Response> {
            return localVarFp.transact(transactRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * Attempts to cancel a previously submitted transaction intent using its session ID.
     * @summary Cancel a transaction session
     * @param {CancelRequest} cancelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public cancel(cancelRequest: CancelRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).cancel(cancelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves metadata about each supported blockchain networks, chains, and other systems.
     * @summary Get supported integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public getIntegrations(options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).getIntegrations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of possible routes for swapping one asset for another across multiple exchanges
     * @summary Get a list of routes for a gateway-to-gateway asset transfer
     * @param {TransactRequestSourceAssetNetworkId} fromNetworkID The sending DLT Network.
     * @param {string} fromAmount The amount that should be sent including all decimals.
     * @param {string} fromToken The token that should be transferred. Can be the address or the symbol.
     * @param {TransactRequestSourceAssetNetworkId} toDLTNetwork The receiving DLT Network.
     * @param {string} toToken The token that should be transferred to. Can be the address or the symbol.
     * @param {string} fromAddress The sending wallet address.
     * @param {string} toAddress The receiving wallet address. If none is provided, the fromAddress will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public getRoutes(fromNetworkID: TransactRequestSourceAssetNetworkId, fromAmount: string, fromToken: string, toDLTNetwork: TransactRequestSourceAssetNetworkId, toToken: string, fromAddress: string, toAddress: string, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).getRoutes(fromNetworkID, fromAmount, fromToken, toDLTNetwork, toToken, fromAddress, toAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows users to queue intents for transactions based on specified parameters.
     * @summary Submit a transaction intent
     * @param {TransactRequest} transactRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transact(transactRequest: TransactRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transact(transactRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


