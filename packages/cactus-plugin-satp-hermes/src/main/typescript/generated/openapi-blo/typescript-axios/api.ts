/* tslint:disable */
/* eslint-disable */
/**
 * SATP Gateway Client (Business Logic Orchestrator)
 * SATP is a protocol operating between two gateways that conducts the transfer of a digital asset from one gateway to another. The protocol establishes a secure channel between the endpoints and implements a 2-phase commit to ensure the properties of transfer atomicity, consistency, isolation and durability.  This API defines the gateway client facing API (business logic orchestrator, or BLO), which is named API-Type  in the SATP-Core specification.  **Additional Resources**: - [Proposed SATP Charter](https://datatracker.ietf.org/doc/charter-ietf-satp/) - [SATP Core draft](https://datatracker.ietf.org/doc/draft-ietf-satp-core) - [SATP Crash Recovery draft](https://datatracker.ietf.org/doc/draft-belchior-satp-gateway-recovery/) - [SATP Architecture draft](https://datatracker.ietf.org/doc/draft-ietf-satp-architecture/) - [SATP Use-Cases draft](https://datatracker.ietf.org/doc/draft-ramakrishna-sat-use-cases/) - [SATP Data sharing draft](https://datatracker.ietf.org/doc/draft-ramakrishna-satp-data-sharing) - [SATP View Addresses draft](https://datatracker.ietf.org/doc/draft-ramakrishna-satp-views-addresses)
 *
 * The version of the OpenAPI document: 0.0.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * An Error
 * @export
 * @interface APIError
 */
export interface APIError {
    /**
     * HTTP error type
     * @type {string}
     * @memberof APIError
     */
    'type': string;
    /**
     * Numeric error code
     * @type {number}
     * @memberof APIError
     */
    'code': number;
    /**
     * HTTP status of the error
     * @type {number}
     * @memberof APIError
     */
    'status': number;
    /**
     * Long error description
     * @type {string}
     * @memberof APIError
     */
    'message': string;
    /**
     * Timestamp of the error
     * @type {string}
     * @memberof APIError
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof Action
     */
    'fromToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The amount of \'fromToken\' to be transferred, specified as a string to maintain precision.
     * @type {string}
     * @memberof Action
     */
    'fromAmount'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof Action
     */
    'toToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The maximum acceptable difference between the expected price of the \'toToken\' and the price at the time of the transfer.
     * @type {number}
     * @memberof Action
     */
    'slippage'?: number;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof Action
     */
    'fromAddress'?: string;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof Action
     */
    'toAddress'?: string;
}
/**
 * Stores global constants related to the authorization of the application. Specifically enumerates the claims to validate for as per RFC 7519, section 4.1. See: https://tools.ietf.org/html/rfc7519#section-4.1
 * @export
 * @enum {string}
 */

export const AuthzJwtClaim = {
    /**
    * The &quot;iss&quot; (issuer) claim identifies the principal that issued the JWT. The processing of this claim is generally application specific. The &quot;iss&quot; value is a case-sensitive string containing a StringOrURI value. Use of this claim is OPTIONAL.
    */
    iss: 'Hyperledger Labs - Carbon Accounting Tool'
} as const;

export type AuthzJwtClaim = typeof AuthzJwtClaim[keyof typeof AuthzJwtClaim];


/**
 * 
 * @export
 * @enum {string}
 */

export const AuthzScope = {
    /**
    * Identities with the group:admin scope are administrators of the system.
    */
    GroupAdmin: 'group:admin',
    /**
    * Identities with the group:user scope are end users of the system who only have authorization to perform a limited set of actions.
    */
    GroupUser: 'group:user'
} as const;

export type AuthzScope = typeof AuthzScope[keyof typeof AuthzScope];


/**
 * Information about the bridge used for the token transfer.
 * @export
 * @interface BridgeInfo
 */
export interface BridgeInfo {
    /**
     * The address of the token being transferred.
     * @type {string}
     * @memberof BridgeInfo
     */
    'tokenAddress'?: string;
}
/**
 * Response for a cancel transaction request. Indicates whether the cancel action was successful and includes the current session status.
 * @export
 * @interface Cancel200Response
 */
export interface Cancel200Response {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof Cancel200Response
     */
    'statusResponse': Transact200ResponseStatusResponse;
    /**
     * Indicates whether the cancel operation was successful.
     * @type {boolean}
     * @memberof Cancel200Response
     */
    'cancelSuccessful': boolean;
}
/**
 * Request to cancel an ongoing transaction session, identified by the session ID.
 * @export
 * @interface CancelRequest
 */
export interface CancelRequest {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof CancelRequest
     */
    'sessionID': string;
}
/**
 * Response for a cancel transaction request. Indicates whether the cancel action was successful and includes the current session status.
 * @export
 * @interface CancelResponse
 */
export interface CancelResponse {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof CancelResponse
     */
    'statusResponse': Transact200ResponseStatusResponse;
    /**
     * Indicates whether the cancel operation was successful.
     * @type {boolean}
     * @memberof CancelResponse
     */
    'cancelSuccessful': boolean;
}
/**
 * 
 * @export
 * @interface Chain
 */
export interface Chain {
    /**
     * A unique identifier for the blockchain network.
     * @type {string}
     * @memberof Chain
     */
    'chainId': string;
    /**
     * The name of the blockchain network.
     * @type {string}
     * @memberof Chain
     */
    'chainName': string;
    /**
     * The type of blockchain network (e.g., \'evm\', \'fabric\').
     * @type {string}
     * @memberof Chain
     */
    'chainType': string;
    /**
     * The specific network name within the blockchain (e.g., \'mainnet\', \'testnet\').
     * @type {string}
     * @memberof Chain
     */
    'networkName': string;
}
/**
 * 
 * @export
 * @interface Chains1Inner
 */
export interface Chains1Inner {
    /**
     * A unique identifier for the blockchain network.
     * @type {string}
     * @memberof Chains1Inner
     */
    'chainId': string;
    /**
     * The name of the blockchain network.
     * @type {string}
     * @memberof Chains1Inner
     */
    'chainName': string;
    /**
     * The type of blockchain network (e.g., \'evm\', \'fabric\').
     * @type {string}
     * @memberof Chains1Inner
     */
    'chainType': string;
    /**
     * The specific network name within the blockchain (e.g., \'mainnet\', \'testnet\').
     * @type {string}
     * @memberof Chains1Inner
     */
    'networkName': string;
}
/**
 * Response schema for a continue request, returning the status of the SATP session.
 * @export
 * @interface Continue200Response
 */
export interface Continue200Response {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof Continue200Response
     */
    'statusResponse': Transact200ResponseStatusResponse;
}
/**
 * Schema for a request to continue a paused transaction session.
 * @export
 * @interface ContinueRequest
 */
export interface ContinueRequest {
    /**
     * A unique identifier for the transaction session to be continued.
     * @type {string}
     * @memberof ContinueRequest
     */
    'sessionId': string;
    /**
     * A unique identifier for the transaction context.
     * @type {string}
     * @memberof ContinueRequest
     */
    'contextId': string;
}
/**
 * Response schema for a continue request, returning the status of the SATP session.
 * @export
 * @interface ContinueResponse
 */
export interface ContinueResponse {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof ContinueResponse
     */
    'statusResponse': Transact200ResponseStatusResponse;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CredentialProfile = {
    Saml: 'SAML',
    Oauth: 'OAUTH',
    X509: 'X509'
} as const;

export type CredentialProfile = typeof CredentialProfile[keyof typeof CredentialProfile];


/**
 * Supported DLT protocols.
 * @export
 * @enum {string}
 */

export const DLTProtocol = {
    HyperledgerFabric: 'HyperledgerFabric',
    HyperledgerBesu: 'HyperledgerBesu'
} as const;

export type DLTProtocol = typeof DLTProtocol[keyof typeof DLTProtocol];


/**
 * Provides an estimation for a transaction, including costs, amounts, and execution duration.
 * @export
 * @interface Estimate
 */
export interface Estimate {
    /**
     * A blockchain address.
     * @type {string}
     * @memberof Estimate
     */
    'approvalAddress'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof Estimate
     */
    'toAmountMin'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof Estimate
     */
    'toAmount'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof Estimate
     */
    'fromAmount'?: string;
    /**
     * A collection of fee costs associated with the transaction.
     * @type {Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner>}
     * @memberof Estimate
     */
    'feeCosts'?: Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner>;
    /**
     * A collection of estimated gas costs for executing the transaction.
     * @type {Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner>}
     * @memberof Estimate
     */
    'gasCosts'?: Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner>;
    /**
     * The estimated duration for the transaction execution in seconds.
     * @type {number}
     * @memberof Estimate
     */
    'executionDuration'?: number;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof Estimate
     */
    'fromAmountUSD'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof Estimate
     */
    'toAmountUSD'?: string;
    /**
     * The tool or service used to generate this estimate.
     * @type {string}
     * @memberof Estimate
     */
    'tool'?: string;
}
/**
 * Details about a specific fee cost associated with the transaction.
 * @export
 * @interface FeeCost
 */
export interface FeeCost {
    /**
     * Name of the fee cost.
     * @type {string}
     * @memberof FeeCost
     */
    'name'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof FeeCost
     */
    'amount'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof FeeCost
     */
    'amountUSD'?: string;
    /**
     * The symbol of a token
     * @type {string}
     * @memberof FeeCost
     */
    'token'?: string;
    /**
     * Indicates if the fee is included in the transaction amount.
     * @type {boolean}
     * @memberof FeeCost
     */
    'included'?: boolean;
}
/**
 * 
 * @export
 * @interface GasCost
 */
export interface GasCost {
    /**
     * The type of the gas cost.
     * @type {string}
     * @memberof GasCost
     */
    'type'?: string;
    /**
     * The gas price, specified as a string to maintain precision.
     * @type {string}
     * @memberof GasCost
     */
    'price'?: string;
    /**
     * The estimated gas required, specified as a string to maintain precision.
     * @type {string}
     * @memberof GasCost
     */
    'estimate'?: string;
    /**
     * The gas limit for the transaction, specified as a string to maintain precision.
     * @type {string}
     * @memberof GasCost
     */
    'limit'?: string;
    /**
     * The amount of gas required in the gas currency.
     * @type {string}
     * @memberof GasCost
     */
    'amount'?: string;
    /**
     * The amount of gas required in USD.
     * @type {string}
     * @memberof GasCost
     */
    'amountUSD'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof GasCost
     */
    'token'?: GetRoutes200ResponseRoutesInnerFromToken;
}
/**
 * Response schema for an audit request. Contains the proofs generated during the audit period and the start and end datetimes.
 * @export
 * @interface GetAudit200Response
 */
export interface GetAudit200Response {
    /**
     * An array of strings representing proofs.
     * @type {Array<string>}
     * @memberof GetAudit200Response
     */
    'proofs'?: Array<string>;
    /**
     * The start datetime of the audit period.
     * @type {string}
     * @memberof GetAudit200Response
     */
    'auditStartTime'?: string;
    /**
     * The end datetime of the audit period.
     * @type {string}
     * @memberof GetAudit200Response
     */
    'auditEndTime'?: string;
}
/**
 * Request schema for initiating an audit. Includes the start and end dates for the audit period and an option to include proofs.
 * @export
 * @interface GetAuditRequest
 */
export interface GetAuditRequest {
    /**
     * The start datetime for the audit.
     * @type {string}
     * @memberof GetAuditRequest
     */
    'auditStartDate'?: string;
    /**
     * The end datetime for the audit.
     * @type {string}
     * @memberof GetAuditRequest
     */
    'auditEndDate'?: string;
    /**
     * Include proofs generated from each gateway transaction.
     * @type {boolean}
     * @memberof GetAuditRequest
     */
    'includeProofs'?: boolean;
}
/**
 * Response schema for an audit request. Contains the proofs generated during the audit period and the start and end datetimes.
 * @export
 * @interface GetAuditResponse
 */
export interface GetAuditResponse {
    /**
     * An array of strings representing proofs.
     * @type {Array<string>}
     * @memberof GetAuditResponse
     */
    'proofs'?: Array<string>;
    /**
     * The start datetime of the audit period.
     * @type {string}
     * @memberof GetAuditResponse
     */
    'auditStartTime'?: string;
    /**
     * The end datetime of the audit period.
     * @type {string}
     * @memberof GetAuditResponse
     */
    'auditEndTime'?: string;
}
/**
 * 
 * @export
 * @interface GetHealthCheck200Response
 */
export interface GetHealthCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof GetHealthCheck200Response
     */
    'status'?: string;
}
/**
 * A collection of available and unavailable routes
 * @export
 * @interface GetRoutes200Response
 */
export interface GetRoutes200Response {
    /**
     * A collection of route objects
     * @type {Array<GetRoutes200ResponseRoutesInner>}
     * @memberof GetRoutes200Response
     */
    'routes': Array<GetRoutes200ResponseRoutesInner>;
}
/**
 * 
 * @export
 * @interface GetRoutes200ResponseRoutesInner
 */
export interface GetRoutes200ResponseRoutesInner {
    /**
     * A unique identifier of the route.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'id': string;
    /**
     * A unique identifier for the gateway.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'gatewayID': string;
    /**
     * The mode of operation for this route - \'data\' for arbitrary payload handling, \'transfer\' for asset transfer.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'mode': GetRoutes200ResponseRoutesInnerModeEnum;
    /**
     * The ID of the DLT Network where the operation will originate.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'fromDLTNetworkID'?: string;
    /**
     * The amount of \'fromToken\' to be transferred in USD, specified as a string to maintain precision.
     * @type {number}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'fromAmountUSD'?: number;
    /**
     * The amount that should be sent including all decimals (e.g., 1000000 for 1 USDC (6 decimals)).
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'fromAmount'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'fromToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The ID of the DLT Network where the operation will end.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'toDLTNetworkID'?: string;
    /**
     * The expected amount to be received in USD.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'toAmountUSD'?: string;
    /**
     * The expected amount to be received including all decimals (e.g., 1000000 for 1 USDC (6 decimals)).
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'toAmount'?: string;
    /**
     * The minimum expected amount to be received including all decimals (e.g., 1000000 for 1 USDC (6 decimals)).
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'toAmountMin'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'toToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The expected gas cost in USD.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'gasCostUSD'?: string;
    /**
     * Whether chain switching is enabled or not.
     * @type {boolean}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'containsSwitchChain'?: boolean;
    /**
     * List of steps involved in this route, adjusted for mode.
     * @type {Array<GetRoutes200ResponseRoutesInnerStepsInner>}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'steps'?: Array<GetRoutes200ResponseRoutesInnerStepsInner>;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerInsurance}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'insurance'?: GetRoutes200ResponseRoutesInnerInsurance;
    /**
     * List of tags identifiers providing additional context or categorization.
     * @type {Array<string>}
     * @memberof GetRoutes200ResponseRoutesInner
     */
    'tags'?: Array<string>;
}

export const GetRoutes200ResponseRoutesInnerModeEnum = {
    Data: 'data',
    Transfer: 'transfer'
} as const;

export type GetRoutes200ResponseRoutesInnerModeEnum = typeof GetRoutes200ResponseRoutesInnerModeEnum[keyof typeof GetRoutes200ResponseRoutesInnerModeEnum];

/**
 * Metadata detailing a supported token
 * @export
 * @interface GetRoutes200ResponseRoutesInnerFromToken
 */
export interface GetRoutes200ResponseRoutesInnerFromToken {
    /**
     * The network of the DLT being interacted with. TODO: implement network identification draft
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'chainID': string;
    /**
     * Supported DLT protocols.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'chainType': GetRoutes200ResponseRoutesInnerFromTokenChainTypeEnum;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'address': string;
    /**
     * The name of the token.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'name'?: string;
    /**
     * The symbol of the token.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'symbol': string;
    /**
     * How many decimals the token supports.
     * @type {number}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'decimals': number;
    /**
     * The logo of a token, chain, dex etc.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'logoURI'?: string;
    /**
     * List of tags identifiers providing additional context or categorization.
     * @type {Array<string>}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'tags'?: Array<string>;
    /**
     * The current price of the token in USD.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'priceUSD'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromTokenExtensions}
     * @memberof GetRoutes200ResponseRoutesInnerFromToken
     */
    'extensions'?: GetRoutes200ResponseRoutesInnerFromTokenExtensions;
}

export const GetRoutes200ResponseRoutesInnerFromTokenChainTypeEnum = {
    HyperledgerFabric: 'HyperledgerFabric',
    HyperledgerBesu: 'HyperledgerBesu'
} as const;

export type GetRoutes200ResponseRoutesInnerFromTokenChainTypeEnum = typeof GetRoutes200ResponseRoutesInnerFromTokenChainTypeEnum[keyof typeof GetRoutes200ResponseRoutesInnerFromTokenChainTypeEnum];

/**
 * 
 * @export
 * @interface GetRoutes200ResponseRoutesInnerFromTokenExtensions
 */
export interface GetRoutes200ResponseRoutesInnerFromTokenExtensions {
    /**
     * 
     * @type {{ [key: string]: GetRoutes200ResponseRoutesInnerFromTokenExtensionsBridgeInfoValue; }}
     * @memberof GetRoutes200ResponseRoutesInnerFromTokenExtensions
     */
    'bridgeInfo'?: { [key: string]: GetRoutes200ResponseRoutesInnerFromTokenExtensionsBridgeInfoValue; };
    /**
     * Indicates whether the token is verified.
     * @type {boolean}
     * @memberof GetRoutes200ResponseRoutesInnerFromTokenExtensions
     */
    'verified'?: boolean;
}
/**
 * Information about the bridge used for the token transfer.
 * @export
 * @interface GetRoutes200ResponseRoutesInnerFromTokenExtensionsBridgeInfoValue
 */
export interface GetRoutes200ResponseRoutesInnerFromTokenExtensionsBridgeInfoValue {
    /**
     * The address of the token being transferred.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerFromTokenExtensionsBridgeInfoValue
     */
    'tokenAddress'?: string;
}
/**
 * 
 * @export
 * @interface GetRoutes200ResponseRoutesInnerInsurance
 */
export interface GetRoutes200ResponseRoutesInnerInsurance {
    /**
     * The state of insurance applicability for the transaction.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerInsurance
     */
    'state'?: GetRoutes200ResponseRoutesInnerInsuranceStateEnum;
    /**
     * The fee amount for insurance, represented in USD.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerInsurance
     */
    'feeAmountUsd'?: string;
}

export const GetRoutes200ResponseRoutesInnerInsuranceStateEnum = {
    NotInsurable: 'NOT_INSURABLE',
    Insurable: 'INSURABLE',
    Insured: 'INSURED'
} as const;

export type GetRoutes200ResponseRoutesInnerInsuranceStateEnum = typeof GetRoutes200ResponseRoutesInnerInsuranceStateEnum[keyof typeof GetRoutes200ResponseRoutesInnerInsuranceStateEnum];

/**
 * Details a single step within a route including actions and estimates.
 * @export
 * @interface GetRoutes200ResponseRoutesInnerStepsInner
 */
export interface GetRoutes200ResponseRoutesInnerStepsInner {
    /**
     * Id of the step
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'id'?: string;
    /**
     * Type of the step, typically describing the action, e.g., \'swap\'.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'type'?: string;
    /**
     * Tool used in the step, e.g., \'stargate\'.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'tool'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerAction}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'action'?: GetRoutes200ResponseRoutesInnerStepsInnerAction;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerEstimate}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'estimate'?: GetRoutes200ResponseRoutesInnerStepsInnerEstimate;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerToolDetails}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'toolDetails'?: GetRoutes200ResponseRoutesInnerStepsInnerToolDetails;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerToolDetails}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'integrationDetails'?: GetRoutes200ResponseRoutesInnerStepsInnerToolDetails;
    /**
     * IDs of further steps included within this step, allowing for nested actions without direct recursion.
     * @type {Array<string>}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInner
     */
    'includedStepIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetRoutes200ResponseRoutesInnerStepsInnerAction
 */
export interface GetRoutes200ResponseRoutesInnerStepsInnerAction {
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerAction
     */
    'fromToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The amount of \'fromToken\' to be transferred, specified as a string to maintain precision.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerAction
     */
    'fromAmount'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerAction
     */
    'toToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The maximum acceptable difference between the expected price of the \'toToken\' and the price at the time of the transfer.
     * @type {number}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerAction
     */
    'slippage'?: number;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerAction
     */
    'fromAddress'?: string;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerAction
     */
    'toAddress'?: string;
}
/**
 * Provides an estimation for a transaction, including costs, amounts, and execution duration.
 * @export
 * @interface GetRoutes200ResponseRoutesInnerStepsInnerEstimate
 */
export interface GetRoutes200ResponseRoutesInnerStepsInnerEstimate {
    /**
     * A blockchain address.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'approvalAddress'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'toAmountMin'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'toAmount'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'fromAmount'?: string;
    /**
     * A collection of fee costs associated with the transaction.
     * @type {Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner>}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'feeCosts'?: Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner>;
    /**
     * A collection of estimated gas costs for executing the transaction.
     * @type {Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner>}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'gasCosts'?: Array<GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner>;
    /**
     * The estimated duration for the transaction execution in seconds.
     * @type {number}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'executionDuration'?: number;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'fromAmountUSD'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'toAmountUSD'?: string;
    /**
     * The tool or service used to generate this estimate.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimate
     */
    'tool'?: string;
}
/**
 * Details about a specific fee cost associated with the transaction.
 * @export
 * @interface GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner
 */
export interface GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner {
    /**
     * Name of the fee cost.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner
     */
    'name'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner
     */
    'amount'?: string;
    /**
     * The amount in string format including all decimals.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner
     */
    'amountUSD'?: string;
    /**
     * The symbol of a token
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner
     */
    'token'?: string;
    /**
     * Indicates if the fee is included in the transaction amount.
     * @type {boolean}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateFeeCostsInner
     */
    'included'?: boolean;
}
/**
 * 
 * @export
 * @interface GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
 */
export interface GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner {
    /**
     * The type of the gas cost.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'type'?: string;
    /**
     * The gas price, specified as a string to maintain precision.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'price'?: string;
    /**
     * The estimated gas required, specified as a string to maintain precision.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'estimate'?: string;
    /**
     * The gas limit for the transaction, specified as a string to maintain precision.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'limit'?: string;
    /**
     * The amount of gas required in the gas currency.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'amount'?: string;
    /**
     * The amount of gas required in USD.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'amountUSD'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerEstimateGasCostsInner
     */
    'token'?: GetRoutes200ResponseRoutesInnerFromToken;
}
/**
 * Describes integration or tool details such as bridges or exchanges involved in the transaction.
 * @export
 * @interface GetRoutes200ResponseRoutesInnerStepsInnerToolDetails
 */
export interface GetRoutes200ResponseRoutesInnerStepsInnerToolDetails {
    /**
     * A unique identifier for the integration or tool.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerToolDetails
     */
    'key': string;
    /**
     * The name of the integration or tool.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerToolDetails
     */
    'name': string;
    /**
     * URL to the logo of the integration or tool.
     * @type {string}
     * @memberof GetRoutes200ResponseRoutesInnerStepsInnerToolDetails
     */
    'logoURI': string;
}
/**
 * 
 * @export
 * @interface HealthCheckResponse
 */
export interface HealthCheckResponse {
    /**
     * 
     * @type {string}
     * @memberof HealthCheckResponse
     */
    'status'?: string;
}
/**
 * Details a single step within a route including actions and estimates.
 * @export
 * @interface IncludedStep
 */
export interface IncludedStep {
    /**
     * Id of the step
     * @type {string}
     * @memberof IncludedStep
     */
    'id'?: string;
    /**
     * Type of the step, typically describing the action, e.g., \'swap\'.
     * @type {string}
     * @memberof IncludedStep
     */
    'type'?: string;
    /**
     * Tool used in the step, e.g., \'stargate\'.
     * @type {string}
     * @memberof IncludedStep
     */
    'tool'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerAction}
     * @memberof IncludedStep
     */
    'action'?: GetRoutes200ResponseRoutesInnerStepsInnerAction;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerEstimate}
     * @memberof IncludedStep
     */
    'estimate'?: GetRoutes200ResponseRoutesInnerStepsInnerEstimate;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerToolDetails}
     * @memberof IncludedStep
     */
    'toolDetails'?: GetRoutes200ResponseRoutesInnerStepsInnerToolDetails;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerStepsInnerToolDetails}
     * @memberof IncludedStep
     */
    'integrationDetails'?: GetRoutes200ResponseRoutesInnerStepsInnerToolDetails;
    /**
     * IDs of further steps included within this step, allowing for nested actions without direct recursion.
     * @type {Array<string>}
     * @memberof IncludedStep
     */
    'includedStepIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Insurance
 */
export interface Insurance {
    /**
     * The state of insurance applicability for the transaction.
     * @type {string}
     * @memberof Insurance
     */
    'state'?: InsuranceStateEnum;
    /**
     * The fee amount for insurance, represented in USD.
     * @type {string}
     * @memberof Insurance
     */
    'feeAmountUsd'?: string;
}

export const InsuranceStateEnum = {
    NotInsurable: 'NOT_INSURABLE',
    Insurable: 'INSURABLE',
    Insured: 'INSURED'
} as const;

export type InsuranceStateEnum = typeof InsuranceStateEnum[keyof typeof InsuranceStateEnum];

/**
 * Describes integration or tool details such as bridges or exchanges involved in the transaction.
 * @export
 * @interface IntegrationDetails
 */
export interface IntegrationDetails {
    /**
     * A unique identifier for the integration or tool.
     * @type {string}
     * @memberof IntegrationDetails
     */
    'key': string;
    /**
     * The name of the integration or tool.
     * @type {string}
     * @memberof IntegrationDetails
     */
    'name': string;
    /**
     * URL to the logo of the integration or tool.
     * @type {string}
     * @memberof IntegrationDetails
     */
    'logoURI': string;
}
/**
 * Response for a pause transaction request. Returns the current status of the SATP session post-pause action.
 * @export
 * @interface Pause200Response
 */
export interface Pause200Response {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof Pause200Response
     */
    'statusResponse': Transact200ResponseStatusResponse;
}
/**
 * Request to temporarily pause an ongoing transaction session, identified by the session and context IDs.
 * @export
 * @interface PauseRequest
 */
export interface PauseRequest {
    /**
     * 
     * @type {string}
     * @memberof PauseRequest
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PauseRequest
     */
    'contextId'?: string;
}
/**
 * Response for a pause transaction request. Returns the current status of the SATP session post-pause action.
 * @export
 * @interface PauseResponse
 */
export interface PauseResponse {
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof PauseResponse
     */
    'statusResponse': Transact200ResponseStatusResponse;
}
/**
 * 
 * @export
 * @interface Route
 */
export interface Route {
    /**
     * A unique identifier of the route.
     * @type {string}
     * @memberof Route
     */
    'id': string;
    /**
     * A unique identifier for the gateway.
     * @type {string}
     * @memberof Route
     */
    'gatewayID': string;
    /**
     * The mode of operation for this route - \'data\' for arbitrary payload handling, \'transfer\' for asset transfer.
     * @type {string}
     * @memberof Route
     */
    'mode': RouteModeEnum;
    /**
     * The ID of the DLT Network where the operation will originate.
     * @type {string}
     * @memberof Route
     */
    'fromDLTNetworkID'?: string;
    /**
     * The amount of \'fromToken\' to be transferred in USD, specified as a string to maintain precision.
     * @type {number}
     * @memberof Route
     */
    'fromAmountUSD'?: number;
    /**
     * The amount that should be sent including all decimals (e.g., 1000000 for 1 USDC (6 decimals)).
     * @type {string}
     * @memberof Route
     */
    'fromAmount'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof Route
     */
    'fromToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The ID of the DLT Network where the operation will end.
     * @type {string}
     * @memberof Route
     */
    'toDLTNetworkID'?: string;
    /**
     * The expected amount to be received in USD.
     * @type {string}
     * @memberof Route
     */
    'toAmountUSD'?: string;
    /**
     * The expected amount to be received including all decimals (e.g., 1000000 for 1 USDC (6 decimals)).
     * @type {string}
     * @memberof Route
     */
    'toAmount'?: string;
    /**
     * The minimum expected amount to be received including all decimals (e.g., 1000000 for 1 USDC (6 decimals)).
     * @type {string}
     * @memberof Route
     */
    'toAmountMin'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromToken}
     * @memberof Route
     */
    'toToken'?: GetRoutes200ResponseRoutesInnerFromToken;
    /**
     * The expected gas cost in USD.
     * @type {string}
     * @memberof Route
     */
    'gasCostUSD'?: string;
    /**
     * Whether chain switching is enabled or not.
     * @type {boolean}
     * @memberof Route
     */
    'containsSwitchChain'?: boolean;
    /**
     * List of steps involved in this route, adjusted for mode.
     * @type {Array<GetRoutes200ResponseRoutesInnerStepsInner>}
     * @memberof Route
     */
    'steps'?: Array<GetRoutes200ResponseRoutesInnerStepsInner>;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerInsurance}
     * @memberof Route
     */
    'insurance'?: GetRoutes200ResponseRoutesInnerInsurance;
    /**
     * List of tags identifiers providing additional context or categorization.
     * @type {Array<string>}
     * @memberof Route
     */
    'tags'?: Array<string>;
}

export const RouteModeEnum = {
    Data: 'data',
    Transfer: 'transfer'
} as const;

export type RouteModeEnum = typeof RouteModeEnum[keyof typeof RouteModeEnum];

/**
 * A collection of available and unavailable routes
 * @export
 * @interface RoutesResponse
 */
export interface RoutesResponse {
    /**
     * A collection of route objects
     * @type {Array<GetRoutes200ResponseRoutesInner>}
     * @memberof RoutesResponse
     */
    'routes': Array<GetRoutes200ResponseRoutesInner>;
}
/**
 * Request for retrieving the current status of a session, identified by the session ID.
 * @export
 * @interface StatusRequest
 */
export interface StatusRequest {
    /**
     * The ID of the session for which the status is being requested.
     * @type {string}
     * @memberof StatusRequest
     */
    'sessionID': string;
}
/**
 * Provides the current status of the SATP session including detailed information on the progress, such as substatus, stage, and step, along with the session start time and chain information.
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'status': StatusResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'substatus': StatusResponseSubstatusEnum;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'stage': StatusResponseStageEnum;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'step': StatusResponseStepEnum;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'startTime': string;
    /**
     * 
     * @type {Transact200ResponseStatusResponseOriginChain}
     * @memberof StatusResponse
     */
    'originChain': Transact200ResponseStatusResponseOriginChain;
    /**
     * 
     * @type {Transact200ResponseStatusResponseDestinationChain}
     * @memberof StatusResponse
     */
    'destinationChain': Transact200ResponseStatusResponseDestinationChain;
}

export const StatusResponseStatusEnum = {
    NotFound: 'NOT_FOUND',
    Invalid: 'INVALID',
    Pending: 'PENDING',
    Done: 'DONE',
    Failed: 'FAILED'
} as const;

export type StatusResponseStatusEnum = typeof StatusResponseStatusEnum[keyof typeof StatusResponseStatusEnum];
export const StatusResponseSubstatusEnum = {
    WaitSourceConfirmations: 'WAIT_SOURCE_CONFIRMATIONS',
    WaitDestinationTransaction: 'WAIT_DESTINATION_TRANSACTION',
    BridgeNotAvailable: 'BRIDGE_NOT_AVAILABLE',
    ChainNotAvailable: 'CHAIN_NOT_AVAILABLE',
    RefundInProgress: 'REFUND_IN_PROGRESS',
    UnknownError: 'UNKNOWN_ERROR',
    Completed: 'COMPLETED',
    Partial: 'PARTIAL',
    Refunded: 'REFUNDED',
    NotProcessableRefundNeeded: 'NOT_PROCESSABLE_REFUND_NEEDED'
} as const;

export type StatusResponseSubstatusEnum = typeof StatusResponseSubstatusEnum[keyof typeof StatusResponseSubstatusEnum];
export const StatusResponseStageEnum = {
    Stage0: 'STAGE0',
    Stage1: 'STAGE1',
    Stage2: 'STAGE2',
    Stage3: 'STAGE3'
} as const;

export type StatusResponseStageEnum = typeof StatusResponseStageEnum[keyof typeof StatusResponseStageEnum];
export const StatusResponseStepEnum = {
    TransferInitializationClaims: 'transfer-initialization-claims',
    ConveyanceOfNetworkCapabilitiesAndParameters: 'conveyance-of-network-capabilities-and-parameters',
    TransferProposalMessage: 'transfer-proposal-message',
    TransferProposalReceiptMessage: 'transfer-proposal-receipt-message',
    TransferProposalRejectAndConditionalRejectMessage: 'transfer-proposal-reject-and-conditional-reject-message',
    TransferCommenceMessage: 'transfer-commence-message',
    CommenceResponseMessage: 'commence-response-message',
    LockAssertionMessage: 'lock-assertion-message',
    LockAssertionReceiptMessage: 'lock-assertion-receipt-message',
    CommitPreparationMessage: 'commit-preparation-message',
    CommitReadyMessage: 'commit-ready-message',
    CommitFinalAssertionMessage: 'commit-final-assertion-message',
    CommitFinalAcknowledgementReceiptMessage: 'commit-final-acknowledgement-receipt-message',
    TransferCompleteMessage: 'transfer-complete-message',
    RollbackTransferInitializationClaims: 'rollback-transfer-initialization-claims',
    RollbackConveyanceOfNetworkCapabilitiesAndParameters: 'rollback-conveyance-of-network-capabilities-and-parameters',
    RollbackTransferProposalMessage: 'rollback-transfer-proposal-message',
    RollbackTransferProposalReceiptMessage: 'rollback-transfer-proposal-receipt-message',
    RollbackTransferProposalRejectAndConditionalRejectMessage: 'rollback-transfer-proposal-reject-and-conditional-reject-message',
    RollbackTransferCommenceMessage: 'rollback-transfer-commence-message',
    RollbackCommenceResponseMessage: 'rollback-commence-response-message',
    RollbackLockAssertionMessage: 'rollback-lock-assertion-message',
    RollbackLockAssertionReceiptMessage: 'rollback-lock-assertion-receipt-message',
    RollbackCommitPreparationMessage: 'rollback-commit-preparation-message',
    RollbackCommitReadyMessage: 'rollback-commit-ready-message',
    RollbackCommitFinalAssertionMessage: 'rollback-commit-final-assertion-message',
    RollbackCommitFinalAcknowledgementReceiptMessage: 'rollback-commit-final-acknowledgement-receipt-message',
    RollbackTransferCompleteMessage: 'rollback-transfer-complete-message'
} as const;

export type StatusResponseStepEnum = typeof StatusResponseStepEnum[keyof typeof StatusResponseStepEnum];

/**
 * Metadata detailing a supported token
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * The network of the DLT being interacted with. TODO: implement network identification draft
     * @type {string}
     * @memberof Token
     */
    'chainID': string;
    /**
     * Supported DLT protocols.
     * @type {string}
     * @memberof Token
     */
    'chainType': TokenChainTypeEnum;
    /**
     * A blockchain address.
     * @type {string}
     * @memberof Token
     */
    'address': string;
    /**
     * The name of the token.
     * @type {string}
     * @memberof Token
     */
    'name'?: string;
    /**
     * The symbol of the token.
     * @type {string}
     * @memberof Token
     */
    'symbol': string;
    /**
     * How many decimals the token supports.
     * @type {number}
     * @memberof Token
     */
    'decimals': number;
    /**
     * The logo of a token, chain, dex etc.
     * @type {string}
     * @memberof Token
     */
    'logoURI'?: string;
    /**
     * List of tags identifiers providing additional context or categorization.
     * @type {Array<string>}
     * @memberof Token
     */
    'tags'?: Array<string>;
    /**
     * The current price of the token in USD.
     * @type {string}
     * @memberof Token
     */
    'priceUSD'?: string;
    /**
     * 
     * @type {GetRoutes200ResponseRoutesInnerFromTokenExtensions}
     * @memberof Token
     */
    'extensions'?: GetRoutes200ResponseRoutesInnerFromTokenExtensions;
}

export const TokenChainTypeEnum = {
    HyperledgerFabric: 'HyperledgerFabric',
    HyperledgerBesu: 'HyperledgerBesu'
} as const;

export type TokenChainTypeEnum = typeof TokenChainTypeEnum[keyof typeof TokenChainTypeEnum];

/**
 * Response schema for a transaction request. Includes the session ID and the current status of the transaction.
 * @export
 * @interface Transact200Response
 */
export interface Transact200Response {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof Transact200Response
     */
    'sessionID': string;
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof Transact200Response
     */
    'statusResponse': Transact200ResponseStatusResponse;
}
/**
 * Provides the current status of the SATP session including detailed information on the progress, such as substatus, stage, and step, along with the session start time and chain information.
 * @export
 * @interface Transact200ResponseStatusResponse
 */
export interface Transact200ResponseStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof Transact200ResponseStatusResponse
     */
    'status': Transact200ResponseStatusResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Transact200ResponseStatusResponse
     */
    'substatus': Transact200ResponseStatusResponseSubstatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Transact200ResponseStatusResponse
     */
    'stage': Transact200ResponseStatusResponseStageEnum;
    /**
     * 
     * @type {string}
     * @memberof Transact200ResponseStatusResponse
     */
    'step': Transact200ResponseStatusResponseStepEnum;
    /**
     * 
     * @type {string}
     * @memberof Transact200ResponseStatusResponse
     */
    'startTime': string;
    /**
     * 
     * @type {Transact200ResponseStatusResponseOriginChain}
     * @memberof Transact200ResponseStatusResponse
     */
    'originChain': Transact200ResponseStatusResponseOriginChain;
    /**
     * 
     * @type {Transact200ResponseStatusResponseDestinationChain}
     * @memberof Transact200ResponseStatusResponse
     */
    'destinationChain': Transact200ResponseStatusResponseDestinationChain;
}

export const Transact200ResponseStatusResponseStatusEnum = {
    NotFound: 'NOT_FOUND',
    Invalid: 'INVALID',
    Pending: 'PENDING',
    Done: 'DONE',
    Failed: 'FAILED'
} as const;

export type Transact200ResponseStatusResponseStatusEnum = typeof Transact200ResponseStatusResponseStatusEnum[keyof typeof Transact200ResponseStatusResponseStatusEnum];
export const Transact200ResponseStatusResponseSubstatusEnum = {
    WaitSourceConfirmations: 'WAIT_SOURCE_CONFIRMATIONS',
    WaitDestinationTransaction: 'WAIT_DESTINATION_TRANSACTION',
    BridgeNotAvailable: 'BRIDGE_NOT_AVAILABLE',
    ChainNotAvailable: 'CHAIN_NOT_AVAILABLE',
    RefundInProgress: 'REFUND_IN_PROGRESS',
    UnknownError: 'UNKNOWN_ERROR',
    Completed: 'COMPLETED',
    Partial: 'PARTIAL',
    Refunded: 'REFUNDED',
    NotProcessableRefundNeeded: 'NOT_PROCESSABLE_REFUND_NEEDED'
} as const;

export type Transact200ResponseStatusResponseSubstatusEnum = typeof Transact200ResponseStatusResponseSubstatusEnum[keyof typeof Transact200ResponseStatusResponseSubstatusEnum];
export const Transact200ResponseStatusResponseStageEnum = {
    Stage0: 'STAGE0',
    Stage1: 'STAGE1',
    Stage2: 'STAGE2',
    Stage3: 'STAGE3'
} as const;

export type Transact200ResponseStatusResponseStageEnum = typeof Transact200ResponseStatusResponseStageEnum[keyof typeof Transact200ResponseStatusResponseStageEnum];
export const Transact200ResponseStatusResponseStepEnum = {
    TransferInitializationClaims: 'transfer-initialization-claims',
    ConveyanceOfNetworkCapabilitiesAndParameters: 'conveyance-of-network-capabilities-and-parameters',
    TransferProposalMessage: 'transfer-proposal-message',
    TransferProposalReceiptMessage: 'transfer-proposal-receipt-message',
    TransferProposalRejectAndConditionalRejectMessage: 'transfer-proposal-reject-and-conditional-reject-message',
    TransferCommenceMessage: 'transfer-commence-message',
    CommenceResponseMessage: 'commence-response-message',
    LockAssertionMessage: 'lock-assertion-message',
    LockAssertionReceiptMessage: 'lock-assertion-receipt-message',
    CommitPreparationMessage: 'commit-preparation-message',
    CommitReadyMessage: 'commit-ready-message',
    CommitFinalAssertionMessage: 'commit-final-assertion-message',
    CommitFinalAcknowledgementReceiptMessage: 'commit-final-acknowledgement-receipt-message',
    TransferCompleteMessage: 'transfer-complete-message',
    RollbackTransferInitializationClaims: 'rollback-transfer-initialization-claims',
    RollbackConveyanceOfNetworkCapabilitiesAndParameters: 'rollback-conveyance-of-network-capabilities-and-parameters',
    RollbackTransferProposalMessage: 'rollback-transfer-proposal-message',
    RollbackTransferProposalReceiptMessage: 'rollback-transfer-proposal-receipt-message',
    RollbackTransferProposalRejectAndConditionalRejectMessage: 'rollback-transfer-proposal-reject-and-conditional-reject-message',
    RollbackTransferCommenceMessage: 'rollback-transfer-commence-message',
    RollbackCommenceResponseMessage: 'rollback-commence-response-message',
    RollbackLockAssertionMessage: 'rollback-lock-assertion-message',
    RollbackLockAssertionReceiptMessage: 'rollback-lock-assertion-receipt-message',
    RollbackCommitPreparationMessage: 'rollback-commit-preparation-message',
    RollbackCommitReadyMessage: 'rollback-commit-ready-message',
    RollbackCommitFinalAssertionMessage: 'rollback-commit-final-assertion-message',
    RollbackCommitFinalAcknowledgementReceiptMessage: 'rollback-commit-final-acknowledgement-receipt-message',
    RollbackTransferCompleteMessage: 'rollback-transfer-complete-message'
} as const;

export type Transact200ResponseStatusResponseStepEnum = typeof Transact200ResponseStatusResponseStepEnum[keyof typeof Transact200ResponseStatusResponseStepEnum];

/**
 * 
 * @export
 * @interface Transact200ResponseStatusResponseDestinationChain
 */
export interface Transact200ResponseStatusResponseDestinationChain {
    /**
     * 
     * @type {any}
     * @memberof Transact200ResponseStatusResponseDestinationChain
     */
    'dltProtocol'?: any;
    /**
     * 
     * @type {any}
     * @memberof Transact200ResponseStatusResponseDestinationChain
     */
    'dltSubnetworkID'?: any;
}
/**
 * 
 * @export
 * @interface Transact200ResponseStatusResponseOriginChain
 */
export interface Transact200ResponseStatusResponseOriginChain {
    /**
     * 
     * @type {any}
     * @memberof Transact200ResponseStatusResponseOriginChain
     */
    'dltProtocol'?: any;
    /**
     * 
     * @type {any}
     * @memberof Transact200ResponseStatusResponseOriginChain
     */
    'dltSubnetworkID'?: any;
}
/**
 * An Error
 * @export
 * @interface TransactDefaultResponse
 */
export interface TransactDefaultResponse {
    /**
     * HTTP error type
     * @type {string}
     * @memberof TransactDefaultResponse
     */
    'type': string;
    /**
     * Numeric error code
     * @type {number}
     * @memberof TransactDefaultResponse
     */
    'code': number;
    /**
     * HTTP status of the error
     * @type {number}
     * @memberof TransactDefaultResponse
     */
    'status': number;
    /**
     * Long error description
     * @type {string}
     * @memberof TransactDefaultResponse
     */
    'message': string;
    /**
     * Timestamp of the error
     * @type {string}
     * @memberof TransactDefaultResponse
     */
    'timestamp': string;
}
/**
 * Request schema for initiating a transaction. Includes details such as the transaction context, mode (data or transfer), payload, and information about the source and destination DLT networks.
 * @export
 * @interface TransactRequest
 */
export interface TransactRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'contextID': string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'mode': TransactRequestModeEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'payload'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'fromDLTNetworkID'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'toDLTNetworkID'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'fromAmount'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'fromToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'toAmount'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactRequest
     */
    'toToken'?: string;
}

export const TransactRequestModeEnum = {
    Data: 'data',
    Transfer: 'transfer'
} as const;

export type TransactRequestModeEnum = typeof TransactRequestModeEnum[keyof typeof TransactRequestModeEnum];

/**
 * Response schema for a transaction request. Includes the session ID and the current status of the transaction.
 * @export
 * @interface TransactResponse
 */
export interface TransactResponse {
    /**
     * Unique identifier (UUID) for the session.
     * @type {string}
     * @memberof TransactResponse
     */
    'sessionID': string;
    /**
     * 
     * @type {Transact200ResponseStatusResponse}
     * @memberof TransactResponse
     */
    'statusResponse': Transact200ResponseStatusResponse;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attempts to continue a previously paused transaction intent, resuming its execution.
         * @summary Continue a paused transaction session
         * @param {ContinueRequest} continueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _continue: async (continueRequest: ContinueRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'continueRequest' is not null or undefined
            assertParamExists('_continue', 'continueRequest', continueRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/continue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(continueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Audits transactions based on provided filters such as start and end dates. Optionally includes proofs generated from each gateway transaction.
         * @summary Audit transactions
         * @param {string} [auditStartDate] The start date for the audit period.
         * @param {string} [auditEndDate] The end date for the audit period.
         * @param {boolean} [includeProofs] Include proofs generated from each gateway transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudit: async (auditStartDate?: string, auditEndDate?: string, includeProofs?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/audit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (auditStartDate !== undefined) {
                localVarQueryParameter['auditStartDate'] = (auditStartDate as any instanceof Date) ?
                    (auditStartDate as any).toISOString() :
                    auditStartDate;
            }

            if (auditEndDate !== undefined) {
                localVarQueryParameter['auditEndDate'] = (auditEndDate as any instanceof Date) ?
                    (auditEndDate as any).toISOString() :
                    auditEndDate;
            }

            if (includeProofs !== undefined) {
                localVarQueryParameter['includeProofs'] = includeProofs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Responds if SATP Hermes is on
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the status of a SATP session
         * @summary Get SATP current session data
         * @param {string} sessionID Unique identifier for the session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (sessionID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionID' is not null or undefined
            assertParamExists('getStatus', 'sessionID', sessionID)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionID !== undefined) {
                localVarQueryParameter['SessionID'] = sessionID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to pause a previously submitted transaction intent, temporarily halting its execution.
         * @summary Pause a transaction session
         * @param {PauseRequest} pauseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause: async (pauseRequest: PauseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pauseRequest' is not null or undefined
            assertParamExists('pause', 'pauseRequest', pauseRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/pause`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pauseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Attempts to continue a previously paused transaction intent, resuming its execution.
         * @summary Continue a paused transaction session
         * @param {ContinueRequest} continueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _continue(continueRequest: ContinueRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Continue200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._continue(continueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Audits transactions based on provided filters such as start and end dates. Optionally includes proofs generated from each gateway transaction.
         * @summary Audit transactions
         * @param {string} [auditStartDate] The start date for the audit period.
         * @param {string} [auditEndDate] The end date for the audit period.
         * @param {boolean} [includeProofs] Include proofs generated from each gateway transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudit(auditStartDate?: string, auditEndDate?: string, includeProofs?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAudit200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAudit(auditStartDate, auditEndDate, includeProofs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Responds if SATP Hermes is on
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealthCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHealthCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the status of a SATP session
         * @summary Get SATP current session data
         * @param {string} sessionID Unique identifier for the session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(sessionID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transact200ResponseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(sessionID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attempts to pause a previously submitted transaction intent, temporarily halting its execution.
         * @summary Pause a transaction session
         * @param {PauseRequest} pauseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pause(pauseRequest: PauseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pause200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pause(pauseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Attempts to continue a previously paused transaction intent, resuming its execution.
         * @summary Continue a paused transaction session
         * @param {ContinueRequest} continueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _continue(continueRequest: ContinueRequest, options?: any): AxiosPromise<Continue200Response> {
            return localVarFp._continue(continueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Audits transactions based on provided filters such as start and end dates. Optionally includes proofs generated from each gateway transaction.
         * @summary Audit transactions
         * @param {string} [auditStartDate] The start date for the audit period.
         * @param {string} [auditEndDate] The end date for the audit period.
         * @param {boolean} [includeProofs] Include proofs generated from each gateway transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudit(auditStartDate?: string, auditEndDate?: string, includeProofs?: boolean, options?: any): AxiosPromise<GetAudit200Response> {
            return localVarFp.getAudit(auditStartDate, auditEndDate, includeProofs, options).then((request) => request(axios, basePath));
        },
        /**
         * Responds if SATP Hermes is on
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck(options?: any): AxiosPromise<GetHealthCheck200Response> {
            return localVarFp.getHealthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the status of a SATP session
         * @summary Get SATP current session data
         * @param {string} sessionID Unique identifier for the session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(sessionID: string, options?: any): AxiosPromise<Transact200ResponseStatusResponse> {
            return localVarFp.getStatus(sessionID, options).then((request) => request(axios, basePath));
        },
        /**
         * Attempts to pause a previously submitted transaction intent, temporarily halting its execution.
         * @summary Pause a transaction session
         * @param {PauseRequest} pauseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pause(pauseRequest: PauseRequest, options?: any): AxiosPromise<Pause200Response> {
            return localVarFp.pause(pauseRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Attempts to continue a previously paused transaction intent, resuming its execution.
     * @summary Continue a paused transaction session
     * @param {ContinueRequest} continueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public _continue(continueRequest: ContinueRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration)._continue(continueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Audits transactions based on provided filters such as start and end dates. Optionally includes proofs generated from each gateway transaction.
     * @summary Audit transactions
     * @param {string} [auditStartDate] The start date for the audit period.
     * @param {string} [auditEndDate] The end date for the audit period.
     * @param {boolean} [includeProofs] Include proofs generated from each gateway transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getAudit(auditStartDate?: string, auditEndDate?: string, includeProofs?: boolean, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getAudit(auditStartDate, auditEndDate, includeProofs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Responds if SATP Hermes is on
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getHealthCheck(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the status of a SATP session
     * @summary Get SATP current session data
     * @param {string} sessionID Unique identifier for the session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getStatus(sessionID: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getStatus(sessionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attempts to pause a previously submitted transaction intent, temporarily halting its execution.
     * @summary Pause a transaction session
     * @param {PauseRequest} pauseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public pause(pauseRequest: PauseRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).pause(pauseRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attempts to cancel a previously submitted transaction intent using its session ID.
         * @summary Cancel a transaction session
         * @param {CancelRequest} cancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (cancelRequest: CancelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelRequest' is not null or undefined
            assertParamExists('cancel', 'cancelRequest', cancelRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves metadata about each supported blockchain networks, chains, and other systems.
         * @summary Get supported integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of possible routes for swapping one asset for another across multiple exchanges
         * @summary Get a list of routes for a gateway-to-gateway asset transfer
         * @param {string} fromNetworkID The sending DLT Network.
         * @param {string} fromAmount The amount that should be sent including all decimals.
         * @param {string} fromToken The token that should be transferred. Can be the address or the symbol.
         * @param {string} toDLTNetwork The receiving DLT Network.
         * @param {string} toToken The token that should be transferred to. Can be the address or the symbol.
         * @param {string} fromAddress The sending wallet address.
         * @param {string} toAddress The receiving wallet address. If none is provided, the fromAddress will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes: async (fromNetworkID: string, fromAmount: string, fromToken: string, toDLTNetwork: string, toToken: string, fromAddress: string, toAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromNetworkID' is not null or undefined
            assertParamExists('getRoutes', 'fromNetworkID', fromNetworkID)
            // verify required parameter 'fromAmount' is not null or undefined
            assertParamExists('getRoutes', 'fromAmount', fromAmount)
            // verify required parameter 'fromToken' is not null or undefined
            assertParamExists('getRoutes', 'fromToken', fromToken)
            // verify required parameter 'toDLTNetwork' is not null or undefined
            assertParamExists('getRoutes', 'toDLTNetwork', toDLTNetwork)
            // verify required parameter 'toToken' is not null or undefined
            assertParamExists('getRoutes', 'toToken', toToken)
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('getRoutes', 'fromAddress', fromAddress)
            // verify required parameter 'toAddress' is not null or undefined
            assertParamExists('getRoutes', 'toAddress', toAddress)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/routes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fromNetworkID !== undefined) {
                localVarQueryParameter['fromNetworkID'] = fromNetworkID;
            }

            if (fromAmount !== undefined) {
                localVarQueryParameter['fromAmount'] = fromAmount;
            }

            if (fromToken !== undefined) {
                localVarQueryParameter['fromToken'] = fromToken;
            }

            if (toDLTNetwork !== undefined) {
                localVarQueryParameter['toDLTNetwork'] = toDLTNetwork;
            }

            if (toToken !== undefined) {
                localVarQueryParameter['toToken'] = toToken;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }

            if (toAddress !== undefined) {
                localVarQueryParameter['toAddress'] = toAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {TransactRequest} transactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transact: async (transactRequest: TransactRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactRequest' is not null or undefined
            assertParamExists('transact', 'transactRequest', transactRequest)
            const localVarPath = `/api/v1/@hyperledger/cactus-plugin-satp-hermes/transact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Attempts to cancel a previously submitted transaction intent using its session ID.
         * @summary Cancel a transaction session
         * @param {CancelRequest} cancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(cancelRequest: CancelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cancel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(cancelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves metadata about each supported blockchain networks, chains, and other systems.
         * @summary Get supported integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Chains1Inner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of possible routes for swapping one asset for another across multiple exchanges
         * @summary Get a list of routes for a gateway-to-gateway asset transfer
         * @param {string} fromNetworkID The sending DLT Network.
         * @param {string} fromAmount The amount that should be sent including all decimals.
         * @param {string} fromToken The token that should be transferred. Can be the address or the symbol.
         * @param {string} toDLTNetwork The receiving DLT Network.
         * @param {string} toToken The token that should be transferred to. Can be the address or the symbol.
         * @param {string} fromAddress The sending wallet address.
         * @param {string} toAddress The receiving wallet address. If none is provided, the fromAddress will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutes(fromNetworkID: string, fromAmount: string, fromToken: string, toDLTNetwork: string, toToken: string, fromAddress: string, toAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRoutes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutes(fromNetworkID, fromAmount, fromToken, toDLTNetwork, toToken, fromAddress, toAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {TransactRequest} transactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transact(transactRequest: TransactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transact(transactRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * Attempts to cancel a previously submitted transaction intent using its session ID.
         * @summary Cancel a transaction session
         * @param {CancelRequest} cancelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(cancelRequest: CancelRequest, options?: any): AxiosPromise<Cancel200Response> {
            return localVarFp.cancel(cancelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves metadata about each supported blockchain networks, chains, and other systems.
         * @summary Get supported integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations(options?: any): AxiosPromise<Array<Chains1Inner>> {
            return localVarFp.getIntegrations(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of possible routes for swapping one asset for another across multiple exchanges
         * @summary Get a list of routes for a gateway-to-gateway asset transfer
         * @param {string} fromNetworkID The sending DLT Network.
         * @param {string} fromAmount The amount that should be sent including all decimals.
         * @param {string} fromToken The token that should be transferred. Can be the address or the symbol.
         * @param {string} toDLTNetwork The receiving DLT Network.
         * @param {string} toToken The token that should be transferred to. Can be the address or the symbol.
         * @param {string} fromAddress The sending wallet address.
         * @param {string} toAddress The receiving wallet address. If none is provided, the fromAddress will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes(fromNetworkID: string, fromAmount: string, fromToken: string, toDLTNetwork: string, toToken: string, fromAddress: string, toAddress: string, options?: any): AxiosPromise<GetRoutes200Response> {
            return localVarFp.getRoutes(fromNetworkID, fromAmount, fromToken, toDLTNetwork, toToken, fromAddress, toAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows users to queue intents for transactions based on specified parameters.
         * @summary Submit a transaction intent
         * @param {TransactRequest} transactRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transact(transactRequest: TransactRequest, options?: any): AxiosPromise<Transact200Response> {
            return localVarFp.transact(transactRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * Attempts to cancel a previously submitted transaction intent using its session ID.
     * @summary Cancel a transaction session
     * @param {CancelRequest} cancelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public cancel(cancelRequest: CancelRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).cancel(cancelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves metadata about each supported blockchain networks, chains, and other systems.
     * @summary Get supported integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public getIntegrations(options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).getIntegrations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of possible routes for swapping one asset for another across multiple exchanges
     * @summary Get a list of routes for a gateway-to-gateway asset transfer
     * @param {string} fromNetworkID The sending DLT Network.
     * @param {string} fromAmount The amount that should be sent including all decimals.
     * @param {string} fromToken The token that should be transferred. Can be the address or the symbol.
     * @param {string} toDLTNetwork The receiving DLT Network.
     * @param {string} toToken The token that should be transferred to. Can be the address or the symbol.
     * @param {string} fromAddress The sending wallet address.
     * @param {string} toAddress The receiving wallet address. If none is provided, the fromAddress will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public getRoutes(fromNetworkID: string, fromAmount: string, fromToken: string, toDLTNetwork: string, toToken: string, fromAddress: string, toAddress: string, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).getRoutes(fromNetworkID, fromAmount, fromToken, toDLTNetwork, toToken, fromAddress, toAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows users to queue intents for transactions based on specified parameters.
     * @summary Submit a transaction intent
     * @param {TransactRequest} transactRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transact(transactRequest: TransactRequest, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transact(transactRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


