// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file ledger/rwset/kvrwset/kv_rwset.proto (package kvrwset, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file ledger/rwset/kvrwset/kv_rwset.proto.
 */
export const file_ledger_rwset_kvrwset_kv_rwset: GenFile = /*@__PURE__*/
  fileDesc("CiNsZWRnZXIvcndzZXQva3Zyd3NldC9rdl9yd3NldC5wcm90bxIHa3Zyd3NldCKzAQoHS1ZSV1NldBIeCgVyZWFkcxgBIAMoCzIPLmt2cndzZXQuS1ZSZWFkEjMKEnJhbmdlX3F1ZXJpZXNfaW5mbxgCIAMoCzIXLmt2cndzZXQuUmFuZ2VRdWVyeUluZm8SIAoGd3JpdGVzGAMgAygLMhAua3Zyd3NldC5LVldyaXRlEjEKD21ldGFkYXRhX3dyaXRlcxgEIAMoCzIYLmt2cndzZXQuS1ZNZXRhZGF0YVdyaXRlIpwBCgtIYXNoZWRSV1NldBIpCgxoYXNoZWRfcmVhZHMYASADKAsyEy5rdnJ3c2V0LktWUmVhZEhhc2gSKwoNaGFzaGVkX3dyaXRlcxgCIAMoCzIULmt2cndzZXQuS1ZXcml0ZUhhc2gSNQoPbWV0YWRhdGFfd3JpdGVzGAMgAygLMhwua3Zyd3NldC5LVk1ldGFkYXRhV3JpdGVIYXNoIjgKBktWUmVhZBILCgNrZXkYASABKAkSIQoHdmVyc2lvbhgCIAEoCzIQLmt2cndzZXQuVmVyc2lvbiI4CgdLVldyaXRlEgsKA2tleRgBIAEoCRIRCglpc19kZWxldGUYAiABKAgSDQoFdmFsdWUYAyABKAwiSQoPS1ZNZXRhZGF0YVdyaXRlEgsKA2tleRgBIAEoCRIpCgdlbnRyaWVzGAIgAygLMhgua3Zyd3NldC5LVk1ldGFkYXRhRW50cnkiQQoKS1ZSZWFkSGFzaBIQCghrZXlfaGFzaBgBIAEoDBIhCgd2ZXJzaW9uGAIgASgLMhAua3Zyd3NldC5WZXJzaW9uIkYKC0tWV3JpdGVIYXNoEhAKCGtleV9oYXNoGAEgASgMEhEKCWlzX2RlbGV0ZRgCIAEoCBISCgp2YWx1ZV9oYXNoGAMgASgMIlIKE0tWTWV0YWRhdGFXcml0ZUhhc2gSEAoIa2V5X2hhc2gYASABKAwSKQoHZW50cmllcxgCIAMoCzIYLmt2cndzZXQuS1ZNZXRhZGF0YUVudHJ5Ii4KD0tWTWV0YWRhdGFFbnRyeRIMCgRuYW1lGAEgASgJEg0KBXZhbHVlGAIgASgMIiwKB1ZlcnNpb24SEQoJYmxvY2tfbnVtGAEgASgEEg4KBnR4X251bRgCIAEoBCLEAQoOUmFuZ2VRdWVyeUluZm8SEQoJc3RhcnRfa2V5GAEgASgJEg8KB2VuZF9rZXkYAiABKAkSFQoNaXRyX2V4aGF1c3RlZBgDIAEoCBIoCglyYXdfcmVhZHMYBCABKAsyEy5rdnJ3c2V0LlF1ZXJ5UmVhZHNIABI/ChNyZWFkc19tZXJrbGVfaGFzaGVzGAUgASgLMiAua3Zyd3NldC5RdWVyeVJlYWRzTWVya2xlU3VtbWFyeUgAQgwKCnJlYWRzX2luZm8iLwoKUXVlcnlSZWFkcxIhCghrdl9yZWFkcxgBIAMoCzIPLmt2cndzZXQuS1ZSZWFkIloKF1F1ZXJ5UmVhZHNNZXJrbGVTdW1tYXJ5EhIKCm1heF9kZWdyZWUYASABKA0SEQoJbWF4X2xldmVsGAIgASgNEhgKEG1heF9sZXZlbF9oYXNoZXMYAyADKAxCcgoyb3JnLmh5cGVybGVkZ2VyLmZhYnJpYy5wcm90b3MubGVkZ2VyLnJ3c2V0Lmt2cndzZXRaPGdpdGh1Yi5jb20vaHlwZXJsZWRnZXIvZmFicmljLXByb3Rvcy1nby9sZWRnZXIvcndzZXQva3Zyd3NldGIGcHJvdG8z");

/**
 * KVRWSet encapsulates the read-write set for a chaincode that operates upon a KV or Document data model
 * This structure is used for both the public data and the private data
 *
 * @generated from message kvrwset.KVRWSet
 */
export type KVRWSet = Message<"kvrwset.KVRWSet"> & {
  /**
   * @generated from field: repeated kvrwset.KVRead reads = 1;
   */
  reads: KVRead[];

  /**
   * @generated from field: repeated kvrwset.RangeQueryInfo range_queries_info = 2;
   */
  rangeQueriesInfo: RangeQueryInfo[];

  /**
   * @generated from field: repeated kvrwset.KVWrite writes = 3;
   */
  writes: KVWrite[];

  /**
   * @generated from field: repeated kvrwset.KVMetadataWrite metadata_writes = 4;
   */
  metadataWrites: KVMetadataWrite[];
};

/**
 * Describes the message kvrwset.KVRWSet.
 * Use `create(KVRWSetSchema)` to create a new message.
 */
export const KVRWSetSchema: GenMessage<KVRWSet> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 0);

/**
 * HashedRWSet encapsulates hashed representation of a private read-write set for KV or Document data model
 *
 * @generated from message kvrwset.HashedRWSet
 */
export type HashedRWSet = Message<"kvrwset.HashedRWSet"> & {
  /**
   * @generated from field: repeated kvrwset.KVReadHash hashed_reads = 1;
   */
  hashedReads: KVReadHash[];

  /**
   * @generated from field: repeated kvrwset.KVWriteHash hashed_writes = 2;
   */
  hashedWrites: KVWriteHash[];

  /**
   * @generated from field: repeated kvrwset.KVMetadataWriteHash metadata_writes = 3;
   */
  metadataWrites: KVMetadataWriteHash[];
};

/**
 * Describes the message kvrwset.HashedRWSet.
 * Use `create(HashedRWSetSchema)` to create a new message.
 */
export const HashedRWSetSchema: GenMessage<HashedRWSet> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 1);

/**
 * KVRead captures a read operation performed during transaction simulation
 * A 'nil' version indicates a non-existing key read by the transaction
 *
 * @generated from message kvrwset.KVRead
 */
export type KVRead = Message<"kvrwset.KVRead"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * @generated from field: kvrwset.Version version = 2;
   */
  version?: Version;
};

/**
 * Describes the message kvrwset.KVRead.
 * Use `create(KVReadSchema)` to create a new message.
 */
export const KVReadSchema: GenMessage<KVRead> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 2);

/**
 * KVWrite captures a write (update/delete) operation performed during transaction simulation
 *
 * @generated from message kvrwset.KVWrite
 */
export type KVWrite = Message<"kvrwset.KVWrite"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * @generated from field: bool is_delete = 2;
   */
  isDelete: boolean;

  /**
   * @generated from field: bytes value = 3;
   */
  value: Uint8Array;
};

/**
 * Describes the message kvrwset.KVWrite.
 * Use `create(KVWriteSchema)` to create a new message.
 */
export const KVWriteSchema: GenMessage<KVWrite> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 3);

/**
 * KVMetadataWrite captures all the entries in the metadata associated with a key
 *
 * @generated from message kvrwset.KVMetadataWrite
 */
export type KVMetadataWrite = Message<"kvrwset.KVMetadataWrite"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * @generated from field: repeated kvrwset.KVMetadataEntry entries = 2;
   */
  entries: KVMetadataEntry[];
};

/**
 * Describes the message kvrwset.KVMetadataWrite.
 * Use `create(KVMetadataWriteSchema)` to create a new message.
 */
export const KVMetadataWriteSchema: GenMessage<KVMetadataWrite> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 4);

/**
 * KVReadHash is similar to the KVRead in spirit. However, it captures the hash of the key instead of the key itself
 * version is kept as is for now. However, if the version also needs to be privacy-protected, it would need to be the
 * hash of the version and hence of 'bytes' type
 *
 * @generated from message kvrwset.KVReadHash
 */
export type KVReadHash = Message<"kvrwset.KVReadHash"> & {
  /**
   * @generated from field: bytes key_hash = 1;
   */
  keyHash: Uint8Array;

  /**
   * @generated from field: kvrwset.Version version = 2;
   */
  version?: Version;
};

/**
 * Describes the message kvrwset.KVReadHash.
 * Use `create(KVReadHashSchema)` to create a new message.
 */
export const KVReadHashSchema: GenMessage<KVReadHash> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 5);

/**
 * KVWriteHash is similar to the KVWrite. It captures a write (update/delete) operation performed during transaction simulation
 *
 * @generated from message kvrwset.KVWriteHash
 */
export type KVWriteHash = Message<"kvrwset.KVWriteHash"> & {
  /**
   * @generated from field: bytes key_hash = 1;
   */
  keyHash: Uint8Array;

  /**
   * @generated from field: bool is_delete = 2;
   */
  isDelete: boolean;

  /**
   * @generated from field: bytes value_hash = 3;
   */
  valueHash: Uint8Array;
};

/**
 * Describes the message kvrwset.KVWriteHash.
 * Use `create(KVWriteHashSchema)` to create a new message.
 */
export const KVWriteHashSchema: GenMessage<KVWriteHash> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 6);

/**
 * KVMetadataWriteHash captures all the upserts to the metadata associated with a key hash
 *
 * @generated from message kvrwset.KVMetadataWriteHash
 */
export type KVMetadataWriteHash = Message<"kvrwset.KVMetadataWriteHash"> & {
  /**
   * @generated from field: bytes key_hash = 1;
   */
  keyHash: Uint8Array;

  /**
   * @generated from field: repeated kvrwset.KVMetadataEntry entries = 2;
   */
  entries: KVMetadataEntry[];
};

/**
 * Describes the message kvrwset.KVMetadataWriteHash.
 * Use `create(KVMetadataWriteHashSchema)` to create a new message.
 */
export const KVMetadataWriteHashSchema: GenMessage<KVMetadataWriteHash> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 7);

/**
 * KVMetadataEntry captures a 'name'ed entry in the metadata of a key/key-hash.
 *
 * @generated from message kvrwset.KVMetadataEntry
 */
export type KVMetadataEntry = Message<"kvrwset.KVMetadataEntry"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bytes value = 2;
   */
  value: Uint8Array;
};

/**
 * Describes the message kvrwset.KVMetadataEntry.
 * Use `create(KVMetadataEntrySchema)` to create a new message.
 */
export const KVMetadataEntrySchema: GenMessage<KVMetadataEntry> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 8);

/**
 * Version encapsulates the version of a Key
 * A version of a committed key is maintained as the height of the transaction that committed the key.
 * The height is represenetd as a tuple <blockNum, txNum> where the txNum is the position of the transaction
 * (starting with 0) within block
 *
 * @generated from message kvrwset.Version
 */
export type Version = Message<"kvrwset.Version"> & {
  /**
   * @generated from field: uint64 block_num = 1;
   */
  blockNum: bigint;

  /**
   * @generated from field: uint64 tx_num = 2;
   */
  txNum: bigint;
};

/**
 * Describes the message kvrwset.Version.
 * Use `create(VersionSchema)` to create a new message.
 */
export const VersionSchema: GenMessage<Version> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 9);

/**
 * RangeQueryInfo encapsulates the details of a range query performed by a transaction during simulation.
 * This helps protect transactions from phantom reads by varifying during validation whether any new items
 * got committed within the given range between transaction simuation and validation
 * (in addition to regular checks for updates/deletes of the existing items).
 * readInfo field contains either the KVReads (for the items read by the range query) or a merkle-tree hash
 * if the KVReads exceeds a pre-configured numbers
 *
 * @generated from message kvrwset.RangeQueryInfo
 */
export type RangeQueryInfo = Message<"kvrwset.RangeQueryInfo"> & {
  /**
   * @generated from field: string start_key = 1;
   */
  startKey: string;

  /**
   * @generated from field: string end_key = 2;
   */
  endKey: string;

  /**
   * @generated from field: bool itr_exhausted = 3;
   */
  itrExhausted: boolean;

  /**
   * @generated from oneof kvrwset.RangeQueryInfo.reads_info
   */
  readsInfo: {
    /**
     * @generated from field: kvrwset.QueryReads raw_reads = 4;
     */
    value: QueryReads;
    case: "rawReads";
  } | {
    /**
     * @generated from field: kvrwset.QueryReadsMerkleSummary reads_merkle_hashes = 5;
     */
    value: QueryReadsMerkleSummary;
    case: "readsMerkleHashes";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message kvrwset.RangeQueryInfo.
 * Use `create(RangeQueryInfoSchema)` to create a new message.
 */
export const RangeQueryInfoSchema: GenMessage<RangeQueryInfo> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 10);

/**
 * QueryReads encapsulates the KVReads for the items read by a transaction as a result of a query execution
 *
 * @generated from message kvrwset.QueryReads
 */
export type QueryReads = Message<"kvrwset.QueryReads"> & {
  /**
   * @generated from field: repeated kvrwset.KVRead kv_reads = 1;
   */
  kvReads: KVRead[];
};

/**
 * Describes the message kvrwset.QueryReads.
 * Use `create(QueryReadsSchema)` to create a new message.
 */
export const QueryReadsSchema: GenMessage<QueryReads> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 11);

/**
 * QueryReadsMerkleSummary encapsulates the Merkle-tree hashes for the QueryReads
 * This allows to reduce the size of RWSet in the presence of query results
 * by storing certain hashes instead of actual results.
 * maxDegree field refers to the maximum number of children in the tree at any level
 * maxLevel field contains the lowest level which has lesser nodes than maxDegree (starting from leaf level)
 *
 * @generated from message kvrwset.QueryReadsMerkleSummary
 */
export type QueryReadsMerkleSummary = Message<"kvrwset.QueryReadsMerkleSummary"> & {
  /**
   * @generated from field: uint32 max_degree = 1;
   */
  maxDegree: number;

  /**
   * @generated from field: uint32 max_level = 2;
   */
  maxLevel: number;

  /**
   * @generated from field: repeated bytes max_level_hashes = 3;
   */
  maxLevelHashes: Uint8Array[];
};

/**
 * Describes the message kvrwset.QueryReadsMerkleSummary.
 * Use `create(QueryReadsMerkleSummarySchema)` to create a new message.
 */
export const QueryReadsMerkleSummarySchema: GenMessage<QueryReadsMerkleSummary> = /*@__PURE__*/
  messageDesc(file_ledger_rwset_kvrwset_kv_rwset, 12);

