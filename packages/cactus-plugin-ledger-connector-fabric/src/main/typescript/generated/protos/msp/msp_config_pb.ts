// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file msp/msp_config.proto (package msp, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file msp/msp_config.proto.
 */
export const file_msp_msp_config: GenFile = /*@__PURE__*/
  fileDesc("ChRtc3AvbXNwX2NvbmZpZy5wcm90bxIDbXNwIikKCU1TUENvbmZpZxIMCgR0eXBlGAEgASgFEg4KBmNvbmZpZxgCIAEoDCKDAwoPRmFicmljTVNQQ29uZmlnEgwKBG5hbWUYASABKAkSEgoKcm9vdF9jZXJ0cxgCIAMoDBIaChJpbnRlcm1lZGlhdGVfY2VydHMYAyADKAwSDgoGYWRtaW5zGAQgAygMEhcKD3Jldm9jYXRpb25fbGlzdBgFIAMoDBIyChBzaWduaW5nX2lkZW50aXR5GAYgASgLMhgubXNwLlNpZ25pbmdJZGVudGl0eUluZm8SQAofb3JnYW5pemF0aW9uYWxfdW5pdF9pZGVudGlmaWVycxgHIAMoCzIXLm1zcC5GYWJyaWNPVUlkZW50aWZpZXISLgoNY3J5cHRvX2NvbmZpZxgIIAEoCzIXLm1zcC5GYWJyaWNDcnlwdG9Db25maWcSFgoOdGxzX3Jvb3RfY2VydHMYCSADKAwSHgoWdGxzX2ludGVybWVkaWF0ZV9jZXJ0cxgKIAMoDBIrCg9mYWJyaWNfbm9kZV9vdXMYCyABKAsyEi5tc3AuRmFicmljTm9kZU9VcyJeChJGYWJyaWNDcnlwdG9Db25maWcSHQoVc2lnbmF0dXJlX2hhc2hfZmFtaWx5GAEgASgJEikKIWlkZW50aXR5X2lkZW50aWZpZXJfaGFzaF9mdW5jdGlvbhgCIAEoCSJ+Cg9JZGVtaXhNU1BDb25maWcSDAoEbmFtZRgBIAEoCRILCgNpcGsYAiABKAwSKgoGc2lnbmVyGAMgASgLMhoubXNwLklkZW1peE1TUFNpZ25lckNvbmZpZxIVCg1yZXZvY2F0aW9uX3BrGAQgASgMEg0KBWVwb2NoGAUgASgDIqkBChVJZGVtaXhNU1BTaWduZXJDb25maWcSDAoEY3JlZBgBIAEoDBIKCgJzaxgCIAEoDBImCh5vcmdhbml6YXRpb25hbF91bml0X2lkZW50aWZpZXIYAyABKAkSDAoEcm9sZRgEIAEoBRIVCg1lbnJvbGxtZW50X2lkGAUgASgJEikKIWNyZWRlbnRpYWxfcmV2b2NhdGlvbl9pbmZvcm1hdGlvbhgGIAEoDCJSChNTaWduaW5nSWRlbnRpdHlJbmZvEhUKDXB1YmxpY19zaWduZXIYASABKAwSJAoOcHJpdmF0ZV9zaWduZXIYAiABKAsyDC5tc3AuS2V5SW5mbyI3CgdLZXlJbmZvEhYKDmtleV9pZGVudGlmaWVyGAEgASgJEhQKDGtleV9tYXRlcmlhbBgCIAEoDCJRChJGYWJyaWNPVUlkZW50aWZpZXISEwoLY2VydGlmaWNhdGUYASABKAwSJgoeb3JnYW5pemF0aW9uYWxfdW5pdF9pZGVudGlmaWVyGAIgASgJIvkBCg1GYWJyaWNOb2RlT1VzEg4KBmVuYWJsZRgBIAEoCBI1ChRjbGllbnRfb3VfaWRlbnRpZmllchgCIAEoCzIXLm1zcC5GYWJyaWNPVUlkZW50aWZpZXISMwoScGVlcl9vdV9pZGVudGlmaWVyGAMgASgLMhcubXNwLkZhYnJpY09VSWRlbnRpZmllchI0ChNhZG1pbl9vdV9pZGVudGlmaWVyGAQgASgLMhcubXNwLkZhYnJpY09VSWRlbnRpZmllchI2ChVvcmRlcmVyX291X2lkZW50aWZpZXIYBSABKAsyFy5tc3AuRmFicmljT1VJZGVudGlmaWVyQmIKIW9yZy5oeXBlcmxlZGdlci5mYWJyaWMucHJvdG9zLm1zcEIQTXNwQ29uZmlnUGFja2FnZVorZ2l0aHViLmNvbS9oeXBlcmxlZGdlci9mYWJyaWMtcHJvdG9zLWdvL21zcGIGcHJvdG8z");

/**
 * MSPConfig collects all the configuration information for
 * an MSP. The Config field should be unmarshalled in a way
 * that depends on the Type
 *
 * @generated from message msp.MSPConfig
 */
export type MSPConfig = Message<"msp.MSPConfig"> & {
  /**
   * Type holds the type of the MSP; the default one would
   * be of type FABRIC implementing an X.509 based provider
   *
   * @generated from field: int32 type = 1;
   */
  type: number;

  /**
   * Config is MSP dependent configuration info
   *
   * @generated from field: bytes config = 2;
   */
  config: Uint8Array;
};

/**
 * Describes the message msp.MSPConfig.
 * Use `create(MSPConfigSchema)` to create a new message.
 */
export const MSPConfigSchema: GenMessage<MSPConfig> = /*@__PURE__*/
  messageDesc(file_msp_msp_config, 0);

/**
 * FabricMSPConfig collects all the configuration information for
 * a Fabric MSP.
 * Here we assume a default certificate validation policy, where
 * any certificate signed by any of the listed rootCA certs would
 * be considered as valid under this MSP.
 * This MSP may or may not come with a signing identity. If it does,
 * it can also issue signing identities. If it does not, it can only
 * be used to validate and verify certificates.
 *
 * @generated from message msp.FabricMSPConfig
 */
export type FabricMSPConfig = Message<"msp.FabricMSPConfig"> & {
  /**
   * Name holds the identifier of the MSP; MSP identifier
   * is chosen by the application that governs this MSP.
   * For example, and assuming the default implementation of MSP,
   * that is X.509-based and considers a single Issuer,
   * this can refer to the Subject OU field or the Issuer OU field.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * List of root certificates trusted by this MSP
   * they are used upon certificate validation (see
   * comment for IntermediateCerts below)
   *
   * @generated from field: repeated bytes root_certs = 2;
   */
  rootCerts: Uint8Array[];

  /**
   * List of intermediate certificates trusted by this MSP;
   * they are used upon certificate validation as follows:
   * validation attempts to build a path from the certificate
   * to be validated (which is at one end of the path) and
   * one of the certs in the RootCerts field (which is at
   * the other end of the path). If the path is longer than
   * 2, certificates in the middle are searched within the
   * IntermediateCerts pool
   *
   * @generated from field: repeated bytes intermediate_certs = 3;
   */
  intermediateCerts: Uint8Array[];

  /**
   * Identity denoting the administrator of this MSP
   *
   * @generated from field: repeated bytes admins = 4;
   */
  admins: Uint8Array[];

  /**
   * Identity revocation list
   *
   * @generated from field: repeated bytes revocation_list = 5;
   */
  revocationList: Uint8Array[];

  /**
   * SigningIdentity holds information on the signing identity
   * this peer is to use, and which is to be imported by the
   * MSP defined before
   *
   * @generated from field: msp.SigningIdentityInfo signing_identity = 6;
   */
  signingIdentity?: SigningIdentityInfo;

  /**
   * OrganizationalUnitIdentifiers holds one or more
   * fabric organizational unit identifiers that belong to
   * this MSP configuration
   *
   * @generated from field: repeated msp.FabricOUIdentifier organizational_unit_identifiers = 7;
   */
  organizationalUnitIdentifiers: FabricOUIdentifier[];

  /**
   * FabricCryptoConfig contains the configuration parameters
   * for the cryptographic algorithms used by this MSP
   *
   * @generated from field: msp.FabricCryptoConfig crypto_config = 8;
   */
  cryptoConfig?: FabricCryptoConfig;

  /**
   * List of TLS root certificates trusted by this MSP.
   * They are returned by GetTLSRootCerts.
   *
   * @generated from field: repeated bytes tls_root_certs = 9;
   */
  tlsRootCerts: Uint8Array[];

  /**
   * List of TLS intermediate certificates trusted by this MSP;
   * They are returned by GetTLSIntermediateCerts.
   *
   * @generated from field: repeated bytes tls_intermediate_certs = 10;
   */
  tlsIntermediateCerts: Uint8Array[];

  /**
   * fabric_node_ous contains the configuration to distinguish clients from peers from orderers
   * based on the OUs.
   *
   * @generated from field: msp.FabricNodeOUs fabric_node_ous = 11;
   */
  fabricNodeOus?: FabricNodeOUs;
};

/**
 * Describes the message msp.FabricMSPConfig.
 * Use `create(FabricMSPConfigSchema)` to create a new message.
 */
export const FabricMSPConfigSchema: GenMessage<FabricMSPConfig> = /*@__PURE__*/
  messageDesc(file_msp_msp_config, 1);

/**
 * FabricCryptoConfig contains configuration parameters
 * for the cryptographic algorithms used by the MSP
 * this configuration refers to
 *
 * @generated from message msp.FabricCryptoConfig
 */
export type FabricCryptoConfig = Message<"msp.FabricCryptoConfig"> & {
  /**
   * SignatureHashFamily is a string representing the hash family to be used
   * during sign and verify operations.
   * Allowed values are "SHA2" and "SHA3".
   *
   * @generated from field: string signature_hash_family = 1;
   */
  signatureHashFamily: string;

  /**
   * IdentityIdentifierHashFunction is a string representing the hash function
   * to be used during the computation of the identity identifier of an MSP identity.
   * Allowed values are "SHA256", "SHA384" and "SHA3_256", "SHA3_384".
   *
   * @generated from field: string identity_identifier_hash_function = 2;
   */
  identityIdentifierHashFunction: string;
};

/**
 * Describes the message msp.FabricCryptoConfig.
 * Use `create(FabricCryptoConfigSchema)` to create a new message.
 */
export const FabricCryptoConfigSchema: GenMessage<FabricCryptoConfig> = /*@__PURE__*/
  messageDesc(file_msp_msp_config, 2);

/**
 * IdemixMSPConfig collects all the configuration information for
 * an Idemix MSP.
 *
 * @generated from message msp.IdemixMSPConfig
 */
export type IdemixMSPConfig = Message<"msp.IdemixMSPConfig"> & {
  /**
   * Name holds the identifier of the MSP
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * ipk represents the (serialized) issuer public key
   *
   * @generated from field: bytes ipk = 2;
   */
  ipk: Uint8Array;

  /**
   * signer may contain crypto material to configure a default signer
   *
   * @generated from field: msp.IdemixMSPSignerConfig signer = 3;
   */
  signer?: IdemixMSPSignerConfig;

  /**
   * revocation_pk is the public key used for revocation of credentials
   *
   * @generated from field: bytes revocation_pk = 4;
   */
  revocationPk: Uint8Array;

  /**
   * epoch represents the current epoch (time interval) used for revocation
   *
   * @generated from field: int64 epoch = 5;
   */
  epoch: bigint;
};

/**
 * Describes the message msp.IdemixMSPConfig.
 * Use `create(IdemixMSPConfigSchema)` to create a new message.
 */
export const IdemixMSPConfigSchema: GenMessage<IdemixMSPConfig> = /*@__PURE__*/
  messageDesc(file_msp_msp_config, 3);

/**
 * IdemixMSPSIgnerConfig contains the crypto material to set up an idemix signing identity
 *
 * @generated from message msp.IdemixMSPSignerConfig
 */
export type IdemixMSPSignerConfig = Message<"msp.IdemixMSPSignerConfig"> & {
  /**
   * cred represents the serialized idemix credential of the default signer
   *
   * @generated from field: bytes cred = 1;
   */
  cred: Uint8Array;

  /**
   * sk is the secret key of the default signer, corresponding to credential Cred
   *
   * @generated from field: bytes sk = 2;
   */
  sk: Uint8Array;

  /**
   * organizational_unit_identifier defines the organizational unit the default signer is in
   *
   * @generated from field: string organizational_unit_identifier = 3;
   */
  organizationalUnitIdentifier: string;

  /**
   * role defines whether the default signer is admin, peer, member or client
   *
   * @generated from field: int32 role = 4;
   */
  role: number;

  /**
   * enrollment_id contains the enrollment id of this signer
   *
   * @generated from field: string enrollment_id = 5;
   */
  enrollmentId: string;

  /**
   * credential_revocation_information contains a serialized CredentialRevocationInformation
   *
   * @generated from field: bytes credential_revocation_information = 6;
   */
  credentialRevocationInformation: Uint8Array;
};

/**
 * Describes the message msp.IdemixMSPSignerConfig.
 * Use `create(IdemixMSPSignerConfigSchema)` to create a new message.
 */
export const IdemixMSPSignerConfigSchema: GenMessage<IdemixMSPSignerConfig> = /*@__PURE__*/
  messageDesc(file_msp_msp_config, 4);

/**
 * SigningIdentityInfo represents the configuration information
 * related to the signing identity the peer is to use for generating
 * endorsements
 *
 * @generated from message msp.SigningIdentityInfo
 */
export type SigningIdentityInfo = Message<"msp.SigningIdentityInfo"> & {
  /**
   * PublicSigner carries the public information of the signing
   * identity. For an X.509 provider this would be represented by
   * an X.509 certificate
   *
   * @generated from field: bytes public_signer = 1;
   */
  publicSigner: Uint8Array;

  /**
   * PrivateSigner denotes a reference to the private key of the
   * peer's signing identity
   *
   * @generated from field: msp.KeyInfo private_signer = 2;
   */
  privateSigner?: KeyInfo;
};

/**
 * Describes the message msp.SigningIdentityInfo.
 * Use `create(SigningIdentityInfoSchema)` to create a new message.
 */
export const SigningIdentityInfoSchema: GenMessage<SigningIdentityInfo> = /*@__PURE__*/
  messageDesc(file_msp_msp_config, 5);

/**
 * KeyInfo represents a (secret) key that is either already stored
 * in the bccsp/keystore or key material to be imported to the
 * bccsp key-store. In later versions it may contain also a
 * keystore identifier
 *
 * @generated from message msp.KeyInfo
 */
export type KeyInfo = Message<"msp.KeyInfo"> & {
  /**
   * Identifier of the key inside the default keystore; this for
   * the case of Software BCCSP as well as the HSM BCCSP would be
   * the SKI of the key
   *
   * @generated from field: string key_identifier = 1;
   */
  keyIdentifier: string;

  /**
   * KeyMaterial (optional) for the key to be imported; this is
   * properly encoded key bytes, prefixed by the type of the key
   *
   * @generated from field: bytes key_material = 2;
   */
  keyMaterial: Uint8Array;
};

/**
 * Describes the message msp.KeyInfo.
 * Use `create(KeyInfoSchema)` to create a new message.
 */
export const KeyInfoSchema: GenMessage<KeyInfo> = /*@__PURE__*/
  messageDesc(file_msp_msp_config, 6);

/**
 * FabricOUIdentifier represents an organizational unit and
 * its related chain of trust identifier.
 *
 * @generated from message msp.FabricOUIdentifier
 */
export type FabricOUIdentifier = Message<"msp.FabricOUIdentifier"> & {
  /**
   * Certificate represents the second certificate in a certification chain.
   * (Notice that the first certificate in a certification chain is supposed
   * to be the certificate of an identity).
   * It must correspond to the certificate of root or intermediate CA
   * recognized by the MSP this message belongs to.
   * Starting from this certificate, a certification chain is computed
   * and bound to the OrganizationUnitIdentifier specified
   *
   * @generated from field: bytes certificate = 1;
   */
  certificate: Uint8Array;

  /**
   * OrganizationUnitIdentifier defines the organizational unit under the
   * MSP identified with MSPIdentifier
   *
   * @generated from field: string organizational_unit_identifier = 2;
   */
  organizationalUnitIdentifier: string;
};

/**
 * Describes the message msp.FabricOUIdentifier.
 * Use `create(FabricOUIdentifierSchema)` to create a new message.
 */
export const FabricOUIdentifierSchema: GenMessage<FabricOUIdentifier> = /*@__PURE__*/
  messageDesc(file_msp_msp_config, 7);

/**
 * FabricNodeOUs contains configuration to tell apart clients from peers from orderers
 * based on OUs. If NodeOUs recognition is enabled then an msp identity
 * that does not contain any of the specified OU will be considered invalid.
 *
 * @generated from message msp.FabricNodeOUs
 */
export type FabricNodeOUs = Message<"msp.FabricNodeOUs"> & {
  /**
   * If true then an msp identity that does not contain any of the specified OU will be considered invalid.
   *
   * @generated from field: bool enable = 1;
   */
  enable: boolean;

  /**
   * OU Identifier of the clients
   *
   * @generated from field: msp.FabricOUIdentifier client_ou_identifier = 2;
   */
  clientOuIdentifier?: FabricOUIdentifier;

  /**
   * OU Identifier of the peers
   *
   * @generated from field: msp.FabricOUIdentifier peer_ou_identifier = 3;
   */
  peerOuIdentifier?: FabricOUIdentifier;

  /**
   * OU Identifier of the admins
   *
   * @generated from field: msp.FabricOUIdentifier admin_ou_identifier = 4;
   */
  adminOuIdentifier?: FabricOUIdentifier;

  /**
   * OU Identifier of the orderers
   *
   * @generated from field: msp.FabricOUIdentifier orderer_ou_identifier = 5;
   */
  ordererOuIdentifier?: FabricOUIdentifier;
};

/**
 * Describes the message msp.FabricNodeOUs.
 * Use `create(FabricNodeOUsSchema)` to create a new message.
 */
export const FabricNodeOUsSchema: GenMessage<FabricNodeOUs> = /*@__PURE__*/
  messageDesc(file_msp_msp_config, 8);

