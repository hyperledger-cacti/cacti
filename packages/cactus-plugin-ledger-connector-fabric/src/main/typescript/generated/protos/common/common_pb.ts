// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file common/common.proto (package common, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file common/common.proto.
 */
export const file_common_common: GenFile = /*@__PURE__*/
  fileDesc("ChNjb21tb24vY29tbW9uLnByb3RvEgZjb21tb24iGwoKTGFzdENvbmZpZxINCgVpbmRleBgBIAEoBCJICghNZXRhZGF0YRINCgV2YWx1ZRgBIAEoDBItCgpzaWduYXR1cmVzGAIgAygLMhkuY29tbW9uLk1ldGFkYXRhU2lnbmF0dXJlIkAKEU1ldGFkYXRhU2lnbmF0dXJlEhgKEHNpZ25hdHVyZV9oZWFkZXIYASABKAwSEQoJc2lnbmF0dXJlGAIgASgMIjoKBkhlYWRlchIWCg5jaGFubmVsX2hlYWRlchgBIAEoDBIYChBzaWduYXR1cmVfaGVhZGVyGAIgASgMIrkBCg1DaGFubmVsSGVhZGVyEgwKBHR5cGUYASABKAUSDwoHdmVyc2lvbhgCIAEoBRItCgl0aW1lc3RhbXAYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhIKCmNoYW5uZWxfaWQYBCABKAkSDQoFdHhfaWQYBSABKAkSDQoFZXBvY2gYBiABKAQSEQoJZXh0ZW5zaW9uGAcgASgMEhUKDXRsc19jZXJ0X2hhc2gYCCABKAwiMQoPU2lnbmF0dXJlSGVhZGVyEg8KB2NyZWF0b3IYASABKAwSDQoFbm9uY2UYAiABKAwiNwoHUGF5bG9hZBIeCgZoZWFkZXIYASABKAsyDi5jb21tb24uSGVhZGVyEgwKBGRhdGEYAiABKAwiLgoIRW52ZWxvcGUSDwoHcGF5bG9hZBgBIAEoDBIRCglzaWduYXR1cmUYAiABKAwidgoFQmxvY2sSIwoGaGVhZGVyGAEgASgLMhMuY29tbW9uLkJsb2NrSGVhZGVyEh8KBGRhdGEYAiABKAsyES5jb21tb24uQmxvY2tEYXRhEicKCG1ldGFkYXRhGAMgASgLMhUuY29tbW9uLkJsb2NrTWV0YWRhdGEiRwoLQmxvY2tIZWFkZXISDgoGbnVtYmVyGAEgASgEEhUKDXByZXZpb3VzX2hhc2gYAiABKAwSEQoJZGF0YV9oYXNoGAMgASgMIhkKCUJsb2NrRGF0YRIMCgRkYXRhGAEgAygMIiEKDUJsb2NrTWV0YWRhdGESEAoIbWV0YWRhdGEYASADKAwiWwoUT3JkZXJlckJsb2NrTWV0YWRhdGESJwoLbGFzdF9jb25maWcYASABKAsyEi5jb21tb24uTGFzdENvbmZpZxIaChJjb25zZW50ZXJfbWV0YWRhdGEYAiABKAwqwAEKBlN0YXR1cxILCgdVTktOT1dOEAASDAoHU1VDQ0VTUxDIARIQCgtCQURfUkVRVUVTVBCQAxIOCglGT1JCSURERU4QkwMSDgoJTk9UX0ZPVU5EEJQDEh0KGFJFUVVFU1RfRU5USVRZX1RPT19MQVJHRRCdAxIaChVJTlRFUk5BTF9TRVJWRVJfRVJST1IQ9AMSFAoPTk9UX0lNUExFTUVOVEVEEPUDEhgKE1NFUlZJQ0VfVU5BVkFJTEFCTEUQ9wMq6AEKCkhlYWRlclR5cGUSCwoHTUVTU0FHRRAAEgoKBkNPTkZJRxABEhEKDUNPTkZJR19VUERBVEUQAhIYChRFTkRPUlNFUl9UUkFOU0FDVElPThADEhcKE09SREVSRVJfVFJBTlNBQ1RJT04QBBIVChFERUxJVkVSX1NFRUtfSU5GTxAFEhUKEUNIQUlOQ09ERV9QQUNLQUdFEAYSGAoUUEVFUl9BRE1JTl9PUEVSQVRJT04QCCIECAcQByIECAkQCSoUUEVFUl9SRVNPVVJDRV9VUERBVEUqEVRPS0VOX1RSQU5TQUNUSU9OKnQKEkJsb2NrTWV0YWRhdGFJbmRleBIOCgpTSUdOQVRVUkVTEAASEwoLTEFTVF9DT05GSUcQARoCCAESFwoTVFJBTlNBQ1RJT05TX0ZJTFRFUhACEg8KB09SREVSRVIQAxoCCAESDwoLQ09NTUlUX0hBU0gQBEJWCiRvcmcuaHlwZXJsZWRnZXIuZmFicmljLnByb3Rvcy5jb21tb25aLmdpdGh1Yi5jb20vaHlwZXJsZWRnZXIvZmFicmljLXByb3Rvcy1nby9jb21tb25iBnByb3RvMw", [file_google_protobuf_timestamp]);

/**
 * LastConfig is the encoded value for the Metadata message which is encoded in the LAST_CONFIGURATION block metadata index
 *
 * @generated from message common.LastConfig
 */
export type LastConfig = Message<"common.LastConfig"> & {
  /**
   * @generated from field: uint64 index = 1;
   */
  index: bigint;
};

/**
 * Describes the message common.LastConfig.
 * Use `create(LastConfigSchema)` to create a new message.
 */
export const LastConfigSchema: GenMessage<LastConfig> = /*@__PURE__*/
  messageDesc(file_common_common, 0);

/**
 * Metadata is a common structure to be used to encode block metadata
 *
 * @generated from message common.Metadata
 */
export type Metadata = Message<"common.Metadata"> & {
  /**
   * @generated from field: bytes value = 1;
   */
  value: Uint8Array;

  /**
   * @generated from field: repeated common.MetadataSignature signatures = 2;
   */
  signatures: MetadataSignature[];
};

/**
 * Describes the message common.Metadata.
 * Use `create(MetadataSchema)` to create a new message.
 */
export const MetadataSchema: GenMessage<Metadata> = /*@__PURE__*/
  messageDesc(file_common_common, 1);

/**
 * @generated from message common.MetadataSignature
 */
export type MetadataSignature = Message<"common.MetadataSignature"> & {
  /**
   * An encoded SignatureHeader
   *
   * @generated from field: bytes signature_header = 1;
   */
  signatureHeader: Uint8Array;

  /**
   * The signature over the concatenation of the Metadata value bytes, signatureHeader, and block header
   *
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;
};

/**
 * Describes the message common.MetadataSignature.
 * Use `create(MetadataSignatureSchema)` to create a new message.
 */
export const MetadataSignatureSchema: GenMessage<MetadataSignature> = /*@__PURE__*/
  messageDesc(file_common_common, 2);

/**
 * @generated from message common.Header
 */
export type Header = Message<"common.Header"> & {
  /**
   * @generated from field: bytes channel_header = 1;
   */
  channelHeader: Uint8Array;

  /**
   * @generated from field: bytes signature_header = 2;
   */
  signatureHeader: Uint8Array;
};

/**
 * Describes the message common.Header.
 * Use `create(HeaderSchema)` to create a new message.
 */
export const HeaderSchema: GenMessage<Header> = /*@__PURE__*/
  messageDesc(file_common_common, 3);

/**
 * Header is a generic replay prevention and identity message to include in a signed payload
 *
 * @generated from message common.ChannelHeader
 */
export type ChannelHeader = Message<"common.ChannelHeader"> & {
  /**
   * Header types 0-10000 are reserved and defined by HeaderType
   *
   * @generated from field: int32 type = 1;
   */
  type: number;

  /**
   * Version indicates message protocol version
   *
   * @generated from field: int32 version = 2;
   */
  version: number;

  /**
   * Timestamp is the local time when the message was created
   * by the sender
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  /**
   * Identifier of the channel this message is bound for
   *
   * @generated from field: string channel_id = 4;
   */
  channelId: string;

  /**
   * An unique identifier that is used end-to-end.
   *  -  set by higher layers such as end user or SDK
   *  -  passed to the endorser (which will check for uniqueness)
   *  -  as the header is passed along unchanged, it will be
   *     be retrieved by the committer (uniqueness check here as well)
   *  -  to be stored in the ledger
   *
   * @generated from field: string tx_id = 5;
   */
  txId: string;

  /**
   * The epoch in which this header was generated, where epoch is defined based on block height
   * Epoch in which the response has been generated. This field identifies a
   * logical window of time. A proposal response is accepted by a peer only if
   * two conditions hold:
   * 1. the epoch specified in the message is the current epoch
   * 2. this message has been only seen once during this epoch (i.e. it hasn't
   *    been replayed)
   *
   * @generated from field: uint64 epoch = 6;
   */
  epoch: bigint;

  /**
   * Extension that may be attached based on the header type
   *
   * @generated from field: bytes extension = 7;
   */
  extension: Uint8Array;

  /**
   * If mutual TLS is employed, this represents
   * the hash of the client's TLS certificate
   *
   * @generated from field: bytes tls_cert_hash = 8;
   */
  tlsCertHash: Uint8Array;
};

/**
 * Describes the message common.ChannelHeader.
 * Use `create(ChannelHeaderSchema)` to create a new message.
 */
export const ChannelHeaderSchema: GenMessage<ChannelHeader> = /*@__PURE__*/
  messageDesc(file_common_common, 4);

/**
 * @generated from message common.SignatureHeader
 */
export type SignatureHeader = Message<"common.SignatureHeader"> & {
  /**
   * Creator of the message, a marshaled msp.SerializedIdentity
   *
   * @generated from field: bytes creator = 1;
   */
  creator: Uint8Array;

  /**
   * Arbitrary number that may only be used once. Can be used to detect replay attacks.
   *
   * @generated from field: bytes nonce = 2;
   */
  nonce: Uint8Array;
};

/**
 * Describes the message common.SignatureHeader.
 * Use `create(SignatureHeaderSchema)` to create a new message.
 */
export const SignatureHeaderSchema: GenMessage<SignatureHeader> = /*@__PURE__*/
  messageDesc(file_common_common, 5);

/**
 * Payload is the message contents (and header to allow for signing)
 *
 * @generated from message common.Payload
 */
export type Payload = Message<"common.Payload"> & {
  /**
   * Header is included to provide identity and prevent replay
   *
   * @generated from field: common.Header header = 1;
   */
  header?: Header;

  /**
   * Data, the encoding of which is defined by the type in the header
   *
   * @generated from field: bytes data = 2;
   */
  data: Uint8Array;
};

/**
 * Describes the message common.Payload.
 * Use `create(PayloadSchema)` to create a new message.
 */
export const PayloadSchema: GenMessage<Payload> = /*@__PURE__*/
  messageDesc(file_common_common, 6);

/**
 * Envelope wraps a Payload with a signature so that the message may be authenticated
 *
 * @generated from message common.Envelope
 */
export type Envelope = Message<"common.Envelope"> & {
  /**
   * A marshaled Payload
   *
   * @generated from field: bytes payload = 1;
   */
  payload: Uint8Array;

  /**
   * A signature by the creator specified in the Payload header
   *
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;
};

/**
 * Describes the message common.Envelope.
 * Use `create(EnvelopeSchema)` to create a new message.
 */
export const EnvelopeSchema: GenMessage<Envelope> = /*@__PURE__*/
  messageDesc(file_common_common, 7);

/**
 * This is finalized block structure to be shared among the orderer and peer
 * Note that the BlockHeader chains to the previous BlockHeader, and the BlockData hash is embedded
 * in the BlockHeader.  This makes it natural and obvious that the Data is included in the hash, but
 * the Metadata is not.
 *
 * @generated from message common.Block
 */
export type Block = Message<"common.Block"> & {
  /**
   * @generated from field: common.BlockHeader header = 1;
   */
  header?: BlockHeader;

  /**
   * @generated from field: common.BlockData data = 2;
   */
  data?: BlockData;

  /**
   * @generated from field: common.BlockMetadata metadata = 3;
   */
  metadata?: BlockMetadata;
};

/**
 * Describes the message common.Block.
 * Use `create(BlockSchema)` to create a new message.
 */
export const BlockSchema: GenMessage<Block> = /*@__PURE__*/
  messageDesc(file_common_common, 8);

/**
 * BlockHeader is the element of the block which forms the block chain
 * The block header is hashed using the configured chain hashing algorithm
 * over the ASN.1 encoding of the BlockHeader
 *
 * @generated from message common.BlockHeader
 */
export type BlockHeader = Message<"common.BlockHeader"> & {
  /**
   * The position in the blockchain
   *
   * @generated from field: uint64 number = 1;
   */
  number: bigint;

  /**
   * The hash of the previous block header
   *
   * @generated from field: bytes previous_hash = 2;
   */
  previousHash: Uint8Array;

  /**
   * The hash of the BlockData, by MerkleTree
   *
   * @generated from field: bytes data_hash = 3;
   */
  dataHash: Uint8Array;
};

/**
 * Describes the message common.BlockHeader.
 * Use `create(BlockHeaderSchema)` to create a new message.
 */
export const BlockHeaderSchema: GenMessage<BlockHeader> = /*@__PURE__*/
  messageDesc(file_common_common, 9);

/**
 * @generated from message common.BlockData
 */
export type BlockData = Message<"common.BlockData"> & {
  /**
   * @generated from field: repeated bytes data = 1;
   */
  data: Uint8Array[];
};

/**
 * Describes the message common.BlockData.
 * Use `create(BlockDataSchema)` to create a new message.
 */
export const BlockDataSchema: GenMessage<BlockData> = /*@__PURE__*/
  messageDesc(file_common_common, 10);

/**
 * @generated from message common.BlockMetadata
 */
export type BlockMetadata = Message<"common.BlockMetadata"> & {
  /**
   * @generated from field: repeated bytes metadata = 1;
   */
  metadata: Uint8Array[];
};

/**
 * Describes the message common.BlockMetadata.
 * Use `create(BlockMetadataSchema)` to create a new message.
 */
export const BlockMetadataSchema: GenMessage<BlockMetadata> = /*@__PURE__*/
  messageDesc(file_common_common, 11);

/**
 * OrdererBlockMetadata defines metadata that is set by the ordering service.
 *
 * @generated from message common.OrdererBlockMetadata
 */
export type OrdererBlockMetadata = Message<"common.OrdererBlockMetadata"> & {
  /**
   * @generated from field: common.LastConfig last_config = 1;
   */
  lastConfig?: LastConfig;

  /**
   * @generated from field: bytes consenter_metadata = 2;
   */
  consenterMetadata: Uint8Array;
};

/**
 * Describes the message common.OrdererBlockMetadata.
 * Use `create(OrdererBlockMetadataSchema)` to create a new message.
 */
export const OrdererBlockMetadataSchema: GenMessage<OrdererBlockMetadata> = /*@__PURE__*/
  messageDesc(file_common_common, 12);

/**
 * These status codes are intended to resemble selected HTTP status codes
 *
 * @generated from enum common.Status
 */
export enum Status {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: SUCCESS = 200;
   */
  SUCCESS = 200,

  /**
   * @generated from enum value: BAD_REQUEST = 400;
   */
  BAD_REQUEST = 400,

  /**
   * @generated from enum value: FORBIDDEN = 403;
   */
  FORBIDDEN = 403,

  /**
   * @generated from enum value: NOT_FOUND = 404;
   */
  NOT_FOUND = 404,

  /**
   * @generated from enum value: REQUEST_ENTITY_TOO_LARGE = 413;
   */
  REQUEST_ENTITY_TOO_LARGE = 413,

  /**
   * @generated from enum value: INTERNAL_SERVER_ERROR = 500;
   */
  INTERNAL_SERVER_ERROR = 500,

  /**
   * @generated from enum value: NOT_IMPLEMENTED = 501;
   */
  NOT_IMPLEMENTED = 501,

  /**
   * @generated from enum value: SERVICE_UNAVAILABLE = 503;
   */
  SERVICE_UNAVAILABLE = 503,
}

/**
 * Describes the enum common.Status.
 */
export const StatusSchema: GenEnum<Status> = /*@__PURE__*/
  enumDesc(file_common_common, 0);

/**
 * @generated from enum common.HeaderType
 */
export enum HeaderType {
  /**
   * Used for messages which are signed but opaque
   *
   * @generated from enum value: MESSAGE = 0;
   */
  MESSAGE = 0,

  /**
   * Used for messages which express the channel config
   *
   * @generated from enum value: CONFIG = 1;
   */
  CONFIG = 1,

  /**
   * Used for transactions which update the channel config
   *
   * @generated from enum value: CONFIG_UPDATE = 2;
   */
  CONFIG_UPDATE = 2,

  /**
   * Used by the SDK to submit endorser based transactions
   *
   * @generated from enum value: ENDORSER_TRANSACTION = 3;
   */
  ENDORSER_TRANSACTION = 3,

  /**
   * Used internally by the orderer for management
   *
   * @generated from enum value: ORDERER_TRANSACTION = 4;
   */
  ORDERER_TRANSACTION = 4,

  /**
   * Used as the type for Envelope messages submitted to instruct the Deliver API to seek
   *
   * @generated from enum value: DELIVER_SEEK_INFO = 5;
   */
  DELIVER_SEEK_INFO = 5,

  /**
   * Used for packaging chaincode artifacts for install
   *
   * @generated from enum value: CHAINCODE_PACKAGE = 6;
   */
  CHAINCODE_PACKAGE = 6,

  /**
   * Used for invoking an administrative operation on a peer
   *
   * @generated from enum value: PEER_ADMIN_OPERATION = 8;
   */
  PEER_ADMIN_OPERATION = 8,
}

/**
 * Describes the enum common.HeaderType.
 */
export const HeaderTypeSchema: GenEnum<HeaderType> = /*@__PURE__*/
  enumDesc(file_common_common, 1);

/**
 * This enum enlists indexes of the block metadata array
 *
 * @generated from enum common.BlockMetadataIndex
 */
export enum BlockMetadataIndex {
  /**
   * Block metadata array position for block signatures
   *
   * @generated from enum value: SIGNATURES = 0;
   */
  SIGNATURES = 0,

  /**
   * Block metadata array position to store last configuration block sequence number
   *
   * @generated from enum value: LAST_CONFIG = 1 [deprecated = true];
   * @deprecated
   */
  LAST_CONFIG = 1,

  /**
   * Block metadata array position to store serialized bit array filter of invalid transactions
   *
   * @generated from enum value: TRANSACTIONS_FILTER = 2;
   */
  TRANSACTIONS_FILTER = 2,

  /**
   * Block metadata array position to store operational metadata for orderers
   * e.g. For Kafka, this is where we store the last offset written to the local ledger 
   *
   * @generated from enum value: ORDERER = 3 [deprecated = true];
   * @deprecated
   */
  ORDERER = 3,

  /**
   * Block metadata array position to store the hash of TRANSACTIONS_FILTER, State Updates,
   * and the COMMIT_HASH of the previous block 
   *
   * @generated from enum value: COMMIT_HASH = 4;
   */
  COMMIT_HASH = 4,
}

/**
 * Describes the enum common.BlockMetadataIndex.
 */
export const BlockMetadataIndexSchema: GenEnum<BlockMetadataIndex> = /*@__PURE__*/
  enumDesc(file_common_common, 2);

