// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file common/configuration.proto (package common, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file common/configuration.proto.
 */
export const file_common_configuration: GenFile = /*@__PURE__*/
  fileDesc("Chpjb21tb24vY29uZmlndXJhdGlvbi5wcm90bxIGY29tbW9uIiAKEEhhc2hpbmdBbGdvcml0aG0SDAoEbmFtZRgBIAEoCSIqChlCbG9ja0RhdGFIYXNoaW5nU3RydWN0dXJlEg0KBXdpZHRoGAEgASgNIiUKEE9yZGVyZXJBZGRyZXNzZXMSEQoJYWRkcmVzc2VzGAEgAygJIhoKCkNvbnNvcnRpdW0SDAoEbmFtZRgBIAEoCSKVAQoMQ2FwYWJpbGl0aWVzEjwKDGNhcGFiaWxpdGllcxgBIAMoCzImLmNvbW1vbi5DYXBhYmlsaXRpZXMuQ2FwYWJpbGl0aWVzRW50cnkaRwoRQ2FwYWJpbGl0aWVzRW50cnkSCwoDa2V5GAEgASgJEiEKBXZhbHVlGAIgASgLMhIuY29tbW9uLkNhcGFiaWxpdHk6AjgBIgwKCkNhcGFiaWxpdHlCVgokb3JnLmh5cGVybGVkZ2VyLmZhYnJpYy5wcm90b3MuY29tbW9uWi5naXRodWIuY29tL2h5cGVybGVkZ2VyL2ZhYnJpYy1wcm90b3MtZ28vY29tbW9uYgZwcm90bzM");

/**
 * HashingAlgorithm is encoded into the configuration transaction as  a configuration item of type Chain
 * with a Key of "HashingAlgorithm" and a Value of  HashingAlgorithm as marshaled protobuf bytes
 *
 * @generated from message common.HashingAlgorithm
 */
export type HashingAlgorithm = Message<"common.HashingAlgorithm"> & {
  /**
   * Currently supported algorithms are: SHAKE256
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message common.HashingAlgorithm.
 * Use `create(HashingAlgorithmSchema)` to create a new message.
 */
export const HashingAlgorithmSchema: GenMessage<HashingAlgorithm> = /*@__PURE__*/
  messageDesc(file_common_configuration, 0);

/**
 * BlockDataHashingStructure is encoded into the configuration transaction as a configuration item of
 * type Chain with a Key of "BlockDataHashingStructure" and a Value of HashingAlgorithm as marshaled protobuf bytes
 *
 * @generated from message common.BlockDataHashingStructure
 */
export type BlockDataHashingStructure = Message<"common.BlockDataHashingStructure"> & {
  /**
   * width specifies the width of the Merkle tree to use when computing the BlockDataHash
   * in order to replicate flat hashing, set this width to MAX_UINT32
   *
   * @generated from field: uint32 width = 1;
   */
  width: number;
};

/**
 * Describes the message common.BlockDataHashingStructure.
 * Use `create(BlockDataHashingStructureSchema)` to create a new message.
 */
export const BlockDataHashingStructureSchema: GenMessage<BlockDataHashingStructure> = /*@__PURE__*/
  messageDesc(file_common_configuration, 1);

/**
 * OrdererAddresses is encoded into the configuration transaction as a configuration item of type Chain
 * with a Key of "OrdererAddresses" and a Value of OrdererAddresses as marshaled protobuf bytes
 *
 * @generated from message common.OrdererAddresses
 */
export type OrdererAddresses = Message<"common.OrdererAddresses"> & {
  /**
   * @generated from field: repeated string addresses = 1;
   */
  addresses: string[];
};

/**
 * Describes the message common.OrdererAddresses.
 * Use `create(OrdererAddressesSchema)` to create a new message.
 */
export const OrdererAddressesSchema: GenMessage<OrdererAddresses> = /*@__PURE__*/
  messageDesc(file_common_configuration, 2);

/**
 * Consortium represents the consortium context in which the channel was created
 *
 * @generated from message common.Consortium
 */
export type Consortium = Message<"common.Consortium"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message common.Consortium.
 * Use `create(ConsortiumSchema)` to create a new message.
 */
export const ConsortiumSchema: GenMessage<Consortium> = /*@__PURE__*/
  messageDesc(file_common_configuration, 3);

/**
 * Capabilities message defines the capabilities a particular binary must implement
 * for that binary to be able to safely participate in the channel.  The capabilities
 * message is defined at the /Channel level, the /Channel/Application level, and the
 * /Channel/Orderer level.
 *
 * The /Channel level capabilties define capabilities which both the orderer and peer
 * binaries must satisfy.  These capabilties might be things like a new MSP type,
 * or a new policy type.
 *
 * The /Channel/Orderer level capabilties define capabilities which must be supported
 * by the orderer, but which have no bearing on the behavior of the peer.  For instance
 * if the orderer changes the logic for how it constructs new channels, only all orderers
 * must agree on the new logic.  The peers do not need to be aware of this change as
 * they only interact with the channel after it has been constructed.
 *
 * Finally, the /Channel/Application level capabilities define capabilities which the peer
 * binary must satisfy, but which have no bearing on the orderer.  For instance, if the
 * peer adds a new UTXO transaction type, or changes the chaincode lifecycle requirements,
 * all peers must agree on the new logic.  However, orderers never inspect transactions
 * this deeply, and therefore have no need to be aware of the change.
 *
 * The capabilities strings defined in these messages typically correspond to release
 * binary versions (e.g. "V1.1"), and are used primarilly as a mechanism for a fully
 * upgraded network to switch from one set of logic to a new one.
 *
 * Although for V1.1, the orderers must be upgraded to V1.1 prior to the rest of the
 * network, going forward, because of the split between the /Channel, /Channel/Orderer
 * and /Channel/Application capabilities.  It should be possible for the orderer and
 * application networks to upgrade themselves independently (with the exception of any
 * new capabilities defined at the /Channel level).
 *
 * @generated from message common.Capabilities
 */
export type Capabilities = Message<"common.Capabilities"> & {
  /**
   * @generated from field: map<string, common.Capability> capabilities = 1;
   */
  capabilities: { [key: string]: Capability };
};

/**
 * Describes the message common.Capabilities.
 * Use `create(CapabilitiesSchema)` to create a new message.
 */
export const CapabilitiesSchema: GenMessage<Capabilities> = /*@__PURE__*/
  messageDesc(file_common_configuration, 4);

/**
 * Capability is an empty message for the time being.  It is defined as a protobuf
 * message rather than a constant, so that we may extend capabilities with other fields
 * if the need arises in the future.  For the time being, a capability being in the
 * capabilities map requires that that capability be supported.
 *
 * @generated from message common.Capability
 */
export type Capability = Message<"common.Capability"> & {
};

/**
 * Describes the message common.Capability.
 * Use `create(CapabilitySchema)` to create a new message.
 */
export const CapabilitySchema: GenMessage<Capability> = /*@__PURE__*/
  messageDesc(file_common_configuration, 5);

