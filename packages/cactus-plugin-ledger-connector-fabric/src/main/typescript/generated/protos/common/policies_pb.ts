// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file common/policies.proto (package common, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { MSPPrincipal } from "../msp/msp_principal_pb";
import { file_msp_msp_principal } from "../msp/msp_principal_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file common/policies.proto.
 */
export const file_common_policies: GenFile = /*@__PURE__*/
  fileDesc("ChVjb21tb24vcG9saWNpZXMucHJvdG8SBmNvbW1vbiJrCgZQb2xpY3kSDAoEdHlwZRgBIAEoBRINCgV2YWx1ZRgCIAEoDCJECgpQb2xpY3lUeXBlEgsKB1VOS05PV04QABINCglTSUdOQVRVUkUQARIHCgNNU1AQAhIRCg1JTVBMSUNJVF9NRVRBEAMiewoXU2lnbmF0dXJlUG9saWN5RW52ZWxvcGUSDwoHdmVyc2lvbhgBIAEoBRIlCgRydWxlGAIgASgLMhcuY29tbW9uLlNpZ25hdHVyZVBvbGljeRIoCgppZGVudGl0aWVzGAMgAygLMhQuY29tbW9uLk1TUFByaW5jaXBhbCKfAQoPU2lnbmF0dXJlUG9saWN5EhMKCXNpZ25lZF9ieRgBIAEoBUgAEjIKCG5fb3V0X29mGAIgASgLMh4uY29tbW9uLlNpZ25hdHVyZVBvbGljeS5OT3V0T2ZIABo7CgZOT3V0T2YSCQoBbhgBIAEoBRImCgVydWxlcxgCIAMoCzIXLmNvbW1vbi5TaWduYXR1cmVQb2xpY3lCBgoEVHlwZSJ/ChJJbXBsaWNpdE1ldGFQb2xpY3kSEgoKc3ViX3BvbGljeRgBIAEoCRItCgRydWxlGAIgASgOMh8uY29tbW9uLkltcGxpY2l0TWV0YVBvbGljeS5SdWxlIiYKBFJ1bGUSBwoDQU5ZEAASBwoDQUxMEAESDAoITUFKT1JJVFkQAiKHAQoRQXBwbGljYXRpb25Qb2xpY3kSOwoQc2lnbmF0dXJlX3BvbGljeRgBIAEoCzIfLmNvbW1vbi5TaWduYXR1cmVQb2xpY3lFbnZlbG9wZUgAEikKH2NoYW5uZWxfY29uZmlnX3BvbGljeV9yZWZlcmVuY2UYAiABKAlIADoCGAFCBgoEVHlwZUJWCiRvcmcuaHlwZXJsZWRnZXIuZmFicmljLnByb3Rvcy5jb21tb25aLmdpdGh1Yi5jb20vaHlwZXJsZWRnZXIvZmFicmljLXByb3Rvcy1nby9jb21tb25iBnByb3RvMw", [file_msp_msp_principal]);

/**
 * Policy expresses a policy which the orderer can evaluate, because there has been some desire expressed to support
 * multiple policy engines, this is typed as a oneof for now
 *
 * @generated from message common.Policy
 */
export type Policy = Message<"common.Policy"> & {
  /**
   * For outside implementors, consider the first 1000 types reserved, otherwise one of PolicyType
   *
   * @generated from field: int32 type = 1;
   */
  type: number;

  /**
   * @generated from field: bytes value = 2;
   */
  value: Uint8Array;
};

/**
 * Describes the message common.Policy.
 * Use `create(PolicySchema)` to create a new message.
 */
export const PolicySchema: GenMessage<Policy> = /*@__PURE__*/
  messageDesc(file_common_policies, 0);

/**
 * @generated from enum common.Policy.PolicyType
 */
export enum Policy_PolicyType {
  /**
   * Reserved to check for proper initialization
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: SIGNATURE = 1;
   */
  SIGNATURE = 1,

  /**
   * @generated from enum value: MSP = 2;
   */
  MSP = 2,

  /**
   * @generated from enum value: IMPLICIT_META = 3;
   */
  IMPLICIT_META = 3,
}

/**
 * Describes the enum common.Policy.PolicyType.
 */
export const Policy_PolicyTypeSchema: GenEnum<Policy_PolicyType> = /*@__PURE__*/
  enumDesc(file_common_policies, 0, 0);

/**
 * SignaturePolicyEnvelope wraps a SignaturePolicy and includes a version for future enhancements
 *
 * @generated from message common.SignaturePolicyEnvelope
 */
export type SignaturePolicyEnvelope = Message<"common.SignaturePolicyEnvelope"> & {
  /**
   * @generated from field: int32 version = 1;
   */
  version: number;

  /**
   * @generated from field: common.SignaturePolicy rule = 2;
   */
  rule?: SignaturePolicy;

  /**
   * @generated from field: repeated common.MSPPrincipal identities = 3;
   */
  identities: MSPPrincipal[];
};

/**
 * Describes the message common.SignaturePolicyEnvelope.
 * Use `create(SignaturePolicyEnvelopeSchema)` to create a new message.
 */
export const SignaturePolicyEnvelopeSchema: GenMessage<SignaturePolicyEnvelope> = /*@__PURE__*/
  messageDesc(file_common_policies, 1);

/**
 * SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing
 * policies which are more complicated than 'exactly this signature'.  The NOutOf operator is sufficent
 * to express AND as well as OR, as well as of course N out of the following M policies
 * SignedBy implies that the signature is from a valid certificate which is signed by the trusted
 * authority specified in the bytes.  This will be the certificate itself for a self-signed certificate
 * and will be the CA for more traditional certificates
 *
 * @generated from message common.SignaturePolicy
 */
export type SignaturePolicy = Message<"common.SignaturePolicy"> & {
  /**
   * @generated from oneof common.SignaturePolicy.Type
   */
  Type: {
    /**
     * @generated from field: int32 signed_by = 1;
     */
    value: number;
    case: "signedBy";
  } | {
    /**
     * @generated from field: common.SignaturePolicy.NOutOf n_out_of = 2;
     */
    value: SignaturePolicy_NOutOf;
    case: "nOutOf";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message common.SignaturePolicy.
 * Use `create(SignaturePolicySchema)` to create a new message.
 */
export const SignaturePolicySchema: GenMessage<SignaturePolicy> = /*@__PURE__*/
  messageDesc(file_common_policies, 2);

/**
 * @generated from message common.SignaturePolicy.NOutOf
 */
export type SignaturePolicy_NOutOf = Message<"common.SignaturePolicy.NOutOf"> & {
  /**
   * @generated from field: int32 n = 1;
   */
  n: number;

  /**
   * @generated from field: repeated common.SignaturePolicy rules = 2;
   */
  rules: SignaturePolicy[];
};

/**
 * Describes the message common.SignaturePolicy.NOutOf.
 * Use `create(SignaturePolicy_NOutOfSchema)` to create a new message.
 */
export const SignaturePolicy_NOutOfSchema: GenMessage<SignaturePolicy_NOutOf> = /*@__PURE__*/
  messageDesc(file_common_policies, 2, 0);

/**
 * ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration
 * It is implicit because the rule is generate implicitly based on the number of sub policies
 * It is meta because it depends only on the result of other policies
 * When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy
 * of name sub_policy, evaluates the collection and applies the rule.
 * For example, with 4 sub-groups, and a policy name of "foo", ImplicitMetaPolicy retrieves
 * each sub-group, retrieves policy "foo" for each subgroup, evaluates it, and, in the case of ANY
 * 1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures.
 *
 * @generated from message common.ImplicitMetaPolicy
 */
export type ImplicitMetaPolicy = Message<"common.ImplicitMetaPolicy"> & {
  /**
   * @generated from field: string sub_policy = 1;
   */
  subPolicy: string;

  /**
   * @generated from field: common.ImplicitMetaPolicy.Rule rule = 2;
   */
  rule: ImplicitMetaPolicy_Rule;
};

/**
 * Describes the message common.ImplicitMetaPolicy.
 * Use `create(ImplicitMetaPolicySchema)` to create a new message.
 */
export const ImplicitMetaPolicySchema: GenMessage<ImplicitMetaPolicy> = /*@__PURE__*/
  messageDesc(file_common_policies, 3);

/**
 * @generated from enum common.ImplicitMetaPolicy.Rule
 */
export enum ImplicitMetaPolicy_Rule {
  /**
   * Requires any of the sub-policies be satisfied, if no sub-policies exist, always returns true
   *
   * @generated from enum value: ANY = 0;
   */
  ANY = 0,

  /**
   * Requires all of the sub-policies be satisfied
   *
   * @generated from enum value: ALL = 1;
   */
  ALL = 1,

  /**
   * Requires a strict majority (greater than half) of the sub-policies be satisfied
   *
   * @generated from enum value: MAJORITY = 2;
   */
  MAJORITY = 2,
}

/**
 * Describes the enum common.ImplicitMetaPolicy.Rule.
 */
export const ImplicitMetaPolicy_RuleSchema: GenEnum<ImplicitMetaPolicy_Rule> = /*@__PURE__*/
  enumDesc(file_common_policies, 3, 0);

/**
 * ApplicationPolicy captures the diffenrent policy types that
 * are set and evaluted at the application level.
 *
 * @generated from message common.ApplicationPolicy
 * @deprecated
 */
export type ApplicationPolicy = Message<"common.ApplicationPolicy"> & {
  /**
   * @generated from oneof common.ApplicationPolicy.Type
   * @deprecated
   */
  Type: {
    /**
     * SignaturePolicy type is used if the policy is specified as
     * a combination (using threshold gates) of signatures from MSP
     * principals
     *
     * @generated from field: common.SignaturePolicyEnvelope signature_policy = 1;
     */
    value: SignaturePolicyEnvelope;
    case: "signaturePolicy";
  } | {
    /**
     * ChannelConfigPolicyReference is used when the policy is
     * specified as a string that references a policy defined in
     * the configuration of the channel
     *
     * @generated from field: string channel_config_policy_reference = 2;
     */
    value: string;
    case: "channelConfigPolicyReference";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message common.ApplicationPolicy.
 * Use `create(ApplicationPolicySchema)` to create a new message.
 * @deprecated
 */
export const ApplicationPolicySchema: GenMessage<ApplicationPolicy> = /*@__PURE__*/
  messageDesc(file_common_policies, 4);

