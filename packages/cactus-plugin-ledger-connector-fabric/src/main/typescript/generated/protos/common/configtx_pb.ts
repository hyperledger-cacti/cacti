// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file common/configtx.proto (package common, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Envelope } from "./common_pb";
import { file_common_common } from "./common_pb";
import type { Policy } from "./policies_pb";
import { file_common_policies } from "./policies_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file common/configtx.proto.
 */
export const file_common_configtx: GenFile = /*@__PURE__*/
  fileDesc("ChVjb21tb24vY29uZmlndHgucHJvdG8SBmNvbW1vbiJXCg5Db25maWdFbnZlbG9wZRIeCgZjb25maWcYASABKAsyDi5jb21tb24uQ29uZmlnEiUKC2xhc3RfdXBkYXRlGAIgASgLMhAuY29tbW9uLkVudmVsb3BlIlIKBkNvbmZpZxIQCghzZXF1ZW5jZRgBIAEoBBIqCg1jaGFubmVsX2dyb3VwGAIgASgLMhMuY29tbW9uLkNvbmZpZ0dyb3VwSgQIAxAEUgR0eXBlIloKFENvbmZpZ1VwZGF0ZUVudmVsb3BlEhUKDWNvbmZpZ191cGRhdGUYASABKAwSKwoKc2lnbmF0dXJlcxgCIAMoCzIXLmNvbW1vbi5Db25maWdTaWduYXR1cmUi8QEKDENvbmZpZ1VwZGF0ZRISCgpjaGFubmVsX2lkGAEgASgJEiUKCHJlYWRfc2V0GAIgASgLMhMuY29tbW9uLkNvbmZpZ0dyb3VwEiYKCXdyaXRlX3NldBgDIAEoCzITLmNvbW1vbi5Db25maWdHcm91cBI9Cg1pc29sYXRlZF9kYXRhGAUgAygLMiYuY29tbW9uLkNvbmZpZ1VwZGF0ZS5Jc29sYXRlZERhdGFFbnRyeRozChFJc29sYXRlZERhdGFFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAw6AjgBSgQIBBAFUgR0eXBlIpgDCgtDb25maWdHcm91cBIPCgd2ZXJzaW9uGAEgASgEEi8KBmdyb3VwcxgCIAMoCzIfLmNvbW1vbi5Db25maWdHcm91cC5Hcm91cHNFbnRyeRIvCgZ2YWx1ZXMYAyADKAsyHy5jb21tb24uQ29uZmlnR3JvdXAuVmFsdWVzRW50cnkSMwoIcG9saWNpZXMYBCADKAsyIS5jb21tb24uQ29uZmlnR3JvdXAuUG9saWNpZXNFbnRyeRISCgptb2RfcG9saWN5GAUgASgJGkIKC0dyb3Vwc0VudHJ5EgsKA2tleRgBIAEoCRIiCgV2YWx1ZRgCIAEoCzITLmNvbW1vbi5Db25maWdHcm91cDoCOAEaQgoLVmFsdWVzRW50cnkSCwoDa2V5GAEgASgJEiIKBXZhbHVlGAIgASgLMhMuY29tbW9uLkNvbmZpZ1ZhbHVlOgI4ARpFCg1Qb2xpY2llc0VudHJ5EgsKA2tleRgBIAEoCRIjCgV2YWx1ZRgCIAEoCzIULmNvbW1vbi5Db25maWdQb2xpY3k6AjgBIkEKC0NvbmZpZ1ZhbHVlEg8KB3ZlcnNpb24YASABKAQSDQoFdmFsdWUYAiABKAwSEgoKbW9kX3BvbGljeRgDIAEoCSJTCgxDb25maWdQb2xpY3kSDwoHdmVyc2lvbhgBIAEoBBIeCgZwb2xpY3kYAiABKAsyDi5jb21tb24uUG9saWN5EhIKCm1vZF9wb2xpY3kYAyABKAkiPgoPQ29uZmlnU2lnbmF0dXJlEhgKEHNpZ25hdHVyZV9oZWFkZXIYASABKAwSEQoJc2lnbmF0dXJlGAIgASgMQlYKJG9yZy5oeXBlcmxlZGdlci5mYWJyaWMucHJvdG9zLmNvbW1vblouZ2l0aHViLmNvbS9oeXBlcmxlZGdlci9mYWJyaWMtcHJvdG9zLWdvL2NvbW1vbmIGcHJvdG8z", [file_common_common, file_common_policies]);

/**
 * ConfigEnvelope is designed to contain _all_ configuration for a chain with no dependency
 * on previous configuration transactions.
 *
 * It is generated with the following scheme:
 *   1. Retrieve the existing configuration
 *   2. Note the config properties (ConfigValue, ConfigPolicy, ConfigGroup) to be modified
 *   3. Add any intermediate ConfigGroups to the ConfigUpdate.read_set (sparsely)
 *   4. Add any additional desired dependencies to ConfigUpdate.read_set (sparsely)
 *   5. Modify the config properties, incrementing each version by 1, set them in the ConfigUpdate.write_set
 *      Note: any element not modified but specified should already be in the read_set, so may be specified sparsely
 *   6. Create ConfigUpdate message and marshal it into ConfigUpdateEnvelope.update and encode the required signatures
 *     a) Each signature is of type ConfigSignature
 *     b) The ConfigSignature signature is over the concatenation of signature_header and the ConfigUpdate bytes (which includes a ChainHeader)
 *   5. Submit new Config for ordering in Envelope signed by submitter
 *     a) The Envelope Payload has data set to the marshaled ConfigEnvelope
 *     b) The Envelope Payload has a header of type Header.Type.CONFIG_UPDATE
 *
 * The configuration manager will verify:
 *   1. All items in the read_set exist at the read versions
 *   2. All items in the write_set at a different version than, or not in, the read_set have been appropriately signed according to their mod_policy
 *   3. The new configuration satisfies the ConfigSchema
 *
 * @generated from message common.ConfigEnvelope
 */
export type ConfigEnvelope = Message<"common.ConfigEnvelope"> & {
  /**
   * A marshaled Config structure
   *
   * @generated from field: common.Config config = 1;
   */
  config?: Config;

  /**
   * The last CONFIG_UPDATE message which generated this current configuration
   *
   * @generated from field: common.Envelope last_update = 2;
   */
  lastUpdate?: Envelope;
};

/**
 * Describes the message common.ConfigEnvelope.
 * Use `create(ConfigEnvelopeSchema)` to create a new message.
 */
export const ConfigEnvelopeSchema: GenMessage<ConfigEnvelope> = /*@__PURE__*/
  messageDesc(file_common_configtx, 0);

/**
 * Config represents the config for a particular channel
 *
 * @generated from message common.Config
 */
export type Config = Message<"common.Config"> & {
  /**
   * @generated from field: uint64 sequence = 1;
   */
  sequence: bigint;

  /**
   * channel_group is a bad name for this, it should be changed to root when API breakage is allowed
   *
   * @generated from field: common.ConfigGroup channel_group = 2;
   */
  channelGroup?: ConfigGroup;
};

/**
 * Describes the message common.Config.
 * Use `create(ConfigSchema)` to create a new message.
 */
export const ConfigSchema: GenMessage<Config> = /*@__PURE__*/
  messageDesc(file_common_configtx, 1);

/**
 * @generated from message common.ConfigUpdateEnvelope
 */
export type ConfigUpdateEnvelope = Message<"common.ConfigUpdateEnvelope"> & {
  /**
   * A marshaled ConfigUpdate structure
   *
   * @generated from field: bytes config_update = 1;
   */
  configUpdate: Uint8Array;

  /**
   * Signatures over the config_update
   *
   * @generated from field: repeated common.ConfigSignature signatures = 2;
   */
  signatures: ConfigSignature[];
};

/**
 * Describes the message common.ConfigUpdateEnvelope.
 * Use `create(ConfigUpdateEnvelopeSchema)` to create a new message.
 */
export const ConfigUpdateEnvelopeSchema: GenMessage<ConfigUpdateEnvelope> = /*@__PURE__*/
  messageDesc(file_common_configtx, 2);

/**
 * ConfigUpdate is used to submit a subset of config and to have the orderer apply to Config
 * it is always submitted inside a ConfigUpdateEnvelope which allows the addition of signatures
 * resulting in a new total configuration.  The update is applied as follows:
 * 1. The versions from all of the elements in the read_set is verified against the versions in the existing config.
 *    If there is a mismatch in the read versions, then the config update fails and is rejected.
 * 2. Any elements in the write_set with the same version as the read_set are ignored.
 * 3. The corresponding mod_policy for every remaining element in the write_set is collected.
 * 4. Each policy is checked against the signatures from the ConfigUpdateEnvelope, any failing to verify are rejected
 * 5. The write_set is applied to the Config and the ConfigGroupSchema verifies that the updates were legal
 *
 * @generated from message common.ConfigUpdate
 */
export type ConfigUpdate = Message<"common.ConfigUpdate"> & {
  /**
   * Which channel this config update is for
   *
   * @generated from field: string channel_id = 1;
   */
  channelId: string;

  /**
   * ReadSet explicitly lists the portion of the config which was read, this should be sparse with only Version set
   *
   * @generated from field: common.ConfigGroup read_set = 2;
   */
  readSet?: ConfigGroup;

  /**
   * WriteSet lists the portion of the config which was written, this should included updated Versions
   *
   * @generated from field: common.ConfigGroup write_set = 3;
   */
  writeSet?: ConfigGroup;

  /**
   * Data which is not to be reflected in the resulting Config, but is still needed for some other purpose.  For instance, rscc_seed_data
   *
   * @generated from field: map<string, bytes> isolated_data = 5;
   */
  isolatedData: { [key: string]: Uint8Array };
};

/**
 * Describes the message common.ConfigUpdate.
 * Use `create(ConfigUpdateSchema)` to create a new message.
 */
export const ConfigUpdateSchema: GenMessage<ConfigUpdate> = /*@__PURE__*/
  messageDesc(file_common_configtx, 3);

/**
 * ConfigGroup is the hierarchical data structure for holding config
 *
 * @generated from message common.ConfigGroup
 */
export type ConfigGroup = Message<"common.ConfigGroup"> & {
  /**
   * @generated from field: uint64 version = 1;
   */
  version: bigint;

  /**
   * @generated from field: map<string, common.ConfigGroup> groups = 2;
   */
  groups: { [key: string]: ConfigGroup };

  /**
   * @generated from field: map<string, common.ConfigValue> values = 3;
   */
  values: { [key: string]: ConfigValue };

  /**
   * @generated from field: map<string, common.ConfigPolicy> policies = 4;
   */
  policies: { [key: string]: ConfigPolicy };

  /**
   * @generated from field: string mod_policy = 5;
   */
  modPolicy: string;
};

/**
 * Describes the message common.ConfigGroup.
 * Use `create(ConfigGroupSchema)` to create a new message.
 */
export const ConfigGroupSchema: GenMessage<ConfigGroup> = /*@__PURE__*/
  messageDesc(file_common_configtx, 4);

/**
 * ConfigValue represents an individual piece of config data
 *
 * @generated from message common.ConfigValue
 */
export type ConfigValue = Message<"common.ConfigValue"> & {
  /**
   * @generated from field: uint64 version = 1;
   */
  version: bigint;

  /**
   * @generated from field: bytes value = 2;
   */
  value: Uint8Array;

  /**
   * @generated from field: string mod_policy = 3;
   */
  modPolicy: string;
};

/**
 * Describes the message common.ConfigValue.
 * Use `create(ConfigValueSchema)` to create a new message.
 */
export const ConfigValueSchema: GenMessage<ConfigValue> = /*@__PURE__*/
  messageDesc(file_common_configtx, 5);

/**
 * @generated from message common.ConfigPolicy
 */
export type ConfigPolicy = Message<"common.ConfigPolicy"> & {
  /**
   * @generated from field: uint64 version = 1;
   */
  version: bigint;

  /**
   * @generated from field: common.Policy policy = 2;
   */
  policy?: Policy;

  /**
   * @generated from field: string mod_policy = 3;
   */
  modPolicy: string;
};

/**
 * Describes the message common.ConfigPolicy.
 * Use `create(ConfigPolicySchema)` to create a new message.
 */
export const ConfigPolicySchema: GenMessage<ConfigPolicy> = /*@__PURE__*/
  messageDesc(file_common_configtx, 6);

/**
 * @generated from message common.ConfigSignature
 */
export type ConfigSignature = Message<"common.ConfigSignature"> & {
  /**
   * A marshaled SignatureHeader
   *
   * @generated from field: bytes signature_header = 1;
   */
  signatureHeader: Uint8Array;

  /**
   * Signature over the concatenation signatureHeader bytes and config bytes
   *
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;
};

/**
 * Describes the message common.ConfigSignature.
 * Use `create(ConfigSignatureSchema)` to create a new message.
 */
export const ConfigSignatureSchema: GenMessage<ConfigSignature> = /*@__PURE__*/
  messageDesc(file_common_configtx, 7);

