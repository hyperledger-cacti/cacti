// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file peer/collection.proto (package protos, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { SignaturePolicyEnvelope } from "../common/policies_pb";
import { file_common_policies } from "../common/policies_pb";
import type { ApplicationPolicy } from "./policy_pb";
import { file_peer_policy } from "./policy_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file peer/collection.proto.
 */
export const file_peer_collection: GenFile = /*@__PURE__*/
  fileDesc("ChVwZWVyL2NvbGxlY3Rpb24ucHJvdG8SBnByb3RvcyJDChdDb2xsZWN0aW9uQ29uZmlnUGFja2FnZRIoCgZjb25maWcYASADKAsyGC5wcm90b3MuQ29sbGVjdGlvbkNvbmZpZyJhChBDb2xsZWN0aW9uQ29uZmlnEkIKGHN0YXRpY19jb2xsZWN0aW9uX2NvbmZpZxgBIAEoCzIeLnByb3Rvcy5TdGF0aWNDb2xsZWN0aW9uQ29uZmlnSABCCQoHcGF5bG9hZCKeAgoWU3RhdGljQ29sbGVjdGlvbkNvbmZpZxIMCgRuYW1lGAEgASgJEjoKEm1lbWJlcl9vcmdzX3BvbGljeRgCIAEoCzIeLnByb3Rvcy5Db2xsZWN0aW9uUG9saWN5Q29uZmlnEhsKE3JlcXVpcmVkX3BlZXJfY291bnQYAyABKAUSGgoSbWF4aW11bV9wZWVyX2NvdW50GAQgASgFEhUKDWJsb2NrX3RvX2xpdmUYBSABKAQSGAoQbWVtYmVyX29ubHlfcmVhZBgGIAEoCBIZChFtZW1iZXJfb25seV93cml0ZRgHIAEoCBI1ChJlbmRvcnNlbWVudF9wb2xpY3kYCCABKAsyGS5wcm90b3MuQXBwbGljYXRpb25Qb2xpY3kiYAoWQ29sbGVjdGlvblBvbGljeUNvbmZpZxI7ChBzaWduYXR1cmVfcG9saWN5GAEgASgLMh8uY29tbW9uLlNpZ25hdHVyZVBvbGljeUVudmVsb3BlSABCCQoHcGF5bG9hZEJSCiJvcmcuaHlwZXJsZWRnZXIuZmFicmljLnByb3Rvcy5wZWVyWixnaXRodWIuY29tL2h5cGVybGVkZ2VyL2ZhYnJpYy1wcm90b3MtZ28vcGVlcmIGcHJvdG8z", [file_common_policies, file_peer_policy]);

/**
 * CollectionConfigPackage represents an array of CollectionConfig
 * messages; the extra struct is required because repeated oneof is
 * forbidden by the protobuf syntax
 *
 * @generated from message protos.CollectionConfigPackage
 */
export type CollectionConfigPackage = Message<"protos.CollectionConfigPackage"> & {
  /**
   * @generated from field: repeated protos.CollectionConfig config = 1;
   */
  config: CollectionConfig[];
};

/**
 * Describes the message protos.CollectionConfigPackage.
 * Use `create(CollectionConfigPackageSchema)` to create a new message.
 */
export const CollectionConfigPackageSchema: GenMessage<CollectionConfigPackage> = /*@__PURE__*/
  messageDesc(file_peer_collection, 0);

/**
 * CollectionConfig defines the configuration of a collection object;
 * it currently contains a single, static type.
 * Dynamic collections are deferred.
 *
 * @generated from message protos.CollectionConfig
 */
export type CollectionConfig = Message<"protos.CollectionConfig"> & {
  /**
   * @generated from oneof protos.CollectionConfig.payload
   */
  payload: {
    /**
     * @generated from field: protos.StaticCollectionConfig static_collection_config = 1;
     */
    value: StaticCollectionConfig;
    case: "staticCollectionConfig";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message protos.CollectionConfig.
 * Use `create(CollectionConfigSchema)` to create a new message.
 */
export const CollectionConfigSchema: GenMessage<CollectionConfig> = /*@__PURE__*/
  messageDesc(file_peer_collection, 1);

/**
 * StaticCollectionConfig constitutes the configuration parameters of a
 * static collection object. Static collections are collections that are
 * known at chaincode instantiation time, and that cannot be changed.
 * Dynamic collections are deferred.
 *
 * @generated from message protos.StaticCollectionConfig
 */
export type StaticCollectionConfig = Message<"protos.StaticCollectionConfig"> & {
  /**
   * the name of the collection inside the denoted chaincode
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * a reference to a policy residing / managed in the config block
   * to define which orgs have access to this collectionâ€™s private data
   *
   * @generated from field: protos.CollectionPolicyConfig member_orgs_policy = 2;
   */
  memberOrgsPolicy?: CollectionPolicyConfig;

  /**
   * The minimum number of peers private data will be sent to upon
   * endorsement. The endorsement would fail if dissemination to at least
   * this number of peers is not achieved.
   *
   * @generated from field: int32 required_peer_count = 3;
   */
  requiredPeerCount: number;

  /**
   * The maximum number of peers that private data will be sent to
   * upon endorsement. This number has to be bigger than required_peer_count.
   *
   * @generated from field: int32 maximum_peer_count = 4;
   */
  maximumPeerCount: number;

  /**
   * The number of blocks after which the collection data expires.
   * For instance if the value is set to 10, a key last modified by block number 100
   * will be purged at block number 111. A zero value is treated same as MaxUint64
   *
   * @generated from field: uint64 block_to_live = 5;
   */
  blockToLive: bigint;

  /**
   * The member only read access denotes whether only collection member clients
   * can read the private data (if set to true), or even non members can
   * read the data (if set to false, for example if you want to implement more granular
   * access logic in the chaincode)
   *
   * @generated from field: bool member_only_read = 6;
   */
  memberOnlyRead: boolean;

  /**
   * The member only write access denotes whether only collection member clients
   * can write the private data (if set to true), or even non members can
   * write the data (if set to false, for example if you want to implement more granular
   * access logic in the chaincode)
   *
   * @generated from field: bool member_only_write = 7;
   */
  memberOnlyWrite: boolean;

  /**
   * a reference to a policy residing / managed in the config block
   * to define the endorsement policy for this collection
   *
   * @generated from field: protos.ApplicationPolicy endorsement_policy = 8;
   */
  endorsementPolicy?: ApplicationPolicy;
};

/**
 * Describes the message protos.StaticCollectionConfig.
 * Use `create(StaticCollectionConfigSchema)` to create a new message.
 */
export const StaticCollectionConfigSchema: GenMessage<StaticCollectionConfig> = /*@__PURE__*/
  messageDesc(file_peer_collection, 2);

/**
 * Collection policy configuration. Initially, the configuration can only
 * contain a SignaturePolicy. In the future, the SignaturePolicy may be a
 * more general Policy. Instead of containing the actual policy, the
 * configuration may in the future contain a string reference to a policy.
 *
 * @generated from message protos.CollectionPolicyConfig
 */
export type CollectionPolicyConfig = Message<"protos.CollectionPolicyConfig"> & {
  /**
   * @generated from oneof protos.CollectionPolicyConfig.payload
   */
  payload: {
    /**
     * Initially, only a signature policy is supported.
     *
     * Later, the SignaturePolicy will be replaced by a Policy.
     *        Policy policy = 1;
     * A reference to a Policy is planned to be added later.
     *        string reference = 2;
     *
     * @generated from field: common.SignaturePolicyEnvelope signature_policy = 1;
     */
    value: SignaturePolicyEnvelope;
    case: "signaturePolicy";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message protos.CollectionPolicyConfig.
 * Use `create(CollectionPolicyConfigSchema)` to create a new message.
 */
export const CollectionPolicyConfigSchema: GenMessage<CollectionPolicyConfig> = /*@__PURE__*/
  messageDesc(file_peer_collection, 3);

