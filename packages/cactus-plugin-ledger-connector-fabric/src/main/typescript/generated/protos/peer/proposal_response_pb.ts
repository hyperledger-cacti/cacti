// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file peer/proposal_response.proto (package protos, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file peer/proposal_response.proto.
 */
export const file_peer_proposal_response: GenFile = /*@__PURE__*/
  fileDesc("ChxwZWVyL3Byb3Bvc2FsX3Jlc3BvbnNlLnByb3RvEgZwcm90b3MisQEKEFByb3Bvc2FsUmVzcG9uc2USDwoHdmVyc2lvbhgBIAEoBRItCgl0aW1lc3RhbXAYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEiIKCHJlc3BvbnNlGAQgASgLMhAucHJvdG9zLlJlc3BvbnNlEg8KB3BheWxvYWQYBSABKAwSKAoLZW5kb3JzZW1lbnQYBiABKAsyEy5wcm90b3MuRW5kb3JzZW1lbnQiPAoIUmVzcG9uc2USDgoGc3RhdHVzGAEgASgFEg8KB21lc3NhZ2UYAiABKAkSDwoHcGF5bG9hZBgDIAEoDCJDChdQcm9wb3NhbFJlc3BvbnNlUGF5bG9hZBIVCg1wcm9wb3NhbF9oYXNoGAEgASgMEhEKCWV4dGVuc2lvbhgCIAEoDCIyCgtFbmRvcnNlbWVudBIQCghlbmRvcnNlchgBIAEoDBIRCglzaWduYXR1cmUYAiABKAxCawoib3JnLmh5cGVybGVkZ2VyLmZhYnJpYy5wcm90b3MucGVlckIXUHJvcG9zYWxSZXNwb25zZVBhY2thZ2VaLGdpdGh1Yi5jb20vaHlwZXJsZWRnZXIvZmFicmljLXByb3Rvcy1nby9wZWVyYgZwcm90bzM", [file_google_protobuf_timestamp]);

/**
 * A ProposalResponse is returned from an endorser to the proposal submitter.
 * The idea is that this message contains the endorser's response to the
 * request of a client to perform an action over a chaincode (or more
 * generically on the ledger); the response might be success/error (conveyed in
 * the Response field) together with a description of the action and a
 * signature over it by that endorser.  If a sufficient number of distinct
 * endorsers agree on the same action and produce signature to that effect, a
 * transaction can be generated and sent for ordering.
 *
 * @generated from message protos.ProposalResponse
 */
export type ProposalResponse = Message<"protos.ProposalResponse"> & {
  /**
   * Version indicates message protocol version
   *
   * @generated from field: int32 version = 1;
   */
  version: number;

  /**
   * Timestamp is the time that the message
   * was created as  defined by the sender
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  /**
   * A response message indicating whether the
   * endorsement of the action was successful
   *
   * @generated from field: protos.Response response = 4;
   */
  response?: Response;

  /**
   * The payload of response. It is the bytes of ProposalResponsePayload
   *
   * @generated from field: bytes payload = 5;
   */
  payload: Uint8Array;

  /**
   * The endorsement of the proposal, basically
   * the endorser's signature over the payload
   *
   * @generated from field: protos.Endorsement endorsement = 6;
   */
  endorsement?: Endorsement;
};

/**
 * Describes the message protos.ProposalResponse.
 * Use `create(ProposalResponseSchema)` to create a new message.
 */
export const ProposalResponseSchema: GenMessage<ProposalResponse> = /*@__PURE__*/
  messageDesc(file_peer_proposal_response, 0);

/**
 * A response with a representation similar to an HTTP response that can
 * be used within another message.
 *
 * @generated from message protos.Response
 */
export type Response = Message<"protos.Response"> & {
  /**
   * A status code that should follow the HTTP status codes.
   *
   * @generated from field: int32 status = 1;
   */
  status: number;

  /**
   * A message associated with the response code.
   *
   * @generated from field: string message = 2;
   */
  message: string;

  /**
   * A payload that can be used to include metadata with this response.
   *
   * @generated from field: bytes payload = 3;
   */
  payload: Uint8Array;
};

/**
 * Describes the message protos.Response.
 * Use `create(ResponseSchema)` to create a new message.
 */
export const ResponseSchema: GenMessage<Response> = /*@__PURE__*/
  messageDesc(file_peer_proposal_response, 1);

/**
 * ProposalResponsePayload is the payload of a proposal response.  This message
 * is the "bridge" between the client's request and the endorser's action in
 * response to that request. Concretely, for chaincodes, it contains a hashed
 * representation of the proposal (proposalHash) and a representation of the
 * chaincode state changes and events inside the extension field.
 *
 * @generated from message protos.ProposalResponsePayload
 */
export type ProposalResponsePayload = Message<"protos.ProposalResponsePayload"> & {
  /**
   * Hash of the proposal that triggered this response. The hash is used to
   * link a response with its proposal, both for bookeeping purposes on an
   * asynchronous system and for security reasons (accountability,
   * non-repudiation). The hash usually covers the entire Proposal message
   * (byte-by-byte).
   *
   * @generated from field: bytes proposal_hash = 1;
   */
  proposalHash: Uint8Array;

  /**
   * Extension should be unmarshaled to a type-specific message. The type of
   * the extension in any proposal response depends on the type of the proposal
   * that the client selected when the proposal was initially sent out.  In
   * particular, this information is stored in the type field of a Header.  For
   * chaincode, it's a ChaincodeAction message
   *
   * @generated from field: bytes extension = 2;
   */
  extension: Uint8Array;
};

/**
 * Describes the message protos.ProposalResponsePayload.
 * Use `create(ProposalResponsePayloadSchema)` to create a new message.
 */
export const ProposalResponsePayloadSchema: GenMessage<ProposalResponsePayload> = /*@__PURE__*/
  messageDesc(file_peer_proposal_response, 2);

/**
 * An endorsement is a signature of an endorser over a proposal response.  By
 * producing an endorsement message, an endorser implicitly "approves" that
 * proposal response and the actions contained therein. When enough
 * endorsements have been collected, a transaction can be generated out of a
 * set of proposal responses.  Note that this message only contains an identity
 * and a signature but no signed payload. This is intentional because
 * endorsements are supposed to be collected in a transaction, and they are all
 * expected to endorse a single proposal response/action (many endorsements
 * over a single proposal response)
 *
 * @generated from message protos.Endorsement
 */
export type Endorsement = Message<"protos.Endorsement"> & {
  /**
   * Identity of the endorser (e.g. its certificate)
   *
   * @generated from field: bytes endorser = 1;
   */
  endorser: Uint8Array;

  /**
   * Signature of the payload included in ProposalResponse concatenated with
   * the endorser's certificate; ie, sign(ProposalResponse.payload + endorser)
   *
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;
};

/**
 * Describes the message protos.Endorsement.
 * Use `create(EndorsementSchema)` to create a new message.
 */
export const EndorsementSchema: GenMessage<Endorsement> = /*@__PURE__*/
  messageDesc(file_peer_proposal_response, 3);

