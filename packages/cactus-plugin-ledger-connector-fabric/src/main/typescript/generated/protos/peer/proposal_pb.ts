// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file peer/proposal.proto (package protos, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { ChaincodeID } from "./chaincode_pb";
import { file_peer_chaincode } from "./chaincode_pb";
import type { Response } from "./proposal_response_pb";
import { file_peer_proposal_response } from "./proposal_response_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file peer/proposal.proto.
 */
export const file_peer_proposal: GenFile = /*@__PURE__*/
  fileDesc("ChNwZWVyL3Byb3Bvc2FsLnByb3RvEgZwcm90b3MiOwoOU2lnbmVkUHJvcG9zYWwSFgoOcHJvcG9zYWxfYnl0ZXMYASABKAwSEQoJc2lnbmF0dXJlGAIgASgMIj4KCFByb3Bvc2FsEg4KBmhlYWRlchgBIAEoDBIPCgdwYXlsb2FkGAIgASgMEhEKCWV4dGVuc2lvbhgDIAEoDCJeChhDaGFpbmNvZGVIZWFkZXJFeHRlbnNpb24SKQoMY2hhaW5jb2RlX2lkGAIgASgLMhMucHJvdG9zLkNoYWluY29kZUlESgQIARACUhFwYXlsb2FkX3Zpc2JpbGl0eSKoAQoYQ2hhaW5jb2RlUHJvcG9zYWxQYXlsb2FkEg0KBWlucHV0GAEgASgMEkgKDFRyYW5zaWVudE1hcBgCIAMoCzIyLnByb3Rvcy5DaGFpbmNvZGVQcm9wb3NhbFBheWxvYWQuVHJhbnNpZW50TWFwRW50cnkaMwoRVHJhbnNpZW50TWFwRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgMOgI4ASKZAQoPQ2hhaW5jb2RlQWN0aW9uEg8KB3Jlc3VsdHMYASABKAwSDgoGZXZlbnRzGAIgASgMEiIKCHJlc3BvbnNlGAMgASgLMhAucHJvdG9zLlJlc3BvbnNlEikKDGNoYWluY29kZV9pZBgEIAEoCzITLnByb3Rvcy5DaGFpbmNvZGVJREoECAUQBlIQdG9rZW5fb3BlcmF0aW9uc0JjCiJvcmcuaHlwZXJsZWRnZXIuZmFicmljLnByb3Rvcy5wZWVyQg9Qcm9wb3NhbFBhY2thZ2VaLGdpdGh1Yi5jb20vaHlwZXJsZWRnZXIvZmFicmljLXByb3Rvcy1nby9wZWVyYgZwcm90bzM", [file_peer_chaincode, file_peer_proposal_response]);

/**
 * This structure is necessary to sign the proposal which contains the header
 * and the payload. Without this structure, we would have to concatenate the
 * header and the payload to verify the signature, which could be expensive
 * with large payload
 *
 * When an endorser receives a SignedProposal message, it should verify the
 * signature over the proposal bytes. This verification requires the following
 * steps:
 * 1. Verification of the validity of the certificate that was used to produce
 *    the signature.  The certificate will be available once proposalBytes has
 *    been unmarshalled to a Proposal message, and Proposal.header has been
 *    unmarshalled to a Header message. While this unmarshalling-before-verifying
 *    might not be ideal, it is unavoidable because i) the signature needs to also
 *    protect the signing certificate; ii) it is desirable that Header is created
 *    once by the client and never changed (for the sake of accountability and
 *    non-repudiation). Note also that it is actually impossible to conclusively
 *    verify the validity of the certificate included in a Proposal, because the
 *    proposal needs to first be endorsed and ordered with respect to certificate
 *    expiration transactions. Still, it is useful to pre-filter expired
 *    certificates at this stage.
 * 2. Verification that the certificate is trusted (signed by a trusted CA) and
 *    that it is allowed to transact with us (with respect to some ACLs);
 * 3. Verification that the signature on proposalBytes is valid;
 * 4. Detect replay attacks;
 *
 * @generated from message protos.SignedProposal
 */
export type SignedProposal = Message<"protos.SignedProposal"> & {
  /**
   * The bytes of Proposal
   *
   * @generated from field: bytes proposal_bytes = 1;
   */
  proposalBytes: Uint8Array;

  /**
   * Signaure over proposalBytes; this signature is to be verified against
   * the creator identity contained in the header of the Proposal message
   * marshaled as proposalBytes
   *
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;
};

/**
 * Describes the message protos.SignedProposal.
 * Use `create(SignedProposalSchema)` to create a new message.
 */
export const SignedProposalSchema: GenMessage<SignedProposal> = /*@__PURE__*/
  messageDesc(file_peer_proposal, 0);

/**
 * A Proposal is sent to an endorser for endorsement.  The proposal contains:
 * 1. A header which should be unmarshaled to a Header message.  Note that
 *    Header is both the header of a Proposal and of a Transaction, in that i)
 *    both headers should be unmarshaled to this message; and ii) it is used to
 *    compute cryptographic hashes and signatures.  The header has fields common
 *    to all proposals/transactions.  In addition it has a type field for
 *    additional customization. An example of this is the ChaincodeHeaderExtension
 *    message used to extend the Header for type CHAINCODE.
 * 2. A payload whose type depends on the header's type field.
 * 3. An extension whose type depends on the header's type field.
 *
 * Let us see an example. For type CHAINCODE (see the Header message),
 * we have the following:
 * 1. The header is a Header message whose extensions field is a
 *    ChaincodeHeaderExtension message.
 * 2. The payload is a ChaincodeProposalPayload message.
 * 3. The extension is a ChaincodeAction that might be used to ask the
 *    endorsers to endorse a specific ChaincodeAction, thus emulating the
 *    submitting peer model.
 *
 * @generated from message protos.Proposal
 */
export type Proposal = Message<"protos.Proposal"> & {
  /**
   * The header of the proposal. It is the bytes of the Header
   *
   * @generated from field: bytes header = 1;
   */
  header: Uint8Array;

  /**
   * The payload of the proposal as defined by the type in the proposal
   * header.
   *
   * @generated from field: bytes payload = 2;
   */
  payload: Uint8Array;

  /**
   * Optional extensions to the proposal. Its content depends on the Header's
   * type field.  For the type CHAINCODE, it might be the bytes of a
   * ChaincodeAction message.
   *
   * @generated from field: bytes extension = 3;
   */
  extension: Uint8Array;
};

/**
 * Describes the message protos.Proposal.
 * Use `create(ProposalSchema)` to create a new message.
 */
export const ProposalSchema: GenMessage<Proposal> = /*@__PURE__*/
  messageDesc(file_peer_proposal, 1);

/**
 * ChaincodeHeaderExtension is the Header's extentions message to be used when
 * the Header's type is CHAINCODE.  This extensions is used to specify which
 * chaincode to invoke and what should appear on the ledger.
 *
 * @generated from message protos.ChaincodeHeaderExtension
 */
export type ChaincodeHeaderExtension = Message<"protos.ChaincodeHeaderExtension"> & {
  /**
   * The ID of the chaincode to target.
   *
   * @generated from field: protos.ChaincodeID chaincode_id = 2;
   */
  chaincodeId?: ChaincodeID;
};

/**
 * Describes the message protos.ChaincodeHeaderExtension.
 * Use `create(ChaincodeHeaderExtensionSchema)` to create a new message.
 */
export const ChaincodeHeaderExtensionSchema: GenMessage<ChaincodeHeaderExtension> = /*@__PURE__*/
  messageDesc(file_peer_proposal, 2);

/**
 * ChaincodeProposalPayload is the Proposal's payload message to be used when
 * the Header's type is CHAINCODE.  It contains the arguments for this
 * invocation.
 *
 * @generated from message protos.ChaincodeProposalPayload
 */
export type ChaincodeProposalPayload = Message<"protos.ChaincodeProposalPayload"> & {
  /**
   * Input contains the arguments for this invocation. If this invocation
   * deploys a new chaincode, ESCC/VSCC are part of this field.
   * This is usually a marshaled ChaincodeInvocationSpec
   *
   * @generated from field: bytes input = 1;
   */
  input: Uint8Array;

  /**
   * TransientMap contains data (e.g. cryptographic material) that might be used
   * to implement some form of application-level confidentiality. The contents
   * of this field are supposed to always be omitted from the transaction and
   * excluded from the ledger.
   *
   * @generated from field: map<string, bytes> TransientMap = 2;
   */
  TransientMap: { [key: string]: Uint8Array };
};

/**
 * Describes the message protos.ChaincodeProposalPayload.
 * Use `create(ChaincodeProposalPayloadSchema)` to create a new message.
 */
export const ChaincodeProposalPayloadSchema: GenMessage<ChaincodeProposalPayload> = /*@__PURE__*/
  messageDesc(file_peer_proposal, 3);

/**
 * ChaincodeAction contains the actions the events generated by the execution
 * of the chaincode.
 *
 * @generated from message protos.ChaincodeAction
 */
export type ChaincodeAction = Message<"protos.ChaincodeAction"> & {
  /**
   * This field contains the read set and the write set produced by the
   * chaincode executing this invocation.
   *
   * @generated from field: bytes results = 1;
   */
  results: Uint8Array;

  /**
   * This field contains the events generated by the chaincode executing this
   * invocation.
   *
   * @generated from field: bytes events = 2;
   */
  events: Uint8Array;

  /**
   * This field contains the result of executing this invocation.
   *
   * @generated from field: protos.Response response = 3;
   */
  response?: Response;

  /**
   * This field contains the ChaincodeID of executing this invocation. Endorser
   * will set it with the ChaincodeID called by endorser while simulating proposal.
   * Committer will validate the version matching with latest chaincode version.
   * Adding ChaincodeID to keep version opens up the possibility of multiple
   * ChaincodeAction per transaction.
   *
   * @generated from field: protos.ChaincodeID chaincode_id = 4;
   */
  chaincodeId?: ChaincodeID;
};

/**
 * Describes the message protos.ChaincodeAction.
 * Use `create(ChaincodeActionSchema)` to create a new message.
 */
export const ChaincodeActionSchema: GenMessage<ChaincodeAction> = /*@__PURE__*/
  messageDesc(file_peer_proposal, 4);

