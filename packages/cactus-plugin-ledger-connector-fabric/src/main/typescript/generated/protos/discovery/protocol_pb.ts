// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file discovery/protocol.proto (package discovery, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Envelope } from "../gossip/message_pb";
import { file_gossip_message } from "../gossip/message_pb";
import type { FabricMSPConfig } from "../msp/msp_config_pb";
import { file_msp_msp_config } from "../msp/msp_config_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file discovery/protocol.proto.
 */
export const file_discovery_protocol: GenFile = /*@__PURE__*/
  fileDesc("ChhkaXNjb3ZlcnkvcHJvdG9jb2wucHJvdG8SCWRpc2NvdmVyeSIzCg1TaWduZWRSZXF1ZXN0Eg8KB3BheWxvYWQYASABKAwSEQoJc2lnbmF0dXJlGAIgASgMIlkKB1JlcXVlc3QSKwoOYXV0aGVudGljYXRpb24YASABKAsyEy5kaXNjb3ZlcnkuQXV0aEluZm8SIQoHcXVlcmllcxgCIAMoCzIQLmRpc2NvdmVyeS5RdWVyeSIzCghSZXNwb25zZRInCgdyZXN1bHRzGAEgAygLMhYuZGlzY292ZXJ5LlF1ZXJ5UmVzdWx0IkEKCEF1dGhJbmZvEhcKD2NsaWVudF9pZGVudGl0eRgBIAEoDBIcChRjbGllbnRfdGxzX2NlcnRfaGFzaBgCIAEoDCLoAQoFUXVlcnkSDwoHY2hhbm5lbBgBIAEoCRIuCgxjb25maWdfcXVlcnkYAiABKAsyFi5kaXNjb3ZlcnkuQ29uZmlnUXVlcnlIABI0CgpwZWVyX3F1ZXJ5GAMgASgLMh4uZGlzY292ZXJ5LlBlZXJNZW1iZXJzaGlwUXVlcnlIABItCghjY19xdWVyeRgEIAEoCzIZLmRpc2NvdmVyeS5DaGFpbmNvZGVRdWVyeUgAEjAKC2xvY2FsX3BlZXJzGAUgASgLMhkuZGlzY292ZXJ5LkxvY2FsUGVlclF1ZXJ5SABCBwoFcXVlcnki2QEKC1F1ZXJ5UmVzdWx0EiEKBWVycm9yGAEgASgLMhAuZGlzY292ZXJ5LkVycm9ySAASMAoNY29uZmlnX3Jlc3VsdBgCIAEoCzIXLmRpc2NvdmVyeS5Db25maWdSZXN1bHRIABI3CgxjY19xdWVyeV9yZXMYAyABKAsyHy5kaXNjb3ZlcnkuQ2hhaW5jb2RlUXVlcnlSZXN1bHRIABIyCgdtZW1iZXJzGAQgASgLMh8uZGlzY292ZXJ5LlBlZXJNZW1iZXJzaGlwUmVzdWx0SABCCAoGcmVzdWx0Ig0KC0NvbmZpZ1F1ZXJ5IoICCgxDb25maWdSZXN1bHQSLwoEbXNwcxgBIAMoCzIhLmRpc2NvdmVyeS5Db25maWdSZXN1bHQuTXNwc0VudHJ5EjcKCG9yZGVyZXJzGAIgAygLMiUuZGlzY292ZXJ5LkNvbmZpZ1Jlc3VsdC5PcmRlcmVyc0VudHJ5GkEKCU1zcHNFbnRyeRILCgNrZXkYASABKAkSIwoFdmFsdWUYAiABKAsyFC5tc3AuRmFicmljTVNQQ29uZmlnOgI4ARpFCg1PcmRlcmVyc0VudHJ5EgsKA2tleRgBIAEoCRIjCgV2YWx1ZRgCIAEoCzIULmRpc2NvdmVyeS5FbmRwb2ludHM6AjgBIkMKE1BlZXJNZW1iZXJzaGlwUXVlcnkSLAoGZmlsdGVyGAEgASgLMhwuZGlzY292ZXJ5LkNoYWluY29kZUludGVyZXN0IqIBChRQZWVyTWVtYmVyc2hpcFJlc3VsdBJFCgxwZWVyc19ieV9vcmcYASADKAsyLy5kaXNjb3ZlcnkuUGVlck1lbWJlcnNoaXBSZXN1bHQuUGVlcnNCeU9yZ0VudHJ5GkMKD1BlZXJzQnlPcmdFbnRyeRILCgNrZXkYASABKAkSHwoFdmFsdWUYAiABKAsyEC5kaXNjb3ZlcnkuUGVlcnM6AjgBIkEKDkNoYWluY29kZVF1ZXJ5Ei8KCWludGVyZXN0cxgBIAMoCzIcLmRpc2NvdmVyeS5DaGFpbmNvZGVJbnRlcmVzdCJBChFDaGFpbmNvZGVJbnRlcmVzdBIsCgpjaGFpbmNvZGVzGAEgAygLMhguZGlzY292ZXJ5LkNoYWluY29kZUNhbGwiawoNQ2hhaW5jb2RlQ2FsbBIMCgRuYW1lGAEgASgJEhgKEGNvbGxlY3Rpb25fbmFtZXMYAiADKAkSGAoQbm9fcHJpdmF0ZV9yZWFkcxgDIAEoCBIYChBub19wdWJsaWNfd3JpdGVzGAQgASgIIkkKFENoYWluY29kZVF1ZXJ5UmVzdWx0EjEKB2NvbnRlbnQYASADKAsyIC5kaXNjb3ZlcnkuRW5kb3JzZW1lbnREZXNjcmlwdG9yIhAKDkxvY2FsUGVlclF1ZXJ5IvABChVFbmRvcnNlbWVudERlc2NyaXB0b3ISEQoJY2hhaW5jb2RlGAEgASgJElQKE2VuZG9yc2Vyc19ieV9ncm91cHMYAiADKAsyNy5kaXNjb3ZlcnkuRW5kb3JzZW1lbnREZXNjcmlwdG9yLkVuZG9yc2Vyc0J5R3JvdXBzRW50cnkSIgoHbGF5b3V0cxgDIAMoCzIRLmRpc2NvdmVyeS5MYXlvdXQaSgoWRW5kb3JzZXJzQnlHcm91cHNFbnRyeRILCgNrZXkYASABKAkSHwoFdmFsdWUYAiABKAsyEC5kaXNjb3ZlcnkuUGVlcnM6AjgBIokBCgZMYXlvdXQSRQoTcXVhbnRpdGllc19ieV9ncm91cBgBIAMoCzIoLmRpc2NvdmVyeS5MYXlvdXQuUXVhbnRpdGllc0J5R3JvdXBFbnRyeRo4ChZRdWFudGl0aWVzQnlHcm91cEVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoDToCOAEiJwoFUGVlcnMSHgoFcGVlcnMYASADKAsyDy5kaXNjb3ZlcnkuUGVlciJpCgRQZWVyEiQKCnN0YXRlX2luZm8YASABKAsyEC5nb3NzaXAuRW52ZWxvcGUSKQoPbWVtYmVyc2hpcF9pbmZvGAIgASgLMhAuZ29zc2lwLkVudmVsb3BlEhAKCGlkZW50aXR5GAMgASgMIhgKBUVycm9yEg8KB2NvbnRlbnQYASABKAkiMgoJRW5kcG9pbnRzEiUKCGVuZHBvaW50GAEgAygLMhMuZGlzY292ZXJ5LkVuZHBvaW50IiYKCEVuZHBvaW50EgwKBGhvc3QYASABKAkSDAoEcG9ydBgCIAEoDTJGCglEaXNjb3ZlcnkSOQoIRGlzY292ZXISGC5kaXNjb3ZlcnkuU2lnbmVkUmVxdWVzdBoTLmRpc2NvdmVyeS5SZXNwb25zZUJcCidvcmcuaHlwZXJsZWRnZXIuZmFicmljLnByb3Rvcy5kaXNjb3ZlcnlaMWdpdGh1Yi5jb20vaHlwZXJsZWRnZXIvZmFicmljLXByb3Rvcy1nby9kaXNjb3ZlcnliBnByb3RvMw", [file_gossip_message, file_msp_msp_config]);

/**
 * SignedRequest contains a serialized Request in the payload field
 * and a signature.
 * The identity that is used to verify the signature
 * can be extracted from the authentication field of type AuthInfo
 * in the Request itself after deserializing it.
 *
 * @generated from message discovery.SignedRequest
 */
export type SignedRequest = Message<"discovery.SignedRequest"> & {
  /**
   * @generated from field: bytes payload = 1;
   */
  payload: Uint8Array;

  /**
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;
};

/**
 * Describes the message discovery.SignedRequest.
 * Use `create(SignedRequestSchema)` to create a new message.
 */
export const SignedRequestSchema: GenMessage<SignedRequest> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 0);

/**
 * Request contains authentication info about the client that sent the request
 * and the queries it wishes to query the service
 *
 * @generated from message discovery.Request
 */
export type Request = Message<"discovery.Request"> & {
  /**
   * authentication contains information that the service uses to check
   * the client's eligibility for the queries.
   *
   * @generated from field: discovery.AuthInfo authentication = 1;
   */
  authentication?: AuthInfo;

  /**
   * queries
   *
   * @generated from field: repeated discovery.Query queries = 2;
   */
  queries: Query[];
};

/**
 * Describes the message discovery.Request.
 * Use `create(RequestSchema)` to create a new message.
 */
export const RequestSchema: GenMessage<Request> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 1);

/**
 * @generated from message discovery.Response
 */
export type Response = Message<"discovery.Response"> & {
  /**
   * The results are returned in the same order of the queries
   *
   * @generated from field: repeated discovery.QueryResult results = 1;
   */
  results: QueryResult[];
};

/**
 * Describes the message discovery.Response.
 * Use `create(ResponseSchema)` to create a new message.
 */
export const ResponseSchema: GenMessage<Response> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 2);

/**
 * AuthInfo aggregates authentication information that the server uses
 * to authenticate the client
 *
 * @generated from message discovery.AuthInfo
 */
export type AuthInfo = Message<"discovery.AuthInfo"> & {
  /**
   * This is the identity of the client that is used to verify the signature
   * on the SignedRequest's payload.
   * It is a msp.SerializedIdentity in bytes form
   *
   * @generated from field: bytes client_identity = 1;
   */
  clientIdentity: Uint8Array;

  /**
   * This is the hash of the client's TLS cert.
   * When the network is running with TLS, clients that don't include a certificate
   * will be denied access to the service.
   * Since the Request is encapsulated with a SignedRequest (which is signed),
   * this binds the TLS session to the enrollement identity of the client and
   * therefore both authenticates the client to the server,
   * and also prevents the server from relaying the request message to another server.
   *
   * @generated from field: bytes client_tls_cert_hash = 2;
   */
  clientTlsCertHash: Uint8Array;
};

/**
 * Describes the message discovery.AuthInfo.
 * Use `create(AuthInfoSchema)` to create a new message.
 */
export const AuthInfoSchema: GenMessage<AuthInfo> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 3);

/**
 * Query asks for information in the context of a specific channel
 *
 * @generated from message discovery.Query
 */
export type Query = Message<"discovery.Query"> & {
  /**
   * @generated from field: string channel = 1;
   */
  channel: string;

  /**
   * @generated from oneof discovery.Query.query
   */
  query: {
    /**
     * ConfigQuery is used to query for the configuration of the channel,
     * such as FabricMSPConfig, and rorderer endpoints.
     * The client has to query a peer it trusts as it doesn't have means to self-verify
     * the authenticity of the returned result.
     * The result is returned in the form of ConfigResult.
     *
     * @generated from field: discovery.ConfigQuery config_query = 2;
     */
    value: ConfigQuery;
    case: "configQuery";
  } | {
    /**
     * PeerMembershipQuery queries for peers in a channel context,
     * and returns PeerMembershipResult
     *
     * @generated from field: discovery.PeerMembershipQuery peer_query = 3;
     */
    value: PeerMembershipQuery;
    case: "peerQuery";
  } | {
    /**
     * ChaincodeQuery queries for chaincodes by their name and version.
     * An empty version means any version can by returned.
     *
     * @generated from field: discovery.ChaincodeQuery cc_query = 4;
     */
    value: ChaincodeQuery;
    case: "ccQuery";
  } | {
    /**
     * LocalPeerQuery queries for peers in a non channel context,
     * and returns PeerMembershipResult
     *
     * @generated from field: discovery.LocalPeerQuery local_peers = 5;
     */
    value: LocalPeerQuery;
    case: "localPeers";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message discovery.Query.
 * Use `create(QuerySchema)` to create a new message.
 */
export const QuerySchema: GenMessage<Query> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 4);

/**
 * QueryResult contains a result for a given Query.
 * The corresponding Query can be inferred by the index of the QueryResult from
 * its enclosing Response message.
 * QueryResults are ordered in the same order as the Queries are ordered in their enclosing Request.
 *
 * @generated from message discovery.QueryResult
 */
export type QueryResult = Message<"discovery.QueryResult"> & {
  /**
   * @generated from oneof discovery.QueryResult.result
   */
  result: {
    /**
     * Error indicates failure or refusal to process the query
     *
     * @generated from field: discovery.Error error = 1;
     */
    value: Error;
    case: "error";
  } | {
    /**
     * ConfigResult contains the configuration of the channel,
     * such as FabricMSPConfig and orderer endpoints
     *
     * @generated from field: discovery.ConfigResult config_result = 2;
     */
    value: ConfigResult;
    case: "configResult";
  } | {
    /**
     * ChaincodeQueryResult contains information about chaincodes,
     * and their corresponding endorsers
     *
     * @generated from field: discovery.ChaincodeQueryResult cc_query_res = 3;
     */
    value: ChaincodeQueryResult;
    case: "ccQueryRes";
  } | {
    /**
     * PeerMembershipResult contains information about peers,
     * such as their identity, endpoints, and channel related state.
     *
     * @generated from field: discovery.PeerMembershipResult members = 4;
     */
    value: PeerMembershipResult;
    case: "members";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message discovery.QueryResult.
 * Use `create(QueryResultSchema)` to create a new message.
 */
export const QueryResultSchema: GenMessage<QueryResult> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 5);

/**
 * ConfigQuery requests a ConfigResult
 *
 * @generated from message discovery.ConfigQuery
 */
export type ConfigQuery = Message<"discovery.ConfigQuery"> & {
};

/**
 * Describes the message discovery.ConfigQuery.
 * Use `create(ConfigQuerySchema)` to create a new message.
 */
export const ConfigQuerySchema: GenMessage<ConfigQuery> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 6);

/**
 * @generated from message discovery.ConfigResult
 */
export type ConfigResult = Message<"discovery.ConfigResult"> & {
  /**
   * msps is a map from MSP_ID to FabricMSPConfig
   *
   * @generated from field: map<string, msp.FabricMSPConfig> msps = 1;
   */
  msps: { [key: string]: FabricMSPConfig };

  /**
   * orderers is a map from MSP_ID to endpoint lists of orderers
   *
   * @generated from field: map<string, discovery.Endpoints> orderers = 2;
   */
  orderers: { [key: string]: Endpoints };
};

/**
 * Describes the message discovery.ConfigResult.
 * Use `create(ConfigResultSchema)` to create a new message.
 */
export const ConfigResultSchema: GenMessage<ConfigResult> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 7);

/**
 * PeerMembershipQuery requests PeerMembershipResult.
 * The filter field may be optionally populated in order
 * for the peer membership to be filtered according to
 * chaincodes that are installed on peers and collection
 * access control policies.
 *
 * @generated from message discovery.PeerMembershipQuery
 */
export type PeerMembershipQuery = Message<"discovery.PeerMembershipQuery"> & {
  /**
   * @generated from field: discovery.ChaincodeInterest filter = 1;
   */
  filter?: ChaincodeInterest;
};

/**
 * Describes the message discovery.PeerMembershipQuery.
 * Use `create(PeerMembershipQuerySchema)` to create a new message.
 */
export const PeerMembershipQuerySchema: GenMessage<PeerMembershipQuery> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 8);

/**
 * PeerMembershipResult contains peers mapped by their organizations (MSP_ID)
 *
 * @generated from message discovery.PeerMembershipResult
 */
export type PeerMembershipResult = Message<"discovery.PeerMembershipResult"> & {
  /**
   * @generated from field: map<string, discovery.Peers> peers_by_org = 1;
   */
  peersByOrg: { [key: string]: Peers };
};

/**
 * Describes the message discovery.PeerMembershipResult.
 * Use `create(PeerMembershipResultSchema)` to create a new message.
 */
export const PeerMembershipResultSchema: GenMessage<PeerMembershipResult> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 9);

/**
 * ChaincodeQuery requests ChaincodeQueryResults for a given
 * list of chaincode invocations.
 * Each invocation is a separate one, and the endorsement policy
 * is evaluated independantly for each given interest.
 *
 * @generated from message discovery.ChaincodeQuery
 */
export type ChaincodeQuery = Message<"discovery.ChaincodeQuery"> & {
  /**
   * @generated from field: repeated discovery.ChaincodeInterest interests = 1;
   */
  interests: ChaincodeInterest[];
};

/**
 * Describes the message discovery.ChaincodeQuery.
 * Use `create(ChaincodeQuerySchema)` to create a new message.
 */
export const ChaincodeQuerySchema: GenMessage<ChaincodeQuery> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 10);

/**
 * ChaincodeInterest defines an interest about an endorsement
 * for a specific single chaincode invocation.
 * Multiple chaincodes indicate chaincode to chaincode invocations.
 *
 * @generated from message discovery.ChaincodeInterest
 */
export type ChaincodeInterest = Message<"discovery.ChaincodeInterest"> & {
  /**
   * @generated from field: repeated discovery.ChaincodeCall chaincodes = 1;
   */
  chaincodes: ChaincodeCall[];
};

/**
 * Describes the message discovery.ChaincodeInterest.
 * Use `create(ChaincodeInterestSchema)` to create a new message.
 */
export const ChaincodeInterestSchema: GenMessage<ChaincodeInterest> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 11);

/**
 * ChaincodeCall defines a call to a chaincode.
 * It may have collections that are related to the chaincode
 *
 * @generated from message discovery.ChaincodeCall
 */
export type ChaincodeCall = Message<"discovery.ChaincodeCall"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: repeated string collection_names = 2;
   */
  collectionNames: string[];

  /**
   * Indicates we do not need to read from private data
   *
   * @generated from field: bool no_private_reads = 3;
   */
  noPrivateReads: boolean;

  /**
   * Indicates we do not need to write to the chaincode namespace
   *
   * @generated from field: bool no_public_writes = 4;
   */
  noPublicWrites: boolean;
};

/**
 * Describes the message discovery.ChaincodeCall.
 * Use `create(ChaincodeCallSchema)` to create a new message.
 */
export const ChaincodeCallSchema: GenMessage<ChaincodeCall> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 12);

/**
 * ChaincodeQueryResult contains EndorsementDescriptors for
 * chaincodes
 *
 * @generated from message discovery.ChaincodeQueryResult
 */
export type ChaincodeQueryResult = Message<"discovery.ChaincodeQueryResult"> & {
  /**
   * @generated from field: repeated discovery.EndorsementDescriptor content = 1;
   */
  content: EndorsementDescriptor[];
};

/**
 * Describes the message discovery.ChaincodeQueryResult.
 * Use `create(ChaincodeQueryResultSchema)` to create a new message.
 */
export const ChaincodeQueryResultSchema: GenMessage<ChaincodeQueryResult> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 13);

/**
 * LocalPeerQuery queries for peers in a non channel context
 *
 * @generated from message discovery.LocalPeerQuery
 */
export type LocalPeerQuery = Message<"discovery.LocalPeerQuery"> & {
};

/**
 * Describes the message discovery.LocalPeerQuery.
 * Use `create(LocalPeerQuerySchema)` to create a new message.
 */
export const LocalPeerQuerySchema: GenMessage<LocalPeerQuery> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 14);

/**
 * EndorsementDescriptor contains information about which peers can be used
 * to request endorsement from, such that the endorsement policy would be fulfilled.
 * Here is how to compute a set of peers to ask an endorsement from, given an EndorsementDescriptor:
 * Let e: G --> P be the endorsers_by_groups field that maps a group to a set of peers.
 * Note that applying e on a group g yields a set of peers.
 * 1) Select a layout l: G --> N out of the layouts given.
 *    l is the quantities_by_group field of a Layout, and it maps a group to an integer.
 * 2) R = {}  (an empty set of peers)
 * 3) For each group g in the layout l, compute n = l(g)
 *    3.1) Denote P_g as a set of n random peers {p0, p1, ... p_n} selected from e(g)
 *    3.2) R = R U P_g  (add P_g to R)
 * 4) The set of peers R is the peers the client needs to request endorsements from
 *
 * @generated from message discovery.EndorsementDescriptor
 */
export type EndorsementDescriptor = Message<"discovery.EndorsementDescriptor"> & {
  /**
   * @generated from field: string chaincode = 1;
   */
  chaincode: string;

  /**
   * Specifies the endorsers, separated to groups.
   *
   * @generated from field: map<string, discovery.Peers> endorsers_by_groups = 2;
   */
  endorsersByGroups: { [key: string]: Peers };

  /**
   * Specifies options of fulfulling the endorsement policy.
   * Each option lists the group names, and the amount of signatures needed
   * from each group.
   *
   * @generated from field: repeated discovery.Layout layouts = 3;
   */
  layouts: Layout[];
};

/**
 * Describes the message discovery.EndorsementDescriptor.
 * Use `create(EndorsementDescriptorSchema)` to create a new message.
 */
export const EndorsementDescriptorSchema: GenMessage<EndorsementDescriptor> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 15);

/**
 * Layout contains a mapping from a group name to number of peers
 * that are needed for fulfilling an endorsement policy
 *
 * @generated from message discovery.Layout
 */
export type Layout = Message<"discovery.Layout"> & {
  /**
   * Specifies how many non repeated signatures of each group
   * are needed for endorsement
   *
   * @generated from field: map<string, uint32> quantities_by_group = 1;
   */
  quantitiesByGroup: { [key: string]: number };
};

/**
 * Describes the message discovery.Layout.
 * Use `create(LayoutSchema)` to create a new message.
 */
export const LayoutSchema: GenMessage<Layout> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 16);

/**
 * Peers contains a list of Peer(s)
 *
 * @generated from message discovery.Peers
 */
export type Peers = Message<"discovery.Peers"> & {
  /**
   * @generated from field: repeated discovery.Peer peers = 1;
   */
  peers: Peer[];
};

/**
 * Describes the message discovery.Peers.
 * Use `create(PeersSchema)` to create a new message.
 */
export const PeersSchema: GenMessage<Peers> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 17);

/**
 * Peer contains information about the peer such as its channel specific
 * state, and membership information.
 *
 * @generated from message discovery.Peer
 */
export type Peer = Message<"discovery.Peer"> & {
  /**
   * This is an Envelope of a GossipMessage with a gossip.StateInfo message
   *
   * @generated from field: gossip.Envelope state_info = 1;
   */
  stateInfo?: Envelope;

  /**
   * This is an Envelope of a GossipMessage with a gossip.AliveMessage message
   *
   * @generated from field: gossip.Envelope membership_info = 2;
   */
  membershipInfo?: Envelope;

  /**
   * This is the msp.SerializedIdentity of the peer, represented in bytes.
   *
   * @generated from field: bytes identity = 3;
   */
  identity: Uint8Array;
};

/**
 * Describes the message discovery.Peer.
 * Use `create(PeerSchema)` to create a new message.
 */
export const PeerSchema: GenMessage<Peer> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 18);

/**
 * Error denotes that something went wrong and contains the error message
 *
 * @generated from message discovery.Error
 */
export type Error = Message<"discovery.Error"> & {
  /**
   * @generated from field: string content = 1;
   */
  content: string;
};

/**
 * Describes the message discovery.Error.
 * Use `create(ErrorSchema)` to create a new message.
 */
export const ErrorSchema: GenMessage<Error> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 19);

/**
 * Endpoints is a list of Endpoint(s)
 *
 * @generated from message discovery.Endpoints
 */
export type Endpoints = Message<"discovery.Endpoints"> & {
  /**
   * @generated from field: repeated discovery.Endpoint endpoint = 1;
   */
  endpoint: Endpoint[];
};

/**
 * Describes the message discovery.Endpoints.
 * Use `create(EndpointsSchema)` to create a new message.
 */
export const EndpointsSchema: GenMessage<Endpoints> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 20);

/**
 * Endpoint is a combination of a host and a port
 *
 * @generated from message discovery.Endpoint
 */
export type Endpoint = Message<"discovery.Endpoint"> & {
  /**
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * @generated from field: uint32 port = 2;
   */
  port: number;
};

/**
 * Describes the message discovery.Endpoint.
 * Use `create(EndpointSchema)` to create a new message.
 */
export const EndpointSchema: GenMessage<Endpoint> = /*@__PURE__*/
  messageDesc(file_discovery_protocol, 21);

/**
 * Discovery defines a service that serves information about the fabric network
 * like which peers, orderers, chaincodes, etc.
 *
 * @generated from service discovery.Discovery
 */
export const Discovery: GenService<{
  /**
   * Discover receives a signed request, and returns a response.
   *
   * @generated from rpc discovery.Discovery.Discover
   */
  discover: {
    methodKind: "unary";
    input: typeof SignedRequestSchema;
    output: typeof ResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_discovery_protocol, 0);

