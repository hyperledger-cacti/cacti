/* tslint:disable */
/* eslint-disable */
/**
 * Hyperledger Cactus Plugin - Connector Fabric
 * Can perform basic tasks on a fabric ledger
 *
 * The version of the OpenAPI document: v2.0.0-alpha.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Enumerates the supported programming language runtimes of Hyperledger Fabric
 * @export
 * @enum {string}
 */

export const ChainCodeLanguageRuntime = {
    Golang: 'golang',
    Node: 'node',
    Java: 'java'
} as const;

export type ChainCodeLanguageRuntime = typeof ChainCodeLanguageRuntime[keyof typeof ChainCodeLanguageRuntime];


/**
 * 
 * @export
 * @interface ChainCodeLifeCycleCommandResponses
 */
export interface ChainCodeLifeCycleCommandResponses {
    /**
     * 
     * @type {SSHExecCommandResponse}
     * @memberof ChainCodeLifeCycleCommandResponses
     */
    'packaging'?: SSHExecCommandResponse;
    /**
     * 
     * @type {Array<SSHExecCommandResponse>}
     * @memberof ChainCodeLifeCycleCommandResponses
     */
    'installList': Array<SSHExecCommandResponse>;
    /**
     * 
     * @type {Array<SSHExecCommandResponse>}
     * @memberof ChainCodeLifeCycleCommandResponses
     */
    'queryInstalledList': Array<SSHExecCommandResponse>;
    /**
     * 
     * @type {Array<SSHExecCommandResponse>}
     * @memberof ChainCodeLifeCycleCommandResponses
     */
    'approveForMyOrgList': Array<SSHExecCommandResponse>;
    /**
     * 
     * @type {SSHExecCommandResponse}
     * @memberof ChainCodeLifeCycleCommandResponses
     */
    'commit'?: SSHExecCommandResponse;
    /**
     * 
     * @type {SSHExecCommandResponse}
     * @memberof ChainCodeLifeCycleCommandResponses
     */
    'queryCommitted'?: SSHExecCommandResponse;
    /**
     * 
     * @type {SSHExecCommandResponse}
     * @memberof ChainCodeLifeCycleCommandResponses
     */
    'init'?: SSHExecCommandResponse;
}
/**
 * Enumerates the supported source code programming languages of Hyperledger Fabric
 * @export
 * @enum {string}
 */

export const ChainCodeProgrammingLanguage = {
    Golang: 'golang',
    Javascript: 'javascript',
    Typescript: 'typescript',
    Java: 'java'
} as const;

export type ChainCodeProgrammingLanguage = typeof ChainCodeProgrammingLanguage[keyof typeof ChainCodeProgrammingLanguage];


/**
 * 
 * @export
 * @interface ConnectionProfile
 */
export interface ConnectionProfile {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ConnectionProfile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionProfile
     */
    'x-type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionProfile
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectionProfile
     */
    'version': string;
    /**
     * 
     * @type {ConnectionProfileClient}
     * @memberof ConnectionProfile
     */
    'client'?: ConnectionProfileClient;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ConnectionProfile
     */
    'channels'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ConnectionProfile
     */
    'organizations': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ConnectionProfile
     */
    'orderers'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ConnectionProfile
     */
    'peers': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ConnectionProfile
     */
    'certificateAuthorities'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ConnectionProfileClient
 */
export interface ConnectionProfileClient {
    /**
     * 
     * @type {string}
     * @memberof ConnectionProfileClient
     */
    'organization'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DefaultEventHandlerStrategy = {
    MspidScopeAllfortx: 'MSPID_SCOPE_ALLFORTX',
    MspidScopeAnyfortx: 'MSPID_SCOPE_ANYFORTX',
    NetworkScopeAllfortx: 'NETWORK_SCOPE_ALLFORTX',
    NetworkScopeAnyfortx: 'NETWORK_SCOPE_ANYFORTX'
} as const;

export type DefaultEventHandlerStrategy = typeof DefaultEventHandlerStrategy[keyof typeof DefaultEventHandlerStrategy];


/**
 * 
 * @export
 * @interface DeployContractGoSourceV1501Response
 */
export interface DeployContractGoSourceV1501Response {
    /**
     * 
     * @type {string}
     * @memberof DeployContractGoSourceV1501Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeployContractGoSourceV1Request
 */
export interface DeployContractGoSourceV1Request {
    /**
     * 
     * @type {string}
     * @memberof DeployContractGoSourceV1Request
     */
    'policyDslSource': string;
    /**
     * The TLS root cert files that will be passed to the chaincode instantiation command.
     * @type {string}
     * @memberof DeployContractGoSourceV1Request
     */
    'tlsRootCertFiles': string;
    /**
     * The name of the Fabric channel where the contract will get instantiated.
     * @type {string}
     * @memberof DeployContractGoSourceV1Request
     */
    'channelId': string;
    /**
     * 
     * @type {Array<DeploymentTargetOrganization>}
     * @memberof DeployContractGoSourceV1Request
     */
    'targetOrganizations': Array<DeploymentTargetOrganization>;
    /**
     * An array of peer addresses where the contract will be instantiated. Note that at present only the first item from this array will be used which is the behavior taken from the official Fabric samples repository and therefore it is assumed to be correct usage.
     * @type {Array<string>}
     * @memberof DeployContractGoSourceV1Request
     */
    'targetPeerAddresses': Array<string>;
    /**
     * 
     * @type {DeployContractGoSourceV1RequestConstructorArgs}
     * @memberof DeployContractGoSourceV1Request
     */
    'constructorArgs'?: DeployContractGoSourceV1RequestConstructorArgs;
    /**
     * 
     * @type {string}
     * @memberof DeployContractGoSourceV1Request
     */
    'chainCodeVersion': string;
    /**
     * 
     * @type {FileBase64}
     * @memberof DeployContractGoSourceV1Request
     */
    'goSource': FileBase64;
    /**
     * 
     * @type {FileBase64}
     * @memberof DeployContractGoSourceV1Request
     */
    'goMod'?: FileBase64;
    /**
     * The go module name that will be used for the go compilation process.
     * @type {string}
     * @memberof DeployContractGoSourceV1Request
     */
    'moduleName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployContractGoSourceV1Request
     */
    'pinnedDeps'?: Array<string>;
    /**
     * Indicates to the go chaincode compiler of Cactus if it should do an actual go compilation with the contact source or if it should just execute the go mod tidy command.
     * @type {boolean}
     * @memberof DeployContractGoSourceV1Request
     */
    'modTidyOnly'?: boolean | null;
}
/**
 * 
 * @export
 * @interface DeployContractGoSourceV1RequestConstructorArgs
 */
export interface DeployContractGoSourceV1RequestConstructorArgs {
    /**
     * 
     * @type {Array<any>}
     * @memberof DeployContractGoSourceV1RequestConstructorArgs
     */
    'Args'?: Array<any>;
}
/**
 * 
 * @export
 * @interface DeployContractGoSourceV1Response
 */
export interface DeployContractGoSourceV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof DeployContractGoSourceV1Response
     */
    'success': boolean;
    /**
     * 
     * @type {Array<SSHExecCommandResponse>}
     * @memberof DeployContractGoSourceV1Response
     */
    'installationCommandResponses': Array<SSHExecCommandResponse>;
    /**
     * 
     * @type {SSHExecCommandResponse}
     * @memberof DeployContractGoSourceV1Response
     */
    'instantiationCommandResponse': SSHExecCommandResponse;
}
/**
 * 
 * @export
 * @interface DeployContractV1Request
 */
export interface DeployContractV1Request {
    /**
     * 
     * @type {ChainCodeProgrammingLanguage}
     * @memberof DeployContractV1Request
     */
    'ccLang': ChainCodeProgrammingLanguage;
    /**
     * File-system path pointing at the CA file.
     * @type {string}
     * @memberof DeployContractV1Request
     */
    'caFile': string;
    /**
     * Ordering service endpoint specified as <hostname or IP address>:<port>
     * @type {string}
     * @memberof DeployContractV1Request
     */
    'orderer': string;
    /**
     * The hostname override to use when validating the TLS connection to the orderer
     * @type {string}
     * @memberof DeployContractV1Request
     */
    'ordererTLSHostnameOverride': string;
    /**
     * Timeout for client to connect (default 3s)
     * @type {number}
     * @memberof DeployContractV1Request
     */
    'connTimeout'?: number;
    /**
     * Passed in to the peer via the --signature-policy argument on the command line. See also: https://hyperledger-fabric.readthedocs.io/en/release-2.2/endorsement-policies.html#setting-chaincode-level-endorsement-policies
     * @type {string}
     * @memberof DeployContractV1Request
     */
    'signaturePolicy'?: string;
    /**
     * Name of the collections config file as present in the sourceFiles array of the request.
     * @type {string}
     * @memberof DeployContractV1Request
     */
    'collectionsConfigFile'?: string;
    /**
     * The name of the Fabric channel where the contract will get instantiated.
     * @type {string}
     * @memberof DeployContractV1Request
     */
    'channelId': string;
    /**
     * 
     * @type {Array<DeploymentTargetOrganization>}
     * @memberof DeployContractV1Request
     */
    'targetOrganizations': Array<DeploymentTargetOrganization>;
    /**
     * 
     * @type {DeployContractGoSourceV1RequestConstructorArgs}
     * @memberof DeployContractV1Request
     */
    'constructorArgs'?: DeployContractGoSourceV1RequestConstructorArgs;
    /**
     * 
     * @type {number}
     * @memberof DeployContractV1Request
     */
    'ccSequence': number;
    /**
     * 
     * @type {string}
     * @memberof DeployContractV1Request
     */
    'ccVersion': string;
    /**
     * 
     * @type {string}
     * @memberof DeployContractV1Request
     */
    'ccName': string;
    /**
     * Human readable label to uniquely identify the contract. Recommended to include in this at least the contract name and the exact version in order to make it easily distinguishable from other deployments of the same contract.
     * @type {string}
     * @memberof DeployContractV1Request
     */
    'ccLabel': string;
    /**
     * The your-smart-contract.go file where the functionality of your contract is implemented.
     * @type {Array<FileBase64>}
     * @memberof DeployContractV1Request
     */
    'sourceFiles': Array<FileBase64>;
}


/**
 * 
 * @export
 * @interface DeployContractV1Response
 */
export interface DeployContractV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof DeployContractV1Response
     */
    'success': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployContractV1Response
     */
    'packageIds': Array<string>;
    /**
     * 
     * @type {ChainCodeLifeCycleCommandResponses}
     * @memberof DeployContractV1Response
     */
    'lifecycle': ChainCodeLifeCycleCommandResponses;
}
/**
 * 
 * @export
 * @interface DeploymentTargetOrgFabric2x
 */
export interface DeploymentTargetOrgFabric2x {
    /**
     * Transient map of arguments in JSON encoding
     * @type {string}
     * @memberof DeploymentTargetOrgFabric2x
     */
    'transient'?: string;
    /**
     * Mapped to environment variables of the Fabric CLI container.
     * @type {string}
     * @memberof DeploymentTargetOrgFabric2x
     */
    'CORE_PEER_LOCALMSPID': string;
    /**
     * Mapped to environment variables of the Fabric CLI container.
     * @type {string}
     * @memberof DeploymentTargetOrgFabric2x
     */
    'CORE_PEER_ADDRESS': string;
    /**
     * Mapped to environment variables of the Fabric CLI container.
     * @type {string}
     * @memberof DeploymentTargetOrgFabric2x
     */
    'CORE_PEER_MSPCONFIGPATH': string;
    /**
     * Mapped to environment variables of the Fabric CLI container.
     * @type {string}
     * @memberof DeploymentTargetOrgFabric2x
     */
    'CORE_PEER_TLS_ROOTCERT_FILE': string;
    /**
     * Mapped to environment variables of the Fabric CLI container.
     * @type {string}
     * @memberof DeploymentTargetOrgFabric2x
     */
    'ORDERER_TLS_ROOTCERT_FILE': string;
}
/**
 * 
 * @export
 * @interface DeploymentTargetOrganization
 */
export interface DeploymentTargetOrganization {
    /**
     * Mapped to environment variables of the Fabric CLI container.
     * @type {string}
     * @memberof DeploymentTargetOrganization
     */
    'CORE_PEER_LOCALMSPID': string;
    /**
     * Mapped to environment variables of the Fabric CLI container.
     * @type {string}
     * @memberof DeploymentTargetOrganization
     */
    'CORE_PEER_ADDRESS': string;
    /**
     * Mapped to environment variables of the Fabric CLI container.
     * @type {string}
     * @memberof DeploymentTargetOrganization
     */
    'CORE_PEER_MSPCONFIGPATH': string;
    /**
     * Mapped to environment variables of the Fabric CLI container.
     * @type {string}
     * @memberof DeploymentTargetOrganization
     */
    'CORE_PEER_TLS_ROOTCERT_FILE': string;
    /**
     * Mapped to environment variables of the Fabric CLI container.
     * @type {string}
     * @memberof DeploymentTargetOrganization
     */
    'ORDERER_TLS_ROOTCERT_FILE': string;
}
/**
 * 
 * @export
 * @interface ErrorExceptionResponseV1
 */
export interface ErrorExceptionResponseV1 {
    /**
     * 
     * @type {string}
     * @memberof ErrorExceptionResponseV1
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorExceptionResponseV1
     */
    'error': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FabricContractInvocationType = {
    Send: 'FabricContractInvocationType.SEND',
    Call: 'FabricContractInvocationType.CALL',
    Sendprivate: 'FabricContractInvocationType.SENDPRIVATE'
} as const;

export type FabricContractInvocationType = typeof FabricContractInvocationType[keyof typeof FabricContractInvocationType];


/**
 * 
 * @export
 * @interface FabricSigningCredential
 */
export interface FabricSigningCredential {
    /**
     * 
     * @type {string}
     * @memberof FabricSigningCredential
     */
    'keychainId': string;
    /**
     * 
     * @type {string}
     * @memberof FabricSigningCredential
     */
    'keychainRef': string;
    /**
     * 
     * @type {FabricSigningCredentialType}
     * @memberof FabricSigningCredential
     */
    'type'?: FabricSigningCredentialType;
    /**
     * 
     * @type {VaultTransitKey}
     * @memberof FabricSigningCredential
     */
    'vaultTransitKey'?: VaultTransitKey;
    /**
     * 
     * @type {WebSocketKey}
     * @memberof FabricSigningCredential
     */
    'webSocketKey'?: WebSocketKey;
}


/**
 * different type of identity provider for singing fabric messages supported by this package
 * @export
 * @enum {string}
 */

export const FabricSigningCredentialType = {
    X509: 'X.509',
    VaultX509: 'Vault-X.509',
    WsX509: 'WS-X.509'
} as const;

export type FabricSigningCredentialType = typeof FabricSigningCredentialType[keyof typeof FabricSigningCredentialType];


/**
 * Represents a file-system file that has a name and a body which holds the file contents as a Base64 encoded string
 * @export
 * @interface FileBase64
 */
export interface FileBase64 {
    /**
     * The file\'s contents encoded as a Base64 string.
     * @type {string}
     * @memberof FileBase64
     */
    'body': string;
    /**
     * The name as referred to on a file system
     * @type {string}
     * @memberof FileBase64
     */
    'filename': string;
    /**
     * The relative path of the file, if it should be placed in a sub-directory
     * @type {string}
     * @memberof FileBase64
     */
    'filepath'?: string;
}
/**
 * 
 * @export
 * @interface GatewayDiscoveryOptions
 */
export interface GatewayDiscoveryOptions {
    /**
     * 
     * @type {boolean}
     * @memberof GatewayDiscoveryOptions
     */
    'asLocalhost'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GatewayDiscoveryOptions
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface GatewayEventHandlerOptions
 */
export interface GatewayEventHandlerOptions {
    /**
     * 
     * @type {number}
     * @memberof GatewayEventHandlerOptions
     */
    'commitTimeout'?: number;
    /**
     * 
     * @type {number}
     * @memberof GatewayEventHandlerOptions
     */
    'endorseTimeout'?: number;
    /**
     * 
     * @type {DefaultEventHandlerStrategy}
     * @memberof GatewayEventHandlerOptions
     */
    'strategy': DefaultEventHandlerStrategy;
}


/**
 * 
 * @export
 * @interface GatewayOptions
 */
export interface GatewayOptions {
    /**
     * 
     * @type {ConnectionProfile}
     * @memberof GatewayOptions
     */
    'connectionProfile'?: ConnectionProfile;
    /**
     * 
     * @type {GatewayDiscoveryOptions}
     * @memberof GatewayOptions
     */
    'discovery'?: GatewayDiscoveryOptions;
    /**
     * 
     * @type {GatewayEventHandlerOptions}
     * @memberof GatewayOptions
     */
    'eventHandlerOptions'?: GatewayEventHandlerOptions;
    /**
     * 
     * @type {string}
     * @memberof GatewayOptions
     */
    'identity': string;
    /**
     * 
     * @type {GatewayOptionsWallet}
     * @memberof GatewayOptions
     */
    'wallet': GatewayOptionsWallet;
}
/**
 * 
 * @export
 * @interface GatewayOptionsWallet
 */
export interface GatewayOptionsWallet {
    /**
     * 
     * @type {FabricSigningCredential}
     * @memberof GatewayOptionsWallet
     */
    'keychain'?: FabricSigningCredential;
    /**
     * 
     * @type {string}
     * @memberof GatewayOptionsWallet
     */
    'json'?: string;
}
/**
 * Request for GetBlock endpoint.
 * @export
 * @interface GetBlockRequestV1
 */
export interface GetBlockRequestV1 {
    /**
     * Fabric channel which we want to query.
     * @type {string}
     * @memberof GetBlockRequestV1
     */
    'channelName': string;
    /**
     * Fabric channel we want to connect to. If not provided, then one from channelName parameter will be used
     * @type {string}
     * @memberof GetBlockRequestV1
     */
    'connectionChannelName'?: string;
    /**
     * 
     * @type {GatewayOptions}
     * @memberof GetBlockRequestV1
     */
    'gatewayOptions': GatewayOptions;
    /**
     * 
     * @type {GetBlockRequestV1Query}
     * @memberof GetBlockRequestV1
     */
    'query': GetBlockRequestV1Query;
    /**
     * If true, encoded buffer will be returned. Otherwise, entire block object is returned.
     * @type {boolean}
     * @memberof GetBlockRequestV1
     */
    'skipDecode'?: boolean;
}
/**
 * Query selector, caller must provide at least one of them. First found will be used, rest will be ignored, so it\'s recommended to pass single selector.
 * @export
 * @interface GetBlockRequestV1Query
 */
export interface GetBlockRequestV1Query {
    /**
     * Select block by it\'s number.
     * @type {string}
     * @memberof GetBlockRequestV1Query
     */
    'blockNumber'?: string;
    /**
     * 
     * @type {GetBlockRequestV1QueryBlockHash}
     * @memberof GetBlockRequestV1Query
     */
    'blockHash'?: GetBlockRequestV1QueryBlockHash;
    /**
     * Select block by id of transaction that it contains.
     * @type {string}
     * @memberof GetBlockRequestV1Query
     */
    'transactionId'?: string;
}
/**
 * Select block by it\'s hash.
 * @export
 * @interface GetBlockRequestV1QueryBlockHash
 */
export interface GetBlockRequestV1QueryBlockHash {
    /**
     * NodeJS Buffer encoding (utf-8, hex, binary, base64, etc...). Passed directly to `Buffer.from()` call on hashBuffer. If not provided then JSON buffer format is assumed.
     * @type {string}
     * @memberof GetBlockRequestV1QueryBlockHash
     */
    'encoding'?: string;
    /**
     * Buffer of blockHash. It\'s encoding should be described in `encoding` parameter.
     * @type {string}
     * @memberof GetBlockRequestV1QueryBlockHash
     */
    'buffer': string;
}
/**
 * When skipDecode is false (default) then decoded block object is returned.
 * @export
 * @interface GetBlockResponseDecodedV1
 */
export interface GetBlockResponseDecodedV1 {
    /**
     * Full hyperledger fabric block data.
     * @type {any}
     * @memberof GetBlockResponseDecodedV1
     */
    'decodedBlock': any;
}
/**
 * When skipDecode is true then encoded block Buffer is returned.
 * @export
 * @interface GetBlockResponseEncodedV1
 */
export interface GetBlockResponseEncodedV1 {
    /**
     * 
     * @type {string}
     * @memberof GetBlockResponseEncodedV1
     */
    'encodedBlock': string;
}
/**
 * @type GetBlockResponseV1
 * Response from GetBlock endpoint.
 * @export
 */
export type GetBlockResponseV1 = GetBlockResponseDecodedV1 | GetBlockResponseEncodedV1;

/**
 * 
 * @export
 * @interface GetTransactionReceiptResponse
 */
export interface GetTransactionReceiptResponse {
    /**
     * 
     * @type {string}
     * @memberof GetTransactionReceiptResponse
     */
    'blockNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionReceiptResponse
     */
    'channelID'?: string;
    /**
     * 
     * @type {TransactReceiptTransactionCreator}
     * @memberof GetTransactionReceiptResponse
     */
    'transactionCreator'?: TransactReceiptTransactionCreator;
    /**
     * 
     * @type {Array<TransactReceiptTransactionEndorsement>}
     * @memberof GetTransactionReceiptResponse
     */
    'transactionEndorsement'?: Array<TransactReceiptTransactionEndorsement>;
    /**
     * 
     * @type {TransactReceiptBlockMetaData}
     * @memberof GetTransactionReceiptResponse
     */
    'blockMetaData'?: TransactReceiptBlockMetaData;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionReceiptResponse
     */
    'chainCodeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionReceiptResponse
     */
    'chainCodeVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionReceiptResponse
     */
    'responseStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionReceiptResponse
     */
    'rwsetKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionReceiptResponse
     */
    'rwsetWriteData'?: string;
}
/**
 * 
 * @export
 * @interface RunDelegatedSignTransactionRequest
 */
export interface RunDelegatedSignTransactionRequest {
    /**
     * An array of endorsing peers (name or url) for the transaction.
     * @type {Array<string>}
     * @memberof RunDelegatedSignTransactionRequest
     */
    'endorsingPeers'?: Array<string>;
    /**
     * An array of endorsing organizations (by mspID or issuer org name on certificate) for the transaction.
     * @type {Array<string>}
     * @memberof RunDelegatedSignTransactionRequest
     */
    'endorsingOrgs'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof RunDelegatedSignTransactionRequest
     */
    'transientData'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof RunDelegatedSignTransactionRequest
     */
    'signerCertificate': string;
    /**
     * 
     * @type {string}
     * @memberof RunDelegatedSignTransactionRequest
     */
    'signerMspID': string;
    /**
     * Can be used to uniquely identify and authorize signing request
     * @type {any}
     * @memberof RunDelegatedSignTransactionRequest
     */
    'uniqueTransactionData'?: any;
    /**
     * 
     * @type {string}
     * @memberof RunDelegatedSignTransactionRequest
     */
    'channelName': string;
    /**
     * 
     * @type {string}
     * @memberof RunDelegatedSignTransactionRequest
     */
    'contractName': string;
    /**
     * 
     * @type {FabricContractInvocationType}
     * @memberof RunDelegatedSignTransactionRequest
     */
    'invocationType': FabricContractInvocationType;
    /**
     * 
     * @type {string}
     * @memberof RunDelegatedSignTransactionRequest
     */
    'methodName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RunDelegatedSignTransactionRequest
     */
    'params': Array<string>;
    /**
     * 
     * @type {RunTransactionResponseType}
     * @memberof RunDelegatedSignTransactionRequest
     */
    'responseType'?: RunTransactionResponseType;
}


/**
 * 
 * @export
 * @interface RunTransactionRequest
 */
export interface RunTransactionRequest {
    /**
     * An array of endorsing peers (name or url) for the transaction.
     * @type {Array<string>}
     * @memberof RunTransactionRequest
     */
    'endorsingPeers'?: Array<string>;
    /**
     * An array of endorsing organizations (by mspID or issuer org name on certificate) for the transaction.
     * @type {Array<string>}
     * @memberof RunTransactionRequest
     */
    'endorsingOrgs'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof RunTransactionRequest
     */
    'transientData'?: object | null;
    /**
     * 
     * @type {GatewayOptions}
     * @memberof RunTransactionRequest
     */
    'gatewayOptions'?: GatewayOptions;
    /**
     * 
     * @type {FabricSigningCredential}
     * @memberof RunTransactionRequest
     */
    'signingCredential': FabricSigningCredential;
    /**
     * 
     * @type {string}
     * @memberof RunTransactionRequest
     */
    'channelName': string;
    /**
     * 
     * @type {string}
     * @memberof RunTransactionRequest
     */
    'contractName': string;
    /**
     * 
     * @type {FabricContractInvocationType}
     * @memberof RunTransactionRequest
     */
    'invocationType': FabricContractInvocationType;
    /**
     * 
     * @type {string}
     * @memberof RunTransactionRequest
     */
    'methodName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RunTransactionRequest
     */
    'params': Array<string>;
    /**
     * 
     * @type {RunTransactionResponseType}
     * @memberof RunTransactionRequest
     */
    'responseType'?: RunTransactionResponseType;
}


/**
 * 
 * @export
 * @interface RunTransactionResponse
 */
export interface RunTransactionResponse {
    /**
     * 
     * @type {string}
     * @memberof RunTransactionResponse
     */
    'functionOutput': string;
    /**
     * 
     * @type {string}
     * @memberof RunTransactionResponse
     */
    'transactionId': string;
}
/**
 * Response format from transaction / query execution
 * @export
 * @enum {string}
 */

export const RunTransactionResponseType = {
    JSON: 'org.hyperledger.cacti.api.hlfabric.RunTransactionResponseType.JSON',
    UTF8: 'org.hyperledger.cacti.api.hlfabric.RunTransactionResponseType.UTF8'
} as const;

export type RunTransactionResponseType = typeof RunTransactionResponseType[keyof typeof RunTransactionResponseType];


/**
 * 
 * @export
 * @interface SSHExecCommandResponse
 */
export interface SSHExecCommandResponse {
    /**
     * 
     * @type {string}
     * @memberof SSHExecCommandResponse
     */
    'stdout': string;
    /**
     * 
     * @type {string}
     * @memberof SSHExecCommandResponse
     */
    'stderr': string;
    /**
     * 
     * @type {number}
     * @memberof SSHExecCommandResponse
     */
    'code': number | null;
    /**
     * 
     * @type {string}
     * @memberof SSHExecCommandResponse
     */
    'signal': string | null;
}
/**
 * 
 * @export
 * @interface TransactReceiptBlockMetaData
 */
export interface TransactReceiptBlockMetaData {
    /**
     * 
     * @type {string}
     * @memberof TransactReceiptBlockMetaData
     */
    'mspid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactReceiptBlockMetaData
     */
    'blockCreatorID'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactReceiptBlockMetaData
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface TransactReceiptTransactionCreator
 */
export interface TransactReceiptTransactionCreator {
    /**
     * 
     * @type {string}
     * @memberof TransactReceiptTransactionCreator
     */
    'mspid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactReceiptTransactionCreator
     */
    'creatorID'?: string;
}
/**
 * 
 * @export
 * @interface TransactReceiptTransactionEndorsement
 */
export interface TransactReceiptTransactionEndorsement {
    /**
     * 
     * @type {string}
     * @memberof TransactReceiptTransactionEndorsement
     */
    'mspid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactReceiptTransactionEndorsement
     */
    'endorserID'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactReceiptTransactionEndorsement
     */
    'signature'?: string;
}
/**
 * vault key details for signing fabric message with private key stored with transit engine.
 * @export
 * @interface VaultTransitKey
 */
export interface VaultTransitKey {
    /**
     * label of private key
     * @type {string}
     * @memberof VaultTransitKey
     */
    'keyName': string;
    /**
     * token for accessing private key
     * @type {string}
     * @memberof VaultTransitKey
     */
    'token': string;
}
/**
 * Error response from WatchBlocks operation.
 * @export
 * @interface WatchBlocksCactusErrorResponseV1
 */
export interface WatchBlocksCactusErrorResponseV1 {
    /**
     * Error code.
     * @type {number}
     * @memberof WatchBlocksCactusErrorResponseV1
     */
    'code': number;
    /**
     * Description of the error.
     * @type {string}
     * @memberof WatchBlocksCactusErrorResponseV1
     */
    'errorMessage': string;
}
/**
 * Transaction summary from commited block.
 * @export
 * @interface WatchBlocksCactusTransactionsEventV1
 */
export interface WatchBlocksCactusTransactionsEventV1 {
    /**
     * ChainCode containing function that was executed.
     * @type {string}
     * @memberof WatchBlocksCactusTransactionsEventV1
     */
    'chaincodeId': string;
    /**
     * Transaction identifier.
     * @type {string}
     * @memberof WatchBlocksCactusTransactionsEventV1
     */
    'transactionId': string;
    /**
     * Function name that was executed.
     * @type {string}
     * @memberof WatchBlocksCactusTransactionsEventV1
     */
    'functionName': string;
    /**
     * List of function arguments.
     * @type {Array<string>}
     * @memberof WatchBlocksCactusTransactionsEventV1
     */
    'functionArgs': Array<string>;
}
/**
 * Custom response containing block transactions summary. Compatible with legacy fabric-socketio connector monitoring.
 * @export
 * @interface WatchBlocksCactusTransactionsResponseV1
 */
export interface WatchBlocksCactusTransactionsResponseV1 {
    /**
     * List of transactions summary
     * @type {Array<WatchBlocksCactusTransactionsEventV1>}
     * @memberof WatchBlocksCactusTransactionsResponseV1
     */
    'cactusTransactionsEvents': Array<WatchBlocksCactusTransactionsEventV1>;
}
/**
 * Options passed when subscribing to block monitoring with delegated signing.
 * @export
 * @interface WatchBlocksDelegatedSignOptionsV1
 */
export interface WatchBlocksDelegatedSignOptionsV1 {
    /**
     * 
     * @type {WatchBlocksListenerTypeV1}
     * @memberof WatchBlocksDelegatedSignOptionsV1
     */
    'type': WatchBlocksListenerTypeV1;
    /**
     * From which block start monitoring. Defaults to latest.
     * @type {string}
     * @memberof WatchBlocksDelegatedSignOptionsV1
     */
    'startBlock'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchBlocksDelegatedSignOptionsV1
     */
    'channelName': string;
    /**
     * 
     * @type {string}
     * @memberof WatchBlocksDelegatedSignOptionsV1
     */
    'signerCertificate': string;
    /**
     * 
     * @type {string}
     * @memberof WatchBlocksDelegatedSignOptionsV1
     */
    'signerMspID': string;
    /**
     * Can be used to uniquely identify and authorize signing request
     * @type {any}
     * @memberof WatchBlocksDelegatedSignOptionsV1
     */
    'uniqueTransactionData'?: any;
}


/**
 * Response that corresponds to Fabric SDK \'filtered\' EventType.
 * @export
 * @interface WatchBlocksFilteredResponseV1
 */
export interface WatchBlocksFilteredResponseV1 {
    /**
     * Filtered commited block.
     * @type {any}
     * @memberof WatchBlocksFilteredResponseV1
     */
    'filteredBlock': any;
}
/**
 * Response that corresponds to Fabric SDK \'full\' EventType.
 * @export
 * @interface WatchBlocksFullResponseV1
 */
export interface WatchBlocksFullResponseV1 {
    /**
     * Full commited block.
     * @type {any}
     * @memberof WatchBlocksFullResponseV1
     */
    'fullBlock': any;
}
/**
 * Response type from WatchBlocks. \'Cactus*\' are custom views, others correspond to fabric SDK call.
 * @export
 * @enum {string}
 */

export const WatchBlocksListenerTypeV1 = {
    Filtered: 'filtered',
    Full: 'full',
    Private: 'private',
    CactusTransactions: 'cactus:transactions'
} as const;

export type WatchBlocksListenerTypeV1 = typeof WatchBlocksListenerTypeV1[keyof typeof WatchBlocksListenerTypeV1];


/**
 * Options passed when subscribing to block monitoring.
 * @export
 * @interface WatchBlocksOptionsV1
 */
export interface WatchBlocksOptionsV1 {
    /**
     * Hyperledger Fabric channel to connect to.
     * @type {string}
     * @memberof WatchBlocksOptionsV1
     */
    'channelName': string;
    /**
     * 
     * @type {GatewayOptions}
     * @memberof WatchBlocksOptionsV1
     */
    'gatewayOptions': GatewayOptions;
    /**
     * 
     * @type {WatchBlocksListenerTypeV1}
     * @memberof WatchBlocksOptionsV1
     */
    'type': WatchBlocksListenerTypeV1;
    /**
     * From which block start monitoring. Defaults to latest.
     * @type {string}
     * @memberof WatchBlocksOptionsV1
     */
    'startBlock'?: string;
}


/**
 * Response that corresponds to Fabric SDK \'private\' EventType.
 * @export
 * @interface WatchBlocksPrivateResponseV1
 */
export interface WatchBlocksPrivateResponseV1 {
    /**
     * Private commited block.
     * @type {any}
     * @memberof WatchBlocksPrivateResponseV1
     */
    'privateBlock': any;
}
/**
 * @type WatchBlocksResponseV1
 * Response block from WatchBlocks endpoint. Depends on \'type\' passed in subscription options.
 * @export
 */
export type WatchBlocksResponseV1 = WatchBlocksCactusErrorResponseV1 | WatchBlocksCactusTransactionsResponseV1 | WatchBlocksFilteredResponseV1 | WatchBlocksFullResponseV1 | WatchBlocksPrivateResponseV1;

/**
 * Websocket requests for monitoring new blocks.
 * @export
 * @enum {string}
 */

export const WatchBlocksV1 = {
    Subscribe: 'org.hyperledger.cactus.api.async.hlfabric.WatchBlocksV1.Subscribe',
    SubscribeDelegatedSign: 'org.hyperledger.cactus.api.async.hlfabric.WatchBlocksV1.SubscribeDelegatedSign',
    Next: 'org.hyperledger.cactus.api.async.hlfabric.WatchBlocksV1.Next',
    Unsubscribe: 'org.hyperledger.cactus.api.async.hlfabric.WatchBlocksV1.Unsubscribe',
    Error: 'org.hyperledger.cactus.api.async.hlfabric.WatchBlocksV1.Error',
    Complete: 'org.hyperledger.cactus.api.async.hlfabric.WatchBlocksV1.Complete'
} as const;

export type WatchBlocksV1 = typeof WatchBlocksV1[keyof typeof WatchBlocksV1];


/**
 * web-socket key details for signing fabric message with private key stored with external client
 * @export
 * @interface WebSocketKey
 */
export interface WebSocketKey {
    /**
     * session Id to access client
     * @type {string}
     * @memberof WebSocketKey
     */
    'sessionId': string;
    /**
     * signature of the session ID
     * @type {string}
     * @memberof WebSocketKey
     */
    'signature': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploys a chaincode contract in the form of a go sources.
         * @param {DeployContractGoSourceV1Request} [deployContractGoSourceV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractGoSourceV1: async (deployContractGoSourceV1Request?: DeployContractGoSourceV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-fabric/deploy-contract-go-source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployContractGoSourceV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deploys a chaincode contract from a set of source files. Note: This endpoint only supports Fabric 2.x. The \'v1\' suffix in the method name refers to the Cactus API version, not the supported Fabric ledger version.
         * @param {DeployContractV1Request} [deployContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractV1: async (deployContractV1Request?: DeployContractV1Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-fabric/deploy-contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployContractV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get block from the channel using one of selectors from the input. Works only on Fabric 2.x.
         * @param {GetBlockRequestV1} [getBlockRequestV1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockV1: async (getBlockRequestV1?: GetBlockRequestV1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-fabric/get-block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getBlockRequestV1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrometheusMetricsV1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-fabric/get-prometheus-exporter-metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get a transaction receipt by tx id on a Fabric ledger.
         * @param {RunTransactionRequest} runTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionReceiptByTxIDV1: async (runTransactionRequest: RunTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runTransactionRequest' is not null or undefined
            assertParamExists('getTransactionReceiptByTxIDV1', 'runTransactionRequest', runTransactionRequest)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-fabric/get-transaction-receipt-by-txid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Runs a transaction on a Fabric ledger using user-provided signing callback.
         * @param {RunDelegatedSignTransactionRequest} runDelegatedSignTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runDelegatedSignTransactionV1: async (runDelegatedSignTransactionRequest: RunDelegatedSignTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runDelegatedSignTransactionRequest' is not null or undefined
            assertParamExists('runDelegatedSignTransactionV1', 'runDelegatedSignTransactionRequest', runDelegatedSignTransactionRequest)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-fabric/run-delegated-sign-transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runDelegatedSignTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Runs a transaction on a Fabric ledger.
         * @param {RunTransactionRequest} runTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTransactionV1: async (runTransactionRequest: RunTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runTransactionRequest' is not null or undefined
            assertParamExists('runTransactionV1', 'runTransactionRequest', runTransactionRequest)
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-fabric/run-transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deploys a chaincode contract in the form of a go sources.
         * @param {DeployContractGoSourceV1Request} [deployContractGoSourceV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployContractGoSourceV1(deployContractGoSourceV1Request?: DeployContractGoSourceV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContractGoSourceV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployContractGoSourceV1(deployContractGoSourceV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deploys a chaincode contract from a set of source files. Note: This endpoint only supports Fabric 2.x. The \'v1\' suffix in the method name refers to the Cactus API version, not the supported Fabric ledger version.
         * @param {DeployContractV1Request} [deployContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployContractV1(deployContractV1Request?: DeployContractV1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContractV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployContractV1(deployContractV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get block from the channel using one of selectors from the input. Works only on Fabric 2.x.
         * @param {GetBlockRequestV1} [getBlockRequestV1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockV1(getBlockRequestV1?: GetBlockRequestV1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBlockResponseV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockV1(getBlockRequestV1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrometheusMetricsV1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrometheusMetricsV1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get a transaction receipt by tx id on a Fabric ledger.
         * @param {RunTransactionRequest} runTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionReceiptByTxIDV1(runTransactionRequest: RunTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionReceiptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionReceiptByTxIDV1(runTransactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Runs a transaction on a Fabric ledger using user-provided signing callback.
         * @param {RunDelegatedSignTransactionRequest} runDelegatedSignTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runDelegatedSignTransactionV1(runDelegatedSignTransactionRequest: RunDelegatedSignTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runDelegatedSignTransactionV1(runDelegatedSignTransactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Runs a transaction on a Fabric ledger.
         * @param {RunTransactionRequest} runTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runTransactionV1(runTransactionRequest: RunTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runTransactionV1(runTransactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Deploys a chaincode contract in the form of a go sources.
         * @param {DeployContractGoSourceV1Request} [deployContractGoSourceV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractGoSourceV1(deployContractGoSourceV1Request?: DeployContractGoSourceV1Request, options?: any): AxiosPromise<DeployContractGoSourceV1Response> {
            return localVarFp.deployContractGoSourceV1(deployContractGoSourceV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deploys a chaincode contract from a set of source files. Note: This endpoint only supports Fabric 2.x. The \'v1\' suffix in the method name refers to the Cactus API version, not the supported Fabric ledger version.
         * @param {DeployContractV1Request} [deployContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractV1(deployContractV1Request?: DeployContractV1Request, options?: any): AxiosPromise<DeployContractV1Response> {
            return localVarFp.deployContractV1(deployContractV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get block from the channel using one of selectors from the input. Works only on Fabric 2.x.
         * @param {GetBlockRequestV1} [getBlockRequestV1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockV1(getBlockRequestV1?: GetBlockRequestV1, options?: any): AxiosPromise<GetBlockResponseV1> {
            return localVarFp.getBlockV1(getBlockRequestV1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrometheusMetricsV1(options?: any): AxiosPromise<string> {
            return localVarFp.getPrometheusMetricsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get a transaction receipt by tx id on a Fabric ledger.
         * @param {RunTransactionRequest} runTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionReceiptByTxIDV1(runTransactionRequest: RunTransactionRequest, options?: any): AxiosPromise<GetTransactionReceiptResponse> {
            return localVarFp.getTransactionReceiptByTxIDV1(runTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Runs a transaction on a Fabric ledger using user-provided signing callback.
         * @param {RunDelegatedSignTransactionRequest} runDelegatedSignTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runDelegatedSignTransactionV1(runDelegatedSignTransactionRequest: RunDelegatedSignTransactionRequest, options?: any): AxiosPromise<RunTransactionResponse> {
            return localVarFp.runDelegatedSignTransactionV1(runDelegatedSignTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Runs a transaction on a Fabric ledger.
         * @param {RunTransactionRequest} runTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTransactionV1(runTransactionRequest: RunTransactionRequest, options?: any): AxiosPromise<RunTransactionResponse> {
            return localVarFp.runTransactionV1(runTransactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Deploys a chaincode contract in the form of a go sources.
     * @param {DeployContractGoSourceV1Request} [deployContractGoSourceV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deployContractGoSourceV1(deployContractGoSourceV1Request?: DeployContractGoSourceV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deployContractGoSourceV1(deployContractGoSourceV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deploys a chaincode contract from a set of source files. Note: This endpoint only supports Fabric 2.x. The \'v1\' suffix in the method name refers to the Cactus API version, not the supported Fabric ledger version.
     * @param {DeployContractV1Request} [deployContractV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deployContractV1(deployContractV1Request?: DeployContractV1Request, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deployContractV1(deployContractV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get block from the channel using one of selectors from the input. Works only on Fabric 2.x.
     * @param {GetBlockRequestV1} [getBlockRequestV1] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBlockV1(getBlockRequestV1?: GetBlockRequestV1, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBlockV1(getBlockRequestV1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Prometheus Metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPrometheusMetricsV1(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPrometheusMetricsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get a transaction receipt by tx id on a Fabric ledger.
     * @param {RunTransactionRequest} runTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTransactionReceiptByTxIDV1(runTransactionRequest: RunTransactionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTransactionReceiptByTxIDV1(runTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Runs a transaction on a Fabric ledger using user-provided signing callback.
     * @param {RunDelegatedSignTransactionRequest} runDelegatedSignTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public runDelegatedSignTransactionV1(runDelegatedSignTransactionRequest: RunDelegatedSignTransactionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).runDelegatedSignTransactionV1(runDelegatedSignTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Runs a transaction on a Fabric ledger.
     * @param {RunTransactionRequest} runTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public runTransactionV1(runTransactionRequest: RunTransactionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).runTransactionV1(runTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


