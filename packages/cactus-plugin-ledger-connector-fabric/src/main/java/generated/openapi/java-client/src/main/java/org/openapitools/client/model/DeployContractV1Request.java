/*
 * Hyperledger Cactus Plugin - Connector Fabric
 * Can perform basic tasks on a fabric ledger
 *
 * The version of the OpenAPI document: v2.0.0-alpha.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.client.model.ChainCodeProgrammingLanguage;
import org.openapitools.client.model.DeployContractGoSourceV1RequestConstructorArgs;
import org.openapitools.client.model.DeploymentTargetOrganization;
import org.openapitools.client.model.FileBase64;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * DeployContractV1Request
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class DeployContractV1Request {
  public static final String SERIALIZED_NAME_CC_LANG = "ccLang";
  @SerializedName(SERIALIZED_NAME_CC_LANG)
  private ChainCodeProgrammingLanguage ccLang;

  public static final String SERIALIZED_NAME_CA_FILE = "caFile";
  @SerializedName(SERIALIZED_NAME_CA_FILE)
  private String caFile;

  public static final String SERIALIZED_NAME_ORDERER = "orderer";
  @SerializedName(SERIALIZED_NAME_ORDERER)
  private String orderer;

  public static final String SERIALIZED_NAME_ORDERER_T_L_S_HOSTNAME_OVERRIDE = "ordererTLSHostnameOverride";
  @SerializedName(SERIALIZED_NAME_ORDERER_T_L_S_HOSTNAME_OVERRIDE)
  private String ordererTLSHostnameOverride;

  public static final String SERIALIZED_NAME_CONN_TIMEOUT = "connTimeout";
  @SerializedName(SERIALIZED_NAME_CONN_TIMEOUT)
  private Integer connTimeout;

  public static final String SERIALIZED_NAME_SIGNATURE_POLICY = "signaturePolicy";
  @SerializedName(SERIALIZED_NAME_SIGNATURE_POLICY)
  private String signaturePolicy;

  public static final String SERIALIZED_NAME_COLLECTIONS_CONFIG_FILE = "collectionsConfigFile";
  @SerializedName(SERIALIZED_NAME_COLLECTIONS_CONFIG_FILE)
  private String collectionsConfigFile;

  public static final String SERIALIZED_NAME_CHANNEL_ID = "channelId";
  @SerializedName(SERIALIZED_NAME_CHANNEL_ID)
  private String channelId;

  public static final String SERIALIZED_NAME_TARGET_ORGANIZATIONS = "targetOrganizations";
  @SerializedName(SERIALIZED_NAME_TARGET_ORGANIZATIONS)
  private List<DeploymentTargetOrganization> targetOrganizations = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONSTRUCTOR_ARGS = "constructorArgs";
  @SerializedName(SERIALIZED_NAME_CONSTRUCTOR_ARGS)
  private DeployContractGoSourceV1RequestConstructorArgs constructorArgs;

  public static final String SERIALIZED_NAME_CC_SEQUENCE = "ccSequence";
  @SerializedName(SERIALIZED_NAME_CC_SEQUENCE)
  private BigDecimal ccSequence;

  public static final String SERIALIZED_NAME_CC_VERSION = "ccVersion";
  @SerializedName(SERIALIZED_NAME_CC_VERSION)
  private String ccVersion;

  public static final String SERIALIZED_NAME_CC_NAME = "ccName";
  @SerializedName(SERIALIZED_NAME_CC_NAME)
  private String ccName;

  public static final String SERIALIZED_NAME_CC_LABEL = "ccLabel";
  @SerializedName(SERIALIZED_NAME_CC_LABEL)
  private String ccLabel;

  public static final String SERIALIZED_NAME_SOURCE_FILES = "sourceFiles";
  @SerializedName(SERIALIZED_NAME_SOURCE_FILES)
  private List<FileBase64> sourceFiles = new ArrayList<>();

  public DeployContractV1Request() {
  }

  public DeployContractV1Request ccLang(ChainCodeProgrammingLanguage ccLang) {
    
    this.ccLang = ccLang;
    return this;
  }

   /**
   * Get ccLang
   * @return ccLang
  **/
  @javax.annotation.Nonnull
  public ChainCodeProgrammingLanguage getCcLang() {
    return ccLang;
  }


  public void setCcLang(ChainCodeProgrammingLanguage ccLang) {
    this.ccLang = ccLang;
  }


  public DeployContractV1Request caFile(String caFile) {
    
    this.caFile = caFile;
    return this;
  }

   /**
   * File-system path pointing at the CA file.
   * @return caFile
  **/
  @javax.annotation.Nonnull
  public String getCaFile() {
    return caFile;
  }


  public void setCaFile(String caFile) {
    this.caFile = caFile;
  }


  public DeployContractV1Request orderer(String orderer) {
    
    this.orderer = orderer;
    return this;
  }

   /**
   * Ordering service endpoint specified as &lt;hostname or IP address&gt;:&lt;port&gt;
   * @return orderer
  **/
  @javax.annotation.Nonnull
  public String getOrderer() {
    return orderer;
  }


  public void setOrderer(String orderer) {
    this.orderer = orderer;
  }


  public DeployContractV1Request ordererTLSHostnameOverride(String ordererTLSHostnameOverride) {
    
    this.ordererTLSHostnameOverride = ordererTLSHostnameOverride;
    return this;
  }

   /**
   * The hostname override to use when validating the TLS connection to the orderer
   * @return ordererTLSHostnameOverride
  **/
  @javax.annotation.Nonnull
  public String getOrdererTLSHostnameOverride() {
    return ordererTLSHostnameOverride;
  }


  public void setOrdererTLSHostnameOverride(String ordererTLSHostnameOverride) {
    this.ordererTLSHostnameOverride = ordererTLSHostnameOverride;
  }


  public DeployContractV1Request connTimeout(Integer connTimeout) {
    
    this.connTimeout = connTimeout;
    return this;
  }

   /**
   * Timeout for client to connect (default 3s)
   * @return connTimeout
  **/
  @javax.annotation.Nullable
  public Integer getConnTimeout() {
    return connTimeout;
  }


  public void setConnTimeout(Integer connTimeout) {
    this.connTimeout = connTimeout;
  }


  public DeployContractV1Request signaturePolicy(String signaturePolicy) {
    
    this.signaturePolicy = signaturePolicy;
    return this;
  }

   /**
   * Passed in to the peer via the --signature-policy argument on the command line. See also: https://hyperledger-fabric.readthedocs.io/en/release-2.2/endorsement-policies.html#setting-chaincode-level-endorsement-policies
   * @return signaturePolicy
  **/
  @javax.annotation.Nullable
  public String getSignaturePolicy() {
    return signaturePolicy;
  }


  public void setSignaturePolicy(String signaturePolicy) {
    this.signaturePolicy = signaturePolicy;
  }


  public DeployContractV1Request collectionsConfigFile(String collectionsConfigFile) {
    
    this.collectionsConfigFile = collectionsConfigFile;
    return this;
  }

   /**
   * Name of the collections config file as present in the sourceFiles array of the request.
   * @return collectionsConfigFile
  **/
  @javax.annotation.Nullable
  public String getCollectionsConfigFile() {
    return collectionsConfigFile;
  }


  public void setCollectionsConfigFile(String collectionsConfigFile) {
    this.collectionsConfigFile = collectionsConfigFile;
  }


  public DeployContractV1Request channelId(String channelId) {
    
    this.channelId = channelId;
    return this;
  }

   /**
   * The name of the Fabric channel where the contract will get instantiated.
   * @return channelId
  **/
  @javax.annotation.Nonnull
  public String getChannelId() {
    return channelId;
  }


  public void setChannelId(String channelId) {
    this.channelId = channelId;
  }


  public DeployContractV1Request targetOrganizations(List<DeploymentTargetOrganization> targetOrganizations) {
    
    this.targetOrganizations = targetOrganizations;
    return this;
  }

  public DeployContractV1Request addTargetOrganizationsItem(DeploymentTargetOrganization targetOrganizationsItem) {
    if (this.targetOrganizations == null) {
      this.targetOrganizations = new ArrayList<>();
    }
    this.targetOrganizations.add(targetOrganizationsItem);
    return this;
  }

   /**
   * Get targetOrganizations
   * @return targetOrganizations
  **/
  @javax.annotation.Nonnull
  public List<DeploymentTargetOrganization> getTargetOrganizations() {
    return targetOrganizations;
  }


  public void setTargetOrganizations(List<DeploymentTargetOrganization> targetOrganizations) {
    this.targetOrganizations = targetOrganizations;
  }


  public DeployContractV1Request constructorArgs(DeployContractGoSourceV1RequestConstructorArgs constructorArgs) {
    
    this.constructorArgs = constructorArgs;
    return this;
  }

   /**
   * Get constructorArgs
   * @return constructorArgs
  **/
  @javax.annotation.Nullable
  public DeployContractGoSourceV1RequestConstructorArgs getConstructorArgs() {
    return constructorArgs;
  }


  public void setConstructorArgs(DeployContractGoSourceV1RequestConstructorArgs constructorArgs) {
    this.constructorArgs = constructorArgs;
  }


  public DeployContractV1Request ccSequence(BigDecimal ccSequence) {
    
    this.ccSequence = ccSequence;
    return this;
  }

   /**
   * Get ccSequence
   * @return ccSequence
  **/
  @javax.annotation.Nonnull
  public BigDecimal getCcSequence() {
    return ccSequence;
  }


  public void setCcSequence(BigDecimal ccSequence) {
    this.ccSequence = ccSequence;
  }


  public DeployContractV1Request ccVersion(String ccVersion) {
    
    this.ccVersion = ccVersion;
    return this;
  }

   /**
   * Get ccVersion
   * @return ccVersion
  **/
  @javax.annotation.Nonnull
  public String getCcVersion() {
    return ccVersion;
  }


  public void setCcVersion(String ccVersion) {
    this.ccVersion = ccVersion;
  }


  public DeployContractV1Request ccName(String ccName) {
    
    this.ccName = ccName;
    return this;
  }

   /**
   * Get ccName
   * @return ccName
  **/
  @javax.annotation.Nonnull
  public String getCcName() {
    return ccName;
  }


  public void setCcName(String ccName) {
    this.ccName = ccName;
  }


  public DeployContractV1Request ccLabel(String ccLabel) {
    
    this.ccLabel = ccLabel;
    return this;
  }

   /**
   * Human readable label to uniquely identify the contract. Recommended to include in this at least the contract name and the exact version in order to make it easily distinguishable from other deployments of the same contract.
   * @return ccLabel
  **/
  @javax.annotation.Nonnull
  public String getCcLabel() {
    return ccLabel;
  }


  public void setCcLabel(String ccLabel) {
    this.ccLabel = ccLabel;
  }


  public DeployContractV1Request sourceFiles(List<FileBase64> sourceFiles) {
    
    this.sourceFiles = sourceFiles;
    return this;
  }

  public DeployContractV1Request addSourceFilesItem(FileBase64 sourceFilesItem) {
    if (this.sourceFiles == null) {
      this.sourceFiles = new ArrayList<>();
    }
    this.sourceFiles.add(sourceFilesItem);
    return this;
  }

   /**
   * The your-smart-contract.go file where the functionality of your contract is implemented.
   * @return sourceFiles
  **/
  @javax.annotation.Nonnull
  public List<FileBase64> getSourceFiles() {
    return sourceFiles;
  }


  public void setSourceFiles(List<FileBase64> sourceFiles) {
    this.sourceFiles = sourceFiles;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DeployContractV1Request deployContractV1Request = (DeployContractV1Request) o;
    return Objects.equals(this.ccLang, deployContractV1Request.ccLang) &&
        Objects.equals(this.caFile, deployContractV1Request.caFile) &&
        Objects.equals(this.orderer, deployContractV1Request.orderer) &&
        Objects.equals(this.ordererTLSHostnameOverride, deployContractV1Request.ordererTLSHostnameOverride) &&
        Objects.equals(this.connTimeout, deployContractV1Request.connTimeout) &&
        Objects.equals(this.signaturePolicy, deployContractV1Request.signaturePolicy) &&
        Objects.equals(this.collectionsConfigFile, deployContractV1Request.collectionsConfigFile) &&
        Objects.equals(this.channelId, deployContractV1Request.channelId) &&
        Objects.equals(this.targetOrganizations, deployContractV1Request.targetOrganizations) &&
        Objects.equals(this.constructorArgs, deployContractV1Request.constructorArgs) &&
        Objects.equals(this.ccSequence, deployContractV1Request.ccSequence) &&
        Objects.equals(this.ccVersion, deployContractV1Request.ccVersion) &&
        Objects.equals(this.ccName, deployContractV1Request.ccName) &&
        Objects.equals(this.ccLabel, deployContractV1Request.ccLabel) &&
        Objects.equals(this.sourceFiles, deployContractV1Request.sourceFiles);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ccLang, caFile, orderer, ordererTLSHostnameOverride, connTimeout, signaturePolicy, collectionsConfigFile, channelId, targetOrganizations, constructorArgs, ccSequence, ccVersion, ccName, ccLabel, sourceFiles);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DeployContractV1Request {\n");
    sb.append("    ccLang: ").append(toIndentedString(ccLang)).append("\n");
    sb.append("    caFile: ").append(toIndentedString(caFile)).append("\n");
    sb.append("    orderer: ").append(toIndentedString(orderer)).append("\n");
    sb.append("    ordererTLSHostnameOverride: ").append(toIndentedString(ordererTLSHostnameOverride)).append("\n");
    sb.append("    connTimeout: ").append(toIndentedString(connTimeout)).append("\n");
    sb.append("    signaturePolicy: ").append(toIndentedString(signaturePolicy)).append("\n");
    sb.append("    collectionsConfigFile: ").append(toIndentedString(collectionsConfigFile)).append("\n");
    sb.append("    channelId: ").append(toIndentedString(channelId)).append("\n");
    sb.append("    targetOrganizations: ").append(toIndentedString(targetOrganizations)).append("\n");
    sb.append("    constructorArgs: ").append(toIndentedString(constructorArgs)).append("\n");
    sb.append("    ccSequence: ").append(toIndentedString(ccSequence)).append("\n");
    sb.append("    ccVersion: ").append(toIndentedString(ccVersion)).append("\n");
    sb.append("    ccName: ").append(toIndentedString(ccName)).append("\n");
    sb.append("    ccLabel: ").append(toIndentedString(ccLabel)).append("\n");
    sb.append("    sourceFiles: ").append(toIndentedString(sourceFiles)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ccLang");
    openapiFields.add("caFile");
    openapiFields.add("orderer");
    openapiFields.add("ordererTLSHostnameOverride");
    openapiFields.add("connTimeout");
    openapiFields.add("signaturePolicy");
    openapiFields.add("collectionsConfigFile");
    openapiFields.add("channelId");
    openapiFields.add("targetOrganizations");
    openapiFields.add("constructorArgs");
    openapiFields.add("ccSequence");
    openapiFields.add("ccVersion");
    openapiFields.add("ccName");
    openapiFields.add("ccLabel");
    openapiFields.add("sourceFiles");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("ccLang");
    openapiRequiredFields.add("caFile");
    openapiRequiredFields.add("orderer");
    openapiRequiredFields.add("ordererTLSHostnameOverride");
    openapiRequiredFields.add("channelId");
    openapiRequiredFields.add("targetOrganizations");
    openapiRequiredFields.add("ccSequence");
    openapiRequiredFields.add("ccVersion");
    openapiRequiredFields.add("ccName");
    openapiRequiredFields.add("ccLabel");
    openapiRequiredFields.add("sourceFiles");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DeployContractV1Request
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!DeployContractV1Request.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DeployContractV1Request is not found in the empty JSON string", DeployContractV1Request.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!DeployContractV1Request.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DeployContractV1Request` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : DeployContractV1Request.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("caFile").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `caFile` to be a primitive type in the JSON string but got `%s`", jsonObj.get("caFile").toString()));
      }
      if (!jsonObj.get("orderer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `orderer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("orderer").toString()));
      }
      if (!jsonObj.get("ordererTLSHostnameOverride").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ordererTLSHostnameOverride` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ordererTLSHostnameOverride").toString()));
      }
      if ((jsonObj.get("signaturePolicy") != null && !jsonObj.get("signaturePolicy").isJsonNull()) && !jsonObj.get("signaturePolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `signaturePolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("signaturePolicy").toString()));
      }
      if ((jsonObj.get("collectionsConfigFile") != null && !jsonObj.get("collectionsConfigFile").isJsonNull()) && !jsonObj.get("collectionsConfigFile").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `collectionsConfigFile` to be a primitive type in the JSON string but got `%s`", jsonObj.get("collectionsConfigFile").toString()));
      }
      if (!jsonObj.get("channelId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `channelId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("channelId").toString()));
      }
      // ensure the json data is an array
      if (!jsonObj.get("targetOrganizations").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `targetOrganizations` to be an array in the JSON string but got `%s`", jsonObj.get("targetOrganizations").toString()));
      }

      JsonArray jsonArraytargetOrganizations = jsonObj.getAsJsonArray("targetOrganizations");
      // validate the required field `targetOrganizations` (array)
      for (int i = 0; i < jsonArraytargetOrganizations.size(); i++) {
        DeploymentTargetOrganization.validateJsonObject(jsonArraytargetOrganizations.get(i).getAsJsonObject());
      };
      // validate the optional field `constructorArgs`
      if (jsonObj.get("constructorArgs") != null && !jsonObj.get("constructorArgs").isJsonNull()) {
        DeployContractGoSourceV1RequestConstructorArgs.validateJsonObject(jsonObj.getAsJsonObject("constructorArgs"));
      }
      if (!jsonObj.get("ccVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ccVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ccVersion").toString()));
      }
      if (!jsonObj.get("ccName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ccName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ccName").toString()));
      }
      if (!jsonObj.get("ccLabel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ccLabel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ccLabel").toString()));
      }
      // ensure the json data is an array
      if (!jsonObj.get("sourceFiles").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceFiles` to be an array in the JSON string but got `%s`", jsonObj.get("sourceFiles").toString()));
      }

      JsonArray jsonArraysourceFiles = jsonObj.getAsJsonArray("sourceFiles");
      // validate the required field `sourceFiles` (array)
      for (int i = 0; i < jsonArraysourceFiles.size(); i++) {
        FileBase64.validateJsonObject(jsonArraysourceFiles.get(i).getAsJsonObject());
      };
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DeployContractV1Request.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DeployContractV1Request' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DeployContractV1Request> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DeployContractV1Request.class));

       return (TypeAdapter<T>) new TypeAdapter<DeployContractV1Request>() {
           @Override
           public void write(JsonWriter out, DeployContractV1Request value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DeployContractV1Request read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DeployContractV1Request given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DeployContractV1Request
  * @throws IOException if the JSON string is invalid with respect to DeployContractV1Request
  */
  public static DeployContractV1Request fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DeployContractV1Request.class);
  }

 /**
  * Convert an instance of DeployContractV1Request to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

