/**
 * Hyperledger Cactus Plugin - Odap Hermes
 *
 * Implementation for Odap and Hermes
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import org.openapitools.client.models.ClientV1Request
import org.openapitools.client.models.CommitFinalV1Request
import org.openapitools.client.models.CommitFinalV1Response
import org.openapitools.client.models.CommitPreparationV1Request
import org.openapitools.client.models.CommitPreparationV1Response
import org.openapitools.client.models.LockEvidenceV1Request
import org.openapitools.client.models.LockEvidenceV1Response
import org.openapitools.client.models.RecoverSuccessV1Message
import org.openapitools.client.models.RecoverUpdateAckV1Message
import org.openapitools.client.models.RecoverUpdateV1Message
import org.openapitools.client.models.RecoverV1Message
import org.openapitools.client.models.RollbackAckV1Message
import org.openapitools.client.models.RollbackV1Message
import org.openapitools.client.models.TransferCommenceV1Request
import org.openapitools.client.models.TransferCommenceV1Response
import org.openapitools.client.models.TransferCompleteV1Request
import org.openapitools.client.models.TransferInitializationV1Request
import org.openapitools.client.models.TransferInitializationV1Response

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.openapitools.client.baseUrl", "http://localhost")
        }
    }

    /**
    * 
    * 
    * @param clientV1Request  (optional)
    * @return kotlin.Any
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun clientRequestV1(clientV1Request: ClientV1Request?) : kotlin.Any {
        val localVariableConfig = clientRequestV1RequestConfig(clientV1Request = clientV1Request)

        val localVarResponse = request<ClientV1Request, kotlin.Any>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation clientRequestV1
    *
    * @param clientV1Request  (optional)
    * @return RequestConfig
    */
    fun clientRequestV1RequestConfig(clientV1Request: ClientV1Request?) : RequestConfig<ClientV1Request> {
        val localVariableBody = clientV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/clientrequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param transferInitializationV1Request  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase1TransferInitiationRequestV1(transferInitializationV1Request: TransferInitializationV1Request?) : Unit {
        val localVariableConfig = phase1TransferInitiationRequestV1RequestConfig(transferInitializationV1Request = transferInitializationV1Request)

        val localVarResponse = request<TransferInitializationV1Request, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation phase1TransferInitiationRequestV1
    *
    * @param transferInitializationV1Request  (optional)
    * @return RequestConfig
    */
    fun phase1TransferInitiationRequestV1RequestConfig(transferInitializationV1Request: TransferInitializationV1Request?) : RequestConfig<TransferInitializationV1Request> {
        val localVariableBody = transferInitializationV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/phase1/transferinitiationrequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param transferInitializationV1Response  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase1TransferInitiationResponseV1(transferInitializationV1Response: TransferInitializationV1Response?) : Unit {
        val localVariableConfig = phase1TransferInitiationResponseV1RequestConfig(transferInitializationV1Response = transferInitializationV1Response)

        val localVarResponse = request<TransferInitializationV1Response, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation phase1TransferInitiationResponseV1
    *
    * @param transferInitializationV1Response  (optional)
    * @return RequestConfig
    */
    fun phase1TransferInitiationResponseV1RequestConfig(transferInitializationV1Response: TransferInitializationV1Response?) : RequestConfig<TransferInitializationV1Response> {
        val localVariableBody = transferInitializationV1Response
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/phase1/transferinitiationresponse",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param lockEvidenceV1Request  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase2LockEvidenceRequestV1(lockEvidenceV1Request: LockEvidenceV1Request?) : Unit {
        val localVariableConfig = phase2LockEvidenceRequestV1RequestConfig(lockEvidenceV1Request = lockEvidenceV1Request)

        val localVarResponse = request<LockEvidenceV1Request, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation phase2LockEvidenceRequestV1
    *
    * @param lockEvidenceV1Request  (optional)
    * @return RequestConfig
    */
    fun phase2LockEvidenceRequestV1RequestConfig(lockEvidenceV1Request: LockEvidenceV1Request?) : RequestConfig<LockEvidenceV1Request> {
        val localVariableBody = lockEvidenceV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/phase2/lockevidencerequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param lockEvidenceV1Response  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase2LockEvidenceResponseV1(lockEvidenceV1Response: LockEvidenceV1Response?) : Unit {
        val localVariableConfig = phase2LockEvidenceResponseV1RequestConfig(lockEvidenceV1Response = lockEvidenceV1Response)

        val localVarResponse = request<LockEvidenceV1Response, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation phase2LockEvidenceResponseV1
    *
    * @param lockEvidenceV1Response  (optional)
    * @return RequestConfig
    */
    fun phase2LockEvidenceResponseV1RequestConfig(lockEvidenceV1Response: LockEvidenceV1Response?) : RequestConfig<LockEvidenceV1Response> {
        val localVariableBody = lockEvidenceV1Response
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/phase2/lockevidenceresponse",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param transferCommenceV1Request  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase2TransferCommenceRequestV1(transferCommenceV1Request: TransferCommenceV1Request?) : Unit {
        val localVariableConfig = phase2TransferCommenceRequestV1RequestConfig(transferCommenceV1Request = transferCommenceV1Request)

        val localVarResponse = request<TransferCommenceV1Request, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation phase2TransferCommenceRequestV1
    *
    * @param transferCommenceV1Request  (optional)
    * @return RequestConfig
    */
    fun phase2TransferCommenceRequestV1RequestConfig(transferCommenceV1Request: TransferCommenceV1Request?) : RequestConfig<TransferCommenceV1Request> {
        val localVariableBody = transferCommenceV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/phase2/transfercommencerequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param transferCommenceV1Response  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase2TransferCommenceResponseV1(transferCommenceV1Response: TransferCommenceV1Response?) : Unit {
        val localVariableConfig = phase2TransferCommenceResponseV1RequestConfig(transferCommenceV1Response = transferCommenceV1Response)

        val localVarResponse = request<TransferCommenceV1Response, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation phase2TransferCommenceResponseV1
    *
    * @param transferCommenceV1Response  (optional)
    * @return RequestConfig
    */
    fun phase2TransferCommenceResponseV1RequestConfig(transferCommenceV1Response: TransferCommenceV1Response?) : RequestConfig<TransferCommenceV1Response> {
        val localVariableBody = transferCommenceV1Response
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/phase2/transfercommenceresponse",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param commitFinalV1Request  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase3CommitFinalRequestV1(commitFinalV1Request: CommitFinalV1Request?) : Unit {
        val localVariableConfig = phase3CommitFinalRequestV1RequestConfig(commitFinalV1Request = commitFinalV1Request)

        val localVarResponse = request<CommitFinalV1Request, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation phase3CommitFinalRequestV1
    *
    * @param commitFinalV1Request  (optional)
    * @return RequestConfig
    */
    fun phase3CommitFinalRequestV1RequestConfig(commitFinalV1Request: CommitFinalV1Request?) : RequestConfig<CommitFinalV1Request> {
        val localVariableBody = commitFinalV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/phase3/commitfinalrequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param commitFinalV1Response  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase3CommitFinalResponseV1(commitFinalV1Response: CommitFinalV1Response?) : Unit {
        val localVariableConfig = phase3CommitFinalResponseV1RequestConfig(commitFinalV1Response = commitFinalV1Response)

        val localVarResponse = request<CommitFinalV1Response, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation phase3CommitFinalResponseV1
    *
    * @param commitFinalV1Response  (optional)
    * @return RequestConfig
    */
    fun phase3CommitFinalResponseV1RequestConfig(commitFinalV1Response: CommitFinalV1Response?) : RequestConfig<CommitFinalV1Response> {
        val localVariableBody = commitFinalV1Response
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/phase3/commitfinalresponse",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param commitPreparationV1Request  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase3CommitPreparationRequestV1(commitPreparationV1Request: CommitPreparationV1Request?) : Unit {
        val localVariableConfig = phase3CommitPreparationRequestV1RequestConfig(commitPreparationV1Request = commitPreparationV1Request)

        val localVarResponse = request<CommitPreparationV1Request, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation phase3CommitPreparationRequestV1
    *
    * @param commitPreparationV1Request  (optional)
    * @return RequestConfig
    */
    fun phase3CommitPreparationRequestV1RequestConfig(commitPreparationV1Request: CommitPreparationV1Request?) : RequestConfig<CommitPreparationV1Request> {
        val localVariableBody = commitPreparationV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/phase3/commitpreparationrequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param commitPreparationV1Response  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase3CommitPreparationResponseV1(commitPreparationV1Response: CommitPreparationV1Response?) : Unit {
        val localVariableConfig = phase3CommitPreparationResponseV1RequestConfig(commitPreparationV1Response = commitPreparationV1Response)

        val localVarResponse = request<CommitPreparationV1Response, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation phase3CommitPreparationResponseV1
    *
    * @param commitPreparationV1Response  (optional)
    * @return RequestConfig
    */
    fun phase3CommitPreparationResponseV1RequestConfig(commitPreparationV1Response: CommitPreparationV1Response?) : RequestConfig<CommitPreparationV1Response> {
        val localVariableBody = commitPreparationV1Response
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/phase3/commitpreparationresponse",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param transferCompleteV1Request  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun phase3TransferCompleteRequestV1(transferCompleteV1Request: TransferCompleteV1Request?) : Unit {
        val localVariableConfig = phase3TransferCompleteRequestV1RequestConfig(transferCompleteV1Request = transferCompleteV1Request)

        val localVarResponse = request<TransferCompleteV1Request, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation phase3TransferCompleteRequestV1
    *
    * @param transferCompleteV1Request  (optional)
    * @return RequestConfig
    */
    fun phase3TransferCompleteRequestV1RequestConfig(transferCompleteV1Request: TransferCompleteV1Request?) : RequestConfig<TransferCompleteV1Request> {
        val localVariableBody = transferCompleteV1Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/phase3/transfercompleterequest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param recoverUpdateAckV1Message  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun recoverUpdateAckV1Message(recoverUpdateAckV1Message: RecoverUpdateAckV1Message?) : Unit {
        val localVariableConfig = recoverUpdateAckV1MessageRequestConfig(recoverUpdateAckV1Message = recoverUpdateAckV1Message)

        val localVarResponse = request<RecoverUpdateAckV1Message, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation recoverUpdateAckV1Message
    *
    * @param recoverUpdateAckV1Message  (optional)
    * @return RequestConfig
    */
    fun recoverUpdateAckV1MessageRequestConfig(recoverUpdateAckV1Message: RecoverUpdateAckV1Message?) : RequestConfig<RecoverUpdateAckV1Message> {
        val localVariableBody = recoverUpdateAckV1Message
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/recoverupdateackmessage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param recoverUpdateV1Message  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun recoverUpdateV1Message(recoverUpdateV1Message: RecoverUpdateV1Message?) : Unit {
        val localVariableConfig = recoverUpdateV1MessageRequestConfig(recoverUpdateV1Message = recoverUpdateV1Message)

        val localVarResponse = request<RecoverUpdateV1Message, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation recoverUpdateV1Message
    *
    * @param recoverUpdateV1Message  (optional)
    * @return RequestConfig
    */
    fun recoverUpdateV1MessageRequestConfig(recoverUpdateV1Message: RecoverUpdateV1Message?) : RequestConfig<RecoverUpdateV1Message> {
        val localVariableBody = recoverUpdateV1Message
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/recoverupdatemessage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param recoverV1Message  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun recoverV1Message(recoverV1Message: RecoverV1Message?) : Unit {
        val localVariableConfig = recoverV1MessageRequestConfig(recoverV1Message = recoverV1Message)

        val localVarResponse = request<RecoverV1Message, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation recoverV1Message
    *
    * @param recoverV1Message  (optional)
    * @return RequestConfig
    */
    fun recoverV1MessageRequestConfig(recoverV1Message: RecoverV1Message?) : RequestConfig<RecoverV1Message> {
        val localVariableBody = recoverV1Message
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/recovermessage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param recoverSuccessV1Message  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun recoverV1Success(recoverSuccessV1Message: RecoverSuccessV1Message?) : Unit {
        val localVariableConfig = recoverV1SuccessRequestConfig(recoverSuccessV1Message = recoverSuccessV1Message)

        val localVarResponse = request<RecoverSuccessV1Message, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation recoverV1Success
    *
    * @param recoverSuccessV1Message  (optional)
    * @return RequestConfig
    */
    fun recoverV1SuccessRequestConfig(recoverSuccessV1Message: RecoverSuccessV1Message?) : RequestConfig<RecoverSuccessV1Message> {
        val localVariableBody = recoverSuccessV1Message
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/recoversuccessmessage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param rollbackAckV1Message  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rollbackAckV1Message(rollbackAckV1Message: RollbackAckV1Message?) : Unit {
        val localVariableConfig = rollbackAckV1MessageRequestConfig(rollbackAckV1Message = rollbackAckV1Message)

        val localVarResponse = request<RollbackAckV1Message, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation rollbackAckV1Message
    *
    * @param rollbackAckV1Message  (optional)
    * @return RequestConfig
    */
    fun rollbackAckV1MessageRequestConfig(rollbackAckV1Message: RollbackAckV1Message?) : RequestConfig<RollbackAckV1Message> {
        val localVariableBody = rollbackAckV1Message
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/rollbackackmessage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param rollbackV1Message  (optional)
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rollbackV1Message(rollbackV1Message: RollbackV1Message?) : Unit {
        val localVariableConfig = rollbackV1MessageRequestConfig(rollbackV1Message = rollbackV1Message)

        val localVarResponse = request<RollbackV1Message, Unit>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation rollbackV1Message
    *
    * @param rollbackV1Message  (optional)
    * @return RequestConfig
    */
    fun rollbackV1MessageRequestConfig(rollbackV1Message: RollbackV1Message?) : RequestConfig<RollbackV1Message> {
        val localVariableBody = rollbackV1Message
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/@hyperledger/cactus-plugin-odap-hermes/rollbackmessage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
