// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.10.1 with parameter "target=ts"
// @generated from file gossip/message.proto (package gossip, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { CollectionConfigPackage } from "../peer/collection_pb";
import { file_peer_collection } from "../peer/collection_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file gossip/message.proto.
 */
export const file_gossip_message: GenFile = /*@__PURE__*/
  fileDesc("ChRnb3NzaXAvbWVzc2FnZS5wcm90bxIGZ29zc2lwIl8KCEVudmVsb3BlEg8KB3BheWxvYWQYASABKAwSEQoJc2lnbmF0dXJlGAIgASgMEi8KD3NlY3JldF9lbnZlbG9wZRgDIAEoCzIWLmdvc3NpcC5TZWNyZXRFbnZlbG9wZSI0Cg5TZWNyZXRFbnZlbG9wZRIPCgdwYXlsb2FkGAEgASgMEhEKCXNpZ25hdHVyZRgCIAEoDCIvCgZTZWNyZXQSGgoQaW50ZXJuYWxFbmRwb2ludBgBIAEoCUgAQgkKB2NvbnRlbnQijQkKDUdvc3NpcE1lc3NhZ2USDQoFbm9uY2UYASABKAQSDwoHY2hhbm5lbBgCIAEoDBImCgN0YWcYAyABKA4yGS5nb3NzaXAuR29zc2lwTWVzc2FnZS5UYWcSKQoJYWxpdmVfbXNnGAUgASgLMhQuZ29zc2lwLkFsaXZlTWVzc2FnZUgAEiwKB21lbV9yZXEYBiABKAsyGS5nb3NzaXAuTWVtYmVyc2hpcFJlcXVlc3RIABItCgdtZW1fcmVzGAcgASgLMhouZ29zc2lwLk1lbWJlcnNoaXBSZXNwb25zZUgAEicKCGRhdGFfbXNnGAggASgLMhMuZ29zc2lwLkRhdGFNZXNzYWdlSAASJAoFaGVsbG8YCSABKAsyEy5nb3NzaXAuR29zc2lwSGVsbG9IABImCghkYXRhX2RpZxgKIAEoCzISLmdvc3NpcC5EYXRhRGlnZXN0SAASJwoIZGF0YV9yZXEYCyABKAsyEy5nb3NzaXAuRGF0YVJlcXVlc3RIABIpCgtkYXRhX3VwZGF0ZRgMIAEoCzISLmdvc3NpcC5EYXRhVXBkYXRlSAASHgoFZW1wdHkYDSABKAsyDS5nb3NzaXAuRW1wdHlIABIlCgRjb25uGA4gASgLMhUuZ29zc2lwLkNvbm5Fc3RhYmxpc2hIABInCgpzdGF0ZV9pbmZvGA8gASgLMhEuZ29zc2lwLlN0YXRlSW5mb0gAEjMKDnN0YXRlX3NuYXBzaG90GBAgASgLMhkuZ29zc2lwLlN0YXRlSW5mb1NuYXBzaG90SAASOwoTc3RhdGVfaW5mb19wdWxsX3JlcRgRIAEoCzIcLmdvc3NpcC5TdGF0ZUluZm9QdWxsUmVxdWVzdEgAEjMKDXN0YXRlX3JlcXVlc3QYEiABKAsyGi5nb3NzaXAuUmVtb3RlU3RhdGVSZXF1ZXN0SAASNQoOc3RhdGVfcmVzcG9uc2UYEyABKAsyGy5nb3NzaXAuUmVtb3RlU3RhdGVSZXNwb25zZUgAEjMKDmxlYWRlcnNoaXBfbXNnGBQgASgLMhkuZ29zc2lwLkxlYWRlcnNoaXBNZXNzYWdlSAASLQoNcGVlcl9pZGVudGl0eRgVIAEoCzIULmdvc3NpcC5QZWVySWRlbnRpdHlIABImCgNhY2sYFiABKAsyFy5nb3NzaXAuQWNrbm93bGVkZ2VtZW50SAASMgoKcHJpdmF0ZVJlcRgXIAEoCzIcLmdvc3NpcC5SZW1vdGVQdnREYXRhUmVxdWVzdEgAEjMKCnByaXZhdGVSZXMYGCABKAsyHS5nb3NzaXAuUmVtb3RlUHZ0RGF0YVJlc3BvbnNlSAASMgoMcHJpdmF0ZV9kYXRhGBkgASgLMhouZ29zc2lwLlByaXZhdGVEYXRhTWVzc2FnZUgAIl8KA1RhZxINCglVTkRFRklORUQQABIJCgVFTVBUWRABEgwKCE9SR19PTkxZEAISDQoJQ0hBTl9PTkxZEAMSEAoMQ0hBTl9BTkRfT1JHEAQSDwoLQ0hBTl9PUl9PUkcQBUIJCgdjb250ZW50In0KCVN0YXRlSW5mbxIjCgl0aW1lc3RhbXAYAiABKAsyEC5nb3NzaXAuUGVlclRpbWUSDgoGcGtpX2lkGAMgASgMEhMKC2NoYW5uZWxfTUFDGAQgASgMEiYKCnByb3BlcnRpZXMYBSABKAsyEi5nb3NzaXAuUHJvcGVydGllcyJgCgpQcm9wZXJ0aWVzEhUKDWxlZGdlcl9oZWlnaHQYASABKAQSFAoMbGVmdF9jaGFubmVsGAIgASgIEiUKCmNoYWluY29kZXMYAyADKAsyES5nb3NzaXAuQ2hhaW5jb2RlIjcKEVN0YXRlSW5mb1NuYXBzaG90EiIKCGVsZW1lbnRzGAEgAygLMhAuZ29zc2lwLkVudmVsb3BlIisKFFN0YXRlSW5mb1B1bGxSZXF1ZXN0EhMKC2NoYW5uZWxfTUFDGAEgASgMIlcKDUNvbm5Fc3RhYmxpc2gSDgoGcGtpX2lkGAEgASgMEhAKCGlkZW50aXR5GAIgASgMEhUKDXRsc19jZXJ0X2hhc2gYAyABKAwSDQoFcHJvYmUYBCABKAgiPgoMUGVlcklkZW50aXR5Eg4KBnBraV9pZBgBIAEoDBIMCgRjZXJ0GAIgASgMEhAKCG1ldGFkYXRhGAMgASgMIlQKC0RhdGFSZXF1ZXN0Eg0KBW5vbmNlGAEgASgEEg8KB2RpZ2VzdHMYAiADKAwSJQoIbXNnX3R5cGUYAyABKA4yEy5nb3NzaXAuUHVsbE1zZ1R5cGUiVQoLR29zc2lwSGVsbG8SDQoFbm9uY2UYASABKAQSEAoIbWV0YWRhdGEYAiABKAwSJQoIbXNnX3R5cGUYAyABKA4yEy5nb3NzaXAuUHVsbE1zZ1R5cGUiYgoKRGF0YVVwZGF0ZRINCgVub25jZRgBIAEoBBIeCgRkYXRhGAIgAygLMhAuZ29zc2lwLkVudmVsb3BlEiUKCG1zZ190eXBlGAMgASgOMhMuZ29zc2lwLlB1bGxNc2dUeXBlIlMKCkRhdGFEaWdlc3QSDQoFbm9uY2UYASABKAQSDwoHZGlnZXN0cxgCIAMoDBIlCghtc2dfdHlwZRgDIAEoDjITLmdvc3NpcC5QdWxsTXNnVHlwZSIvCgtEYXRhTWVzc2FnZRIgCgdwYXlsb2FkGAEgASgLMg8uZ29zc2lwLlBheWxvYWQiPQoSUHJpdmF0ZURhdGFNZXNzYWdlEicKB3BheWxvYWQYASABKAsyFi5nb3NzaXAuUHJpdmF0ZVBheWxvYWQiPgoHUGF5bG9hZBIPCgdzZXFfbnVtGAEgASgEEgwKBGRhdGEYAiABKAwSFAoMcHJpdmF0ZV9kYXRhGAMgAygMIrsBCg5Qcml2YXRlUGF5bG9hZBIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSEQoJbmFtZXNwYWNlGAIgASgJEg0KBXR4X2lkGAMgASgJEhUKDXByaXZhdGVfcndzZXQYBCABKAwSGgoScHJpdmF0ZV9zaW1faGVpZ2h0GAUgASgEEjsKEmNvbGxlY3Rpb25fY29uZmlncxgGIAEoCzIfLnByb3Rvcy5Db2xsZWN0aW9uQ29uZmlnUGFja2FnZSJpCgxBbGl2ZU1lc3NhZ2USIgoKbWVtYmVyc2hpcBgBIAEoCzIOLmdvc3NpcC5NZW1iZXISIwoJdGltZXN0YW1wGAIgASgLMhAuZ29zc2lwLlBlZXJUaW1lEhAKCGlkZW50aXR5GAQgASgMImAKEUxlYWRlcnNoaXBNZXNzYWdlEg4KBnBraV9pZBgBIAEoDBIjCgl0aW1lc3RhbXAYAiABKAsyEC5nb3NzaXAuUGVlclRpbWUSFgoOaXNfZGVjbGFyYXRpb24YAyABKAgiLAoIUGVlclRpbWUSDwoHaW5jX251bRgBIAEoBBIPCgdzZXFfbnVtGAIgASgEIk4KEU1lbWJlcnNoaXBSZXF1ZXN0EioKEHNlbGZfaW5mb3JtYXRpb24YASABKAsyEC5nb3NzaXAuRW52ZWxvcGUSDQoFa25vd24YAiADKAwiVQoSTWVtYmVyc2hpcFJlc3BvbnNlEh8KBWFsaXZlGAEgAygLMhAuZ29zc2lwLkVudmVsb3BlEh4KBGRlYWQYAiADKAsyEC5nb3NzaXAuRW52ZWxvcGUiPAoGTWVtYmVyEhAKCGVuZHBvaW50GAEgASgJEhAKCG1ldGFkYXRhGAIgASgMEg4KBnBraV9pZBgDIAEoDCIHCgVFbXB0eSJAChJSZW1vdGVTdGF0ZVJlcXVlc3QSFQoNc3RhcnRfc2VxX251bRgBIAEoBBITCgtlbmRfc2VxX251bRgCIAEoBCI4ChNSZW1vdGVTdGF0ZVJlc3BvbnNlEiEKCHBheWxvYWRzGAEgAygLMg8uZ29zc2lwLlBheWxvYWQiPgoUUmVtb3RlUHZ0RGF0YVJlcXVlc3QSJgoHZGlnZXN0cxgBIAMoCzIVLmdvc3NpcC5QdnREYXRhRGlnZXN0Im4KDVB2dERhdGFEaWdlc3QSDQoFdHhfaWQYASABKAkSEQoJbmFtZXNwYWNlGAIgASgJEhIKCmNvbGxlY3Rpb24YAyABKAkSEQoJYmxvY2tfc2VxGAQgASgEEhQKDHNlcV9pbl9ibG9jaxgFIAEoBCJBChVSZW1vdGVQdnREYXRhUmVzcG9uc2USKAoIZWxlbWVudHMYASADKAsyFi5nb3NzaXAuUHZ0RGF0YUVsZW1lbnQiSAoOUHZ0RGF0YUVsZW1lbnQSJQoGZGlnZXN0GAEgASgLMhUuZ29zc2lwLlB2dERhdGFEaWdlc3QSDwoHcGF5bG9hZBgCIAMoDCI6Cg5QdnREYXRhUGF5bG9hZBIXCg90eF9zZXFfaW5fYmxvY2sYASABKAQSDwoHcGF5bG9hZBgCIAEoDCIgCg9BY2tub3dsZWRnZW1lbnQSDQoFZXJyb3IYASABKAkiPAoJQ2hhaW5jb2RlEgwKBG5hbWUYASABKAkSDwoHdmVyc2lvbhgCIAEoCRIQCghtZXRhZGF0YRgDIAEoDCo9CgtQdWxsTXNnVHlwZRINCglVTkRFRklORUQQABINCglCTE9DS19NU0cQARIQCgxJREVOVElUWV9NU0cQAjJmCgZHb3NzaXASNgoMR29zc2lwU3RyZWFtEhAuZ29zc2lwLkVudmVsb3BlGhAuZ29zc2lwLkVudmVsb3BlKAEwARIkCgRQaW5nEg0uZ29zc2lwLkVtcHR5Gg0uZ29zc2lwLkVtcHR5QlYKJG9yZy5oeXBlcmxlZGdlci5mYWJyaWMucHJvdG9zLmdvc3NpcFouZ2l0aHViLmNvbS9oeXBlcmxlZGdlci9mYWJyaWMtcHJvdG9zLWdvL2dvc3NpcGIGcHJvdG8z", [file_peer_collection]);

/**
 * Envelope contains a marshalled
 * GossipMessage and a signature over it.
 * It may also contain a SecretEnvelope
 * which is a marshalled Secret
 *
 * @generated from message gossip.Envelope
 */
export type Envelope = Message<"gossip.Envelope"> & {
  /**
   * @generated from field: bytes payload = 1;
   */
  payload: Uint8Array;

  /**
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;

  /**
   * @generated from field: gossip.SecretEnvelope secret_envelope = 3;
   */
  secretEnvelope?: SecretEnvelope;
};

/**
 * Describes the message gossip.Envelope.
 * Use `create(EnvelopeSchema)` to create a new message.
 */
export const EnvelopeSchema: GenMessage<Envelope> = /*@__PURE__*/
  messageDesc(file_gossip_message, 0);

/**
 * SecretEnvelope is a marshalled Secret
 * and a signature over it.
 * The signature should be validated by the peer
 * that signed the Envelope the SecretEnvelope
 * came with
 *
 * @generated from message gossip.SecretEnvelope
 */
export type SecretEnvelope = Message<"gossip.SecretEnvelope"> & {
  /**
   * @generated from field: bytes payload = 1;
   */
  payload: Uint8Array;

  /**
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;
};

/**
 * Describes the message gossip.SecretEnvelope.
 * Use `create(SecretEnvelopeSchema)` to create a new message.
 */
export const SecretEnvelopeSchema: GenMessage<SecretEnvelope> = /*@__PURE__*/
  messageDesc(file_gossip_message, 1);

/**
 * Secret is an entity that might be omitted
 * from an Envelope when the remote peer that is receiving
 * the Envelope shouldn't know the secret's content.
 *
 * @generated from message gossip.Secret
 */
export type Secret = Message<"gossip.Secret"> & {
  /**
   * @generated from oneof gossip.Secret.content
   */
  content: {
    /**
     * @generated from field: string internalEndpoint = 1;
     */
    value: string;
    case: "internalEndpoint";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message gossip.Secret.
 * Use `create(SecretSchema)` to create a new message.
 */
export const SecretSchema: GenMessage<Secret> = /*@__PURE__*/
  messageDesc(file_gossip_message, 2);

/**
 * GossipMessage defines the message sent in a gossip network
 *
 * @generated from message gossip.GossipMessage
 */
export type GossipMessage = Message<"gossip.GossipMessage"> & {
  /**
   * used mainly for testing, but will might be used in the future
   * for ensuring message delivery by acking
   *
   * @generated from field: uint64 nonce = 1;
   */
  nonce: bigint;

  /**
   * The channel of the message.
   * Some GossipMessages may set this to nil, because
   * they are cross-channels but some may not
   *
   * @generated from field: bytes channel = 2;
   */
  channel: Uint8Array;

  /**
   * determines to which peers it is allowed
   * to forward the message
   *
   * @generated from field: gossip.GossipMessage.Tag tag = 3;
   */
  tag: GossipMessage_Tag;

  /**
   * @generated from oneof gossip.GossipMessage.content
   */
  content: {
    /**
     * Membership
     *
     * @generated from field: gossip.AliveMessage alive_msg = 5;
     */
    value: AliveMessage;
    case: "aliveMsg";
  } | {
    /**
     * @generated from field: gossip.MembershipRequest mem_req = 6;
     */
    value: MembershipRequest;
    case: "memReq";
  } | {
    /**
     * @generated from field: gossip.MembershipResponse mem_res = 7;
     */
    value: MembershipResponse;
    case: "memRes";
  } | {
    /**
     * Contains a ledger block
     *
     * @generated from field: gossip.DataMessage data_msg = 8;
     */
    value: DataMessage;
    case: "dataMsg";
  } | {
    /**
     * Used for push&pull
     *
     * @generated from field: gossip.GossipHello hello = 9;
     */
    value: GossipHello;
    case: "hello";
  } | {
    /**
     * @generated from field: gossip.DataDigest data_dig = 10;
     */
    value: DataDigest;
    case: "dataDig";
  } | {
    /**
     * @generated from field: gossip.DataRequest data_req = 11;
     */
    value: DataRequest;
    case: "dataReq";
  } | {
    /**
     * @generated from field: gossip.DataUpdate data_update = 12;
     */
    value: DataUpdate;
    case: "dataUpdate";
  } | {
    /**
     * Empty message, used for pinging
     *
     * @generated from field: gossip.Empty empty = 13;
     */
    value: Empty;
    case: "empty";
  } | {
    /**
     * ConnEstablish, used for establishing a connection
     *
     * @generated from field: gossip.ConnEstablish conn = 14;
     */
    value: ConnEstablish;
    case: "conn";
  } | {
    /**
     * Used for relaying information
     * about state
     *
     * @generated from field: gossip.StateInfo state_info = 15;
     */
    value: StateInfo;
    case: "stateInfo";
  } | {
    /**
     * Used for sending sets of StateInfo messages
     *
     * @generated from field: gossip.StateInfoSnapshot state_snapshot = 16;
     */
    value: StateInfoSnapshot;
    case: "stateSnapshot";
  } | {
    /**
     * Used for asking for StateInfoSnapshots
     *
     * @generated from field: gossip.StateInfoPullRequest state_info_pull_req = 17;
     */
    value: StateInfoPullRequest;
    case: "stateInfoPullReq";
  } | {
    /**
     *  Used to ask from a remote peer a set of blocks
     *
     * @generated from field: gossip.RemoteStateRequest state_request = 18;
     */
    value: RemoteStateRequest;
    case: "stateRequest";
  } | {
    /**
     * Used to send a set of blocks to a remote peer
     *
     * @generated from field: gossip.RemoteStateResponse state_response = 19;
     */
    value: RemoteStateResponse;
    case: "stateResponse";
  } | {
    /**
     * Used to indicate intent of peer to become leader
     *
     * @generated from field: gossip.LeadershipMessage leadership_msg = 20;
     */
    value: LeadershipMessage;
    case: "leadershipMsg";
  } | {
    /**
     * Used to learn of a peer's certificate
     *
     * @generated from field: gossip.PeerIdentity peer_identity = 21;
     */
    value: PeerIdentity;
    case: "peerIdentity";
  } | {
    /**
     * @generated from field: gossip.Acknowledgement ack = 22;
     */
    value: Acknowledgement;
    case: "ack";
  } | {
    /**
     * Used to request private data
     *
     * @generated from field: gossip.RemotePvtDataRequest privateReq = 23;
     */
    value: RemotePvtDataRequest;
    case: "privateReq";
  } | {
    /**
     * Used to respond to private data requests
     *
     * @generated from field: gossip.RemotePvtDataResponse privateRes = 24;
     */
    value: RemotePvtDataResponse;
    case: "privateRes";
  } | {
    /**
     * Encapsulates private data used to distribute
     * private rwset after the endorsement
     *
     * @generated from field: gossip.PrivateDataMessage private_data = 25;
     */
    value: PrivateDataMessage;
    case: "privateData";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message gossip.GossipMessage.
 * Use `create(GossipMessageSchema)` to create a new message.
 */
export const GossipMessageSchema: GenMessage<GossipMessage> = /*@__PURE__*/
  messageDesc(file_gossip_message, 3);

/**
 * @generated from enum gossip.GossipMessage.Tag
 */
export enum GossipMessage_Tag {
  /**
   * @generated from enum value: UNDEFINED = 0;
   */
  UNDEFINED = 0,

  /**
   * @generated from enum value: EMPTY = 1;
   */
  EMPTY = 1,

  /**
   * @generated from enum value: ORG_ONLY = 2;
   */
  ORG_ONLY = 2,

  /**
   * @generated from enum value: CHAN_ONLY = 3;
   */
  CHAN_ONLY = 3,

  /**
   * @generated from enum value: CHAN_AND_ORG = 4;
   */
  CHAN_AND_ORG = 4,

  /**
   * @generated from enum value: CHAN_OR_ORG = 5;
   */
  CHAN_OR_ORG = 5,
}

/**
 * Describes the enum gossip.GossipMessage.Tag.
 */
export const GossipMessage_TagSchema: GenEnum<GossipMessage_Tag> = /*@__PURE__*/
  enumDesc(file_gossip_message, 3, 0);

/**
 * StateInfo is used for a peer to relay its state information
 * to other peers
 *
 * @generated from message gossip.StateInfo
 */
export type StateInfo = Message<"gossip.StateInfo"> & {
  /**
   * @generated from field: gossip.PeerTime timestamp = 2;
   */
  timestamp?: PeerTime;

  /**
   * @generated from field: bytes pki_id = 3;
   */
  pkiId: Uint8Array;

  /**
   * channel_MAC is an authentication code that proves
   * that the peer that sent this message knows
   * the name of the channel.
   *
   * @generated from field: bytes channel_MAC = 4;
   */
  channelMAC: Uint8Array;

  /**
   * @generated from field: gossip.Properties properties = 5;
   */
  properties?: Properties;
};

/**
 * Describes the message gossip.StateInfo.
 * Use `create(StateInfoSchema)` to create a new message.
 */
export const StateInfoSchema: GenMessage<StateInfo> = /*@__PURE__*/
  messageDesc(file_gossip_message, 4);

/**
 * @generated from message gossip.Properties
 */
export type Properties = Message<"gossip.Properties"> & {
  /**
   * @generated from field: uint64 ledger_height = 1;
   */
  ledgerHeight: bigint;

  /**
   * @generated from field: bool left_channel = 2;
   */
  leftChannel: boolean;

  /**
   * @generated from field: repeated gossip.Chaincode chaincodes = 3;
   */
  chaincodes: Chaincode[];
};

/**
 * Describes the message gossip.Properties.
 * Use `create(PropertiesSchema)` to create a new message.
 */
export const PropertiesSchema: GenMessage<Properties> = /*@__PURE__*/
  messageDesc(file_gossip_message, 5);

/**
 * StateInfoSnapshot is an aggregation of StateInfo messages
 *
 * @generated from message gossip.StateInfoSnapshot
 */
export type StateInfoSnapshot = Message<"gossip.StateInfoSnapshot"> & {
  /**
   * @generated from field: repeated gossip.Envelope elements = 1;
   */
  elements: Envelope[];
};

/**
 * Describes the message gossip.StateInfoSnapshot.
 * Use `create(StateInfoSnapshotSchema)` to create a new message.
 */
export const StateInfoSnapshotSchema: GenMessage<StateInfoSnapshot> = /*@__PURE__*/
  messageDesc(file_gossip_message, 6);

/**
 * StateInfoPullRequest is used to fetch a StateInfoSnapshot
 * from a remote peer
 *
 * @generated from message gossip.StateInfoPullRequest
 */
export type StateInfoPullRequest = Message<"gossip.StateInfoPullRequest"> & {
  /**
   * channel_MAC is an authentication code that proves
   * that the peer that sent this message knows
   * the name of the channel.
   *
   * @generated from field: bytes channel_MAC = 1;
   */
  channelMAC: Uint8Array;
};

/**
 * Describes the message gossip.StateInfoPullRequest.
 * Use `create(StateInfoPullRequestSchema)` to create a new message.
 */
export const StateInfoPullRequestSchema: GenMessage<StateInfoPullRequest> = /*@__PURE__*/
  messageDesc(file_gossip_message, 7);

/**
 * ConnEstablish is the message used for the gossip handshake
 * Whenever a peer connects to another peer, it handshakes
 * with it by sending this message that proves its identity
 *
 * @generated from message gossip.ConnEstablish
 */
export type ConnEstablish = Message<"gossip.ConnEstablish"> & {
  /**
   * @generated from field: bytes pki_id = 1;
   */
  pkiId: Uint8Array;

  /**
   * @generated from field: bytes identity = 2;
   */
  identity: Uint8Array;

  /**
   * @generated from field: bytes tls_cert_hash = 3;
   */
  tlsCertHash: Uint8Array;

  /**
   * @generated from field: bool probe = 4;
   */
  probe: boolean;
};

/**
 * Describes the message gossip.ConnEstablish.
 * Use `create(ConnEstablishSchema)` to create a new message.
 */
export const ConnEstablishSchema: GenMessage<ConnEstablish> = /*@__PURE__*/
  messageDesc(file_gossip_message, 8);

/**
 * PeerIdentity defines the identity of the peer
 * Used to make other peers learn of the identity
 * of a certain peer
 *
 * @generated from message gossip.PeerIdentity
 */
export type PeerIdentity = Message<"gossip.PeerIdentity"> & {
  /**
   * @generated from field: bytes pki_id = 1;
   */
  pkiId: Uint8Array;

  /**
   * @generated from field: bytes cert = 2;
   */
  cert: Uint8Array;

  /**
   * @generated from field: bytes metadata = 3;
   */
  metadata: Uint8Array;
};

/**
 * Describes the message gossip.PeerIdentity.
 * Use `create(PeerIdentitySchema)` to create a new message.
 */
export const PeerIdentitySchema: GenMessage<PeerIdentity> = /*@__PURE__*/
  messageDesc(file_gossip_message, 9);

/**
 * DataRequest is a message used for a peer to request
 * certain data blocks from a remote peer
 *
 * @generated from message gossip.DataRequest
 */
export type DataRequest = Message<"gossip.DataRequest"> & {
  /**
   * @generated from field: uint64 nonce = 1;
   */
  nonce: bigint;

  /**
   * @generated from field: repeated bytes digests = 2;
   */
  digests: Uint8Array[];

  /**
   * @generated from field: gossip.PullMsgType msg_type = 3;
   */
  msgType: PullMsgType;
};

/**
 * Describes the message gossip.DataRequest.
 * Use `create(DataRequestSchema)` to create a new message.
 */
export const DataRequestSchema: GenMessage<DataRequest> = /*@__PURE__*/
  messageDesc(file_gossip_message, 10);

/**
 * GossipHello is the message that is used for the peer to initiate
 * a pull round with another peer
 *
 * @generated from message gossip.GossipHello
 */
export type GossipHello = Message<"gossip.GossipHello"> & {
  /**
   * @generated from field: uint64 nonce = 1;
   */
  nonce: bigint;

  /**
   * @generated from field: bytes metadata = 2;
   */
  metadata: Uint8Array;

  /**
   * @generated from field: gossip.PullMsgType msg_type = 3;
   */
  msgType: PullMsgType;
};

/**
 * Describes the message gossip.GossipHello.
 * Use `create(GossipHelloSchema)` to create a new message.
 */
export const GossipHelloSchema: GenMessage<GossipHello> = /*@__PURE__*/
  messageDesc(file_gossip_message, 11);

/**
 * DataUpdate is the final message in the pull phase
 * sent from the receiver to the initiator
 *
 * @generated from message gossip.DataUpdate
 */
export type DataUpdate = Message<"gossip.DataUpdate"> & {
  /**
   * @generated from field: uint64 nonce = 1;
   */
  nonce: bigint;

  /**
   * @generated from field: repeated gossip.Envelope data = 2;
   */
  data: Envelope[];

  /**
   * @generated from field: gossip.PullMsgType msg_type = 3;
   */
  msgType: PullMsgType;
};

/**
 * Describes the message gossip.DataUpdate.
 * Use `create(DataUpdateSchema)` to create a new message.
 */
export const DataUpdateSchema: GenMessage<DataUpdate> = /*@__PURE__*/
  messageDesc(file_gossip_message, 12);

/**
 * DataDigest is the message sent from the receiver peer
 * to the initator peer and contains the data items it has
 *
 * @generated from message gossip.DataDigest
 */
export type DataDigest = Message<"gossip.DataDigest"> & {
  /**
   * @generated from field: uint64 nonce = 1;
   */
  nonce: bigint;

  /**
   * Maybe change this to bitmap later on
   *
   * @generated from field: repeated bytes digests = 2;
   */
  digests: Uint8Array[];

  /**
   * @generated from field: gossip.PullMsgType msg_type = 3;
   */
  msgType: PullMsgType;
};

/**
 * Describes the message gossip.DataDigest.
 * Use `create(DataDigestSchema)` to create a new message.
 */
export const DataDigestSchema: GenMessage<DataDigest> = /*@__PURE__*/
  messageDesc(file_gossip_message, 13);

/**
 * DataMessage is the message that contains a block
 *
 * @generated from message gossip.DataMessage
 */
export type DataMessage = Message<"gossip.DataMessage"> & {
  /**
   * @generated from field: gossip.Payload payload = 1;
   */
  payload?: Payload;
};

/**
 * Describes the message gossip.DataMessage.
 * Use `create(DataMessageSchema)` to create a new message.
 */
export const DataMessageSchema: GenMessage<DataMessage> = /*@__PURE__*/
  messageDesc(file_gossip_message, 14);

/**
 * PrivateDataMessage message which includes private
 * data information to distributed once transaction
 * has been endorsed
 *
 * @generated from message gossip.PrivateDataMessage
 */
export type PrivateDataMessage = Message<"gossip.PrivateDataMessage"> & {
  /**
   * @generated from field: gossip.PrivatePayload payload = 1;
   */
  payload?: PrivatePayload;
};

/**
 * Describes the message gossip.PrivateDataMessage.
 * Use `create(PrivateDataMessageSchema)` to create a new message.
 */
export const PrivateDataMessageSchema: GenMessage<PrivateDataMessage> = /*@__PURE__*/
  messageDesc(file_gossip_message, 15);

/**
 * Payload contains a block
 *
 * @generated from message gossip.Payload
 */
export type Payload = Message<"gossip.Payload"> & {
  /**
   * @generated from field: uint64 seq_num = 1;
   */
  seqNum: bigint;

  /**
   * @generated from field: bytes data = 2;
   */
  data: Uint8Array;

  /**
   * @generated from field: repeated bytes private_data = 3;
   */
  privateData: Uint8Array[];
};

/**
 * Describes the message gossip.Payload.
 * Use `create(PayloadSchema)` to create a new message.
 */
export const PayloadSchema: GenMessage<Payload> = /*@__PURE__*/
  messageDesc(file_gossip_message, 16);

/**
 * PrivatePayload payload to encapsulate private
 * data with collection name to enable routing
 * based on collection partitioning
 *
 * @generated from message gossip.PrivatePayload
 */
export type PrivatePayload = Message<"gossip.PrivatePayload"> & {
  /**
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * @generated from field: string tx_id = 3;
   */
  txId: string;

  /**
   * @generated from field: bytes private_rwset = 4;
   */
  privateRwset: Uint8Array;

  /**
   * @generated from field: uint64 private_sim_height = 5;
   */
  privateSimHeight: bigint;

  /**
   * @generated from field: protos.CollectionConfigPackage collection_configs = 6;
   */
  collectionConfigs?: CollectionConfigPackage;
};

/**
 * Describes the message gossip.PrivatePayload.
 * Use `create(PrivatePayloadSchema)` to create a new message.
 */
export const PrivatePayloadSchema: GenMessage<PrivatePayload> = /*@__PURE__*/
  messageDesc(file_gossip_message, 17);

/**
 * AliveMessage is sent to inform remote peers
 * of a peer's existence and activity
 *
 * @generated from message gossip.AliveMessage
 */
export type AliveMessage = Message<"gossip.AliveMessage"> & {
  /**
   * @generated from field: gossip.Member membership = 1;
   */
  membership?: Member;

  /**
   * @generated from field: gossip.PeerTime timestamp = 2;
   */
  timestamp?: PeerTime;

  /**
   * @generated from field: bytes identity = 4;
   */
  identity: Uint8Array;
};

/**
 * Describes the message gossip.AliveMessage.
 * Use `create(AliveMessageSchema)` to create a new message.
 */
export const AliveMessageSchema: GenMessage<AliveMessage> = /*@__PURE__*/
  messageDesc(file_gossip_message, 18);

/**
 * Leadership Message is sent during leader election to inform
 * remote peers about intent of peer to proclaim itself as leader
 *
 * @generated from message gossip.LeadershipMessage
 */
export type LeadershipMessage = Message<"gossip.LeadershipMessage"> & {
  /**
   * @generated from field: bytes pki_id = 1;
   */
  pkiId: Uint8Array;

  /**
   * @generated from field: gossip.PeerTime timestamp = 2;
   */
  timestamp?: PeerTime;

  /**
   * @generated from field: bool is_declaration = 3;
   */
  isDeclaration: boolean;
};

/**
 * Describes the message gossip.LeadershipMessage.
 * Use `create(LeadershipMessageSchema)` to create a new message.
 */
export const LeadershipMessageSchema: GenMessage<LeadershipMessage> = /*@__PURE__*/
  messageDesc(file_gossip_message, 19);

/**
 * PeerTime defines the logical time of a peer's life
 *
 * @generated from message gossip.PeerTime
 */
export type PeerTime = Message<"gossip.PeerTime"> & {
  /**
   * @generated from field: uint64 inc_num = 1;
   */
  incNum: bigint;

  /**
   * @generated from field: uint64 seq_num = 2;
   */
  seqNum: bigint;
};

/**
 * Describes the message gossip.PeerTime.
 * Use `create(PeerTimeSchema)` to create a new message.
 */
export const PeerTimeSchema: GenMessage<PeerTime> = /*@__PURE__*/
  messageDesc(file_gossip_message, 20);

/**
 * MembershipRequest is used to ask membership information
 * from a remote peer
 *
 * @generated from message gossip.MembershipRequest
 */
export type MembershipRequest = Message<"gossip.MembershipRequest"> & {
  /**
   * @generated from field: gossip.Envelope self_information = 1;
   */
  selfInformation?: Envelope;

  /**
   * @generated from field: repeated bytes known = 2;
   */
  known: Uint8Array[];
};

/**
 * Describes the message gossip.MembershipRequest.
 * Use `create(MembershipRequestSchema)` to create a new message.
 */
export const MembershipRequestSchema: GenMessage<MembershipRequest> = /*@__PURE__*/
  messageDesc(file_gossip_message, 21);

/**
 * MembershipResponse is used for replying to MembershipRequests
 *
 * @generated from message gossip.MembershipResponse
 */
export type MembershipResponse = Message<"gossip.MembershipResponse"> & {
  /**
   * @generated from field: repeated gossip.Envelope alive = 1;
   */
  alive: Envelope[];

  /**
   * @generated from field: repeated gossip.Envelope dead = 2;
   */
  dead: Envelope[];
};

/**
 * Describes the message gossip.MembershipResponse.
 * Use `create(MembershipResponseSchema)` to create a new message.
 */
export const MembershipResponseSchema: GenMessage<MembershipResponse> = /*@__PURE__*/
  messageDesc(file_gossip_message, 22);

/**
 * Member holds membership-related information
 * about a peer
 *
 * @generated from message gossip.Member
 */
export type Member = Message<"gossip.Member"> & {
  /**
   * @generated from field: string endpoint = 1;
   */
  endpoint: string;

  /**
   * @generated from field: bytes metadata = 2;
   */
  metadata: Uint8Array;

  /**
   * @generated from field: bytes pki_id = 3;
   */
  pkiId: Uint8Array;
};

/**
 * Describes the message gossip.Member.
 * Use `create(MemberSchema)` to create a new message.
 */
export const MemberSchema: GenMessage<Member> = /*@__PURE__*/
  messageDesc(file_gossip_message, 23);

/**
 * Empty is used for pinging and in tests
 *
 * @generated from message gossip.Empty
 */
export type Empty = Message<"gossip.Empty"> & {
};

/**
 * Describes the message gossip.Empty.
 * Use `create(EmptySchema)` to create a new message.
 */
export const EmptySchema: GenMessage<Empty> = /*@__PURE__*/
  messageDesc(file_gossip_message, 24);

/**
 * RemoteStateRequest is used to ask a set of blocks
 * from a remote peer
 *
 * @generated from message gossip.RemoteStateRequest
 */
export type RemoteStateRequest = Message<"gossip.RemoteStateRequest"> & {
  /**
   * @generated from field: uint64 start_seq_num = 1;
   */
  startSeqNum: bigint;

  /**
   * @generated from field: uint64 end_seq_num = 2;
   */
  endSeqNum: bigint;
};

/**
 * Describes the message gossip.RemoteStateRequest.
 * Use `create(RemoteStateRequestSchema)` to create a new message.
 */
export const RemoteStateRequestSchema: GenMessage<RemoteStateRequest> = /*@__PURE__*/
  messageDesc(file_gossip_message, 25);

/**
 * RemoteStateResponse is used to send a set of blocks
 * to a remote peer
 *
 * @generated from message gossip.RemoteStateResponse
 */
export type RemoteStateResponse = Message<"gossip.RemoteStateResponse"> & {
  /**
   * @generated from field: repeated gossip.Payload payloads = 1;
   */
  payloads: Payload[];
};

/**
 * Describes the message gossip.RemoteStateResponse.
 * Use `create(RemoteStateResponseSchema)` to create a new message.
 */
export const RemoteStateResponseSchema: GenMessage<RemoteStateResponse> = /*@__PURE__*/
  messageDesc(file_gossip_message, 26);

/**
 * RemotePrivateDataRequest message used to request
 * missing private rwset
 *
 * @generated from message gossip.RemotePvtDataRequest
 */
export type RemotePvtDataRequest = Message<"gossip.RemotePvtDataRequest"> & {
  /**
   * @generated from field: repeated gossip.PvtDataDigest digests = 1;
   */
  digests: PvtDataDigest[];
};

/**
 * Describes the message gossip.RemotePvtDataRequest.
 * Use `create(RemotePvtDataRequestSchema)` to create a new message.
 */
export const RemotePvtDataRequestSchema: GenMessage<RemotePvtDataRequest> = /*@__PURE__*/
  messageDesc(file_gossip_message, 27);

/**
 * PvtDataDigest defines a digest of private data
 *
 * @generated from message gossip.PvtDataDigest
 */
export type PvtDataDigest = Message<"gossip.PvtDataDigest"> & {
  /**
   * @generated from field: string tx_id = 1;
   */
  txId: string;

  /**
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * @generated from field: string collection = 3;
   */
  collection: string;

  /**
   * @generated from field: uint64 block_seq = 4;
   */
  blockSeq: bigint;

  /**
   * @generated from field: uint64 seq_in_block = 5;
   */
  seqInBlock: bigint;
};

/**
 * Describes the message gossip.PvtDataDigest.
 * Use `create(PvtDataDigestSchema)` to create a new message.
 */
export const PvtDataDigestSchema: GenMessage<PvtDataDigest> = /*@__PURE__*/
  messageDesc(file_gossip_message, 28);

/**
 * RemotePrivateData message to response on private
 * data replication request
 *
 * @generated from message gossip.RemotePvtDataResponse
 */
export type RemotePvtDataResponse = Message<"gossip.RemotePvtDataResponse"> & {
  /**
   * @generated from field: repeated gossip.PvtDataElement elements = 1;
   */
  elements: PvtDataElement[];
};

/**
 * Describes the message gossip.RemotePvtDataResponse.
 * Use `create(RemotePvtDataResponseSchema)` to create a new message.
 */
export const RemotePvtDataResponseSchema: GenMessage<RemotePvtDataResponse> = /*@__PURE__*/
  messageDesc(file_gossip_message, 29);

/**
 * @generated from message gossip.PvtDataElement
 */
export type PvtDataElement = Message<"gossip.PvtDataElement"> & {
  /**
   * @generated from field: gossip.PvtDataDigest digest = 1;
   */
  digest?: PvtDataDigest;

  /**
   * the payload is a marshaled kvrwset.KVRWSet
   *
   * @generated from field: repeated bytes payload = 2;
   */
  payload: Uint8Array[];
};

/**
 * Describes the message gossip.PvtDataElement.
 * Use `create(PvtDataElementSchema)` to create a new message.
 */
export const PvtDataElementSchema: GenMessage<PvtDataElement> = /*@__PURE__*/
  messageDesc(file_gossip_message, 30);

/**
 * PvtPayload augments private rwset data and tx index
 * inside the block
 *
 * @generated from message gossip.PvtDataPayload
 */
export type PvtDataPayload = Message<"gossip.PvtDataPayload"> & {
  /**
   * @generated from field: uint64 tx_seq_in_block = 1;
   */
  txSeqInBlock: bigint;

  /**
   * Encodes marhslaed bytes of rwset.TxPvtReadWriteSet
   * defined in rwset.proto
   *
   * @generated from field: bytes payload = 2;
   */
  payload: Uint8Array;
};

/**
 * Describes the message gossip.PvtDataPayload.
 * Use `create(PvtDataPayloadSchema)` to create a new message.
 */
export const PvtDataPayloadSchema: GenMessage<PvtDataPayload> = /*@__PURE__*/
  messageDesc(file_gossip_message, 31);

/**
 * @generated from message gossip.Acknowledgement
 */
export type Acknowledgement = Message<"gossip.Acknowledgement"> & {
  /**
   * @generated from field: string error = 1;
   */
  error: string;
};

/**
 * Describes the message gossip.Acknowledgement.
 * Use `create(AcknowledgementSchema)` to create a new message.
 */
export const AcknowledgementSchema: GenMessage<Acknowledgement> = /*@__PURE__*/
  messageDesc(file_gossip_message, 32);

/**
 * Chaincode represents a Chaincode that is installed
 * on a peer
 *
 * @generated from message gossip.Chaincode
 */
export type Chaincode = Message<"gossip.Chaincode"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string version = 2;
   */
  version: string;

  /**
   * @generated from field: bytes metadata = 3;
   */
  metadata: Uint8Array;
};

/**
 * Describes the message gossip.Chaincode.
 * Use `create(ChaincodeSchema)` to create a new message.
 */
export const ChaincodeSchema: GenMessage<Chaincode> = /*@__PURE__*/
  messageDesc(file_gossip_message, 33);

/**
 * @generated from enum gossip.PullMsgType
 */
export enum PullMsgType {
  /**
   * @generated from enum value: UNDEFINED = 0;
   */
  UNDEFINED = 0,

  /**
   * @generated from enum value: BLOCK_MSG = 1;
   */
  BLOCK_MSG = 1,

  /**
   * @generated from enum value: IDENTITY_MSG = 2;
   */
  IDENTITY_MSG = 2,
}

/**
 * Describes the enum gossip.PullMsgType.
 */
export const PullMsgTypeSchema: GenEnum<PullMsgType> = /*@__PURE__*/
  enumDesc(file_gossip_message, 0);

/**
 * Gossip
 *
 * @generated from service gossip.Gossip
 */
export const Gossip: GenService<{
  /**
   * GossipStream is the gRPC stream used for sending and receiving messages
   *
   * @generated from rpc gossip.Gossip.GossipStream
   */
  gossipStream: {
    methodKind: "bidi_streaming";
    input: typeof EnvelopeSchema;
    output: typeof EnvelopeSchema;
  },
  /**
   * Ping is used to probe a remote peer's aliveness
   *
   * @generated from rpc gossip.Gossip.Ping
   */
  ping: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof EmptySchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_gossip_message, 0);

