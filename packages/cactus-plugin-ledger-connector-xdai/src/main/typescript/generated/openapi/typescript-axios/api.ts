/* tslint:disable */
/* eslint-disable */
/**
 * Hyperledger Cactus Plugin - Connector Xdai
 * Can perform basic tasks on a Xdai ledger
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ConsistencyStrategy
 */
export interface ConsistencyStrategy {
    /**
     * 
     * @type {ReceiptType}
     * @memberof ConsistencyStrategy
     */
    receiptType: ReceiptType;
    /**
     * The amount of milliseconds to wait for the receipt to arrive to the connector. Defaults to 0 which means to wait for an unlimited amount of time. Note that this wait may be interrupted still by other parts of the infrastructure such as load balancers cutting of HTTP requests after some time even if they are the type that is supposed to be kept alive. The question of re-entrance is a broader topic not in scope to discuss here, but it is important to mention it.
     * @type {number}
     * @memberof ConsistencyStrategy
     */
    timeoutMs?: number;
    /**
     * The number of blocks to wait to be confirmed in addition to the block containing the transaction in question. Note that if the receipt type is set to only wait for node transaction pool ACK and this parameter is set to anything, but zero then the API will not accept the request due to conflicting parameters.
     * @type {number}
     * @memberof ConsistencyStrategy
     */
    blockConfirmations: number;
    /**
     * The amount of time (in milliseconds) connector will wait before making another confiramtion request to the network in case of previous confiramtion request fails
     * @type {number}
     * @memberof ConsistencyStrategy
     */
    pollIntervalMs?: number;
}
/**
 * 
 * @export
 * @interface ContractJSON
 */
export interface ContractJSON {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof ContractJSON
     */
    contractName: string;
    /**
     * See https://ethereum.stackexchange.com/a/47556 regarding the maximum length of the bytecode
     * @type {string}
     * @memberof ContractJSON
     */
    bytecode: string;
    /**
     * The application binary interface of the solidity contract, optional parameter
     * @type {Array<any>}
     * @memberof ContractJSON
     */
    abi: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof ContractJSON
     */
    metadata?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractJSON
     */
    deployedBytecode?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractJSON
     */
    sourceMap?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractJSON
     */
    deployedSourceMap?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractJSON
     */
    sourcePath?: string;
    /**
     * 
     * @type {object}
     * @memberof ContractJSON
     */
    compiler?: object;
    /**
     * 
     * @type {object}
     * @memberof ContractJSON
     */
    networks?: object;
    /**
     * 
     * @type {object}
     * @memberof ContractJSON
     */
    ast?: object;
    /**
     * 
     * @type {object}
     * @memberof ContractJSON
     */
    functionHashes?: object;
    /**
     * 
     * @type {object}
     * @memberof ContractJSON
     */
    gasEstimates?: object;
}
/**
 * 
 * @export
 * @interface DeployContractJsonObjectV1Request
 */
export interface DeployContractJsonObjectV1Request {
    /**
     * 
     * @type {Web3SigningCredential}
     * @memberof DeployContractJsonObjectV1Request
     */
    web3SigningCredential: Web3SigningCredential;
    /**
     * 
     * @type {number}
     * @memberof DeployContractJsonObjectV1Request
     */
    gas?: number;
    /**
     * 
     * @type {string}
     * @memberof DeployContractJsonObjectV1Request
     */
    gasPrice?: string;
    /**
     * The amount of milliseconds to wait for a transaction receipt with theaddress of the contract(which indicates successful deployment) beforegiving up and crashing.
     * @type {number}
     * @memberof DeployContractJsonObjectV1Request
     */
    timeoutMs?: number;
    /**
     * 
     * @type {ContractJSON}
     * @memberof DeployContractJsonObjectV1Request
     */
    contractJSON: ContractJSON;
    /**
     * The list of arguments to pass in to the constructor of the contract being deployed.
     * @type {Array<any>}
     * @memberof DeployContractJsonObjectV1Request
     */
    constructorArgs?: Array<any>;
}
/**
 * 
 * @export
 * @interface DeployContractV1Request
 */
export interface DeployContractV1Request {
    /**
     * The contract name for retrieve the contracts json on the keychain.
     * @type {string}
     * @memberof DeployContractV1Request
     */
    contractName: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof DeployContractV1Request
     */
    constructorArgs?: Array<any>;
    /**
     * 
     * @type {Web3SigningCredential}
     * @memberof DeployContractV1Request
     */
    web3SigningCredential: Web3SigningCredential;
    /**
     * The keychainId for retrieve the contracts json.
     * @type {string}
     * @memberof DeployContractV1Request
     */
    keychainId: string;
    /**
     * 
     * @type {number}
     * @memberof DeployContractV1Request
     */
    gas?: number;
    /**
     * 
     * @type {string}
     * @memberof DeployContractV1Request
     */
    gasPrice?: string;
    /**
     * The amount of milliseconds to wait for a transaction receipt with theaddress of the contract(which indicates successful deployment) beforegiving up and crashing.
     * @type {number}
     * @memberof DeployContractV1Request
     */
    timeoutMs?: number;
}
/**
 * 
 * @export
 * @interface DeployContractV1Response
 */
export interface DeployContractV1Response {
    /**
     * 
     * @type {Web3TransactionReceipt}
     * @memberof DeployContractV1Response
     */
    transactionReceipt: Web3TransactionReceipt;
}
/**
 * 
 * @export
 * @interface DeployRequestBaseV1
 */
export interface DeployRequestBaseV1 {
    /**
     * 
     * @type {ContractJSON}
     * @memberof DeployRequestBaseV1
     */
    contractJSON: ContractJSON;
    /**
     * 
     * @type {Array<any>}
     * @memberof DeployRequestBaseV1
     */
    constructorArgs?: Array<any>;
    /**
     * 
     * @type {Web3SigningCredential}
     * @memberof DeployRequestBaseV1
     */
    web3SigningCredential: Web3SigningCredential;
    /**
     * 
     * @type {string | number}
     * @memberof DeployRequestBaseV1
     */
    gas?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof DeployRequestBaseV1
     */
    gasPrice?: string | number;
    /**
     * The amount of milliseconds to wait for a transaction receipt with theaddress of the contract(which indicates successful deployment) beforegiving up and crashing.
     * @type {number}
     * @memberof DeployRequestBaseV1
     */
    timeoutMs?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum EthContractInvocationType {
    Send = 'SEND',
    Call = 'CALL'
}

/**
 * 
 * @export
 * @interface InvokeContractJsonObjectV1Request
 */
export interface InvokeContractJsonObjectV1Request {
    /**
     * 
     * @type {Web3SigningCredential}
     * @memberof InvokeContractJsonObjectV1Request
     */
    web3SigningCredential: Web3SigningCredential;
    /**
     * 
     * @type {EthContractInvocationType}
     * @memberof InvokeContractJsonObjectV1Request
     */
    invocationType: EthContractInvocationType;
    /**
     * The name of the contract method to invoke.
     * @type {string}
     * @memberof InvokeContractJsonObjectV1Request
     */
    methodName: string;
    /**
     * The list of arguments to pass in to the contract method being invoked.
     * @type {Array<any>}
     * @memberof InvokeContractJsonObjectV1Request
     */
    params: Array<any>;
    /**
     * Address of the solidity contract
     * @type {string}
     * @memberof InvokeContractJsonObjectV1Request
     */
    contractAddress: string;
    /**
     * 
     * @type {string | number}
     * @memberof InvokeContractJsonObjectV1Request
     */
    value?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof InvokeContractJsonObjectV1Request
     */
    gas?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof InvokeContractJsonObjectV1Request
     */
    gasPrice?: string | number;
    /**
     * 
     * @type {number}
     * @memberof InvokeContractJsonObjectV1Request
     */
    nonce?: number;
    /**
     * The amount of milliseconds to wait for a transaction receipt beforegiving up and crashing. Only has any effect if the invocation type is SEND
     * @type {number}
     * @memberof InvokeContractJsonObjectV1Request
     */
    timeoutMs?: number;
    /**
     * 
     * @type {ContractJSON}
     * @memberof InvokeContractJsonObjectV1Request
     */
    contractJSON: ContractJSON;
}
/**
 * 
 * @export
 * @interface InvokeContractV1Request
 */
export interface InvokeContractV1Request {
    /**
     * The contract name to find it in the keychain plugin
     * @type {string}
     * @memberof InvokeContractV1Request
     */
    contractName: string;
    /**
     * 
     * @type {Web3SigningCredential}
     * @memberof InvokeContractV1Request
     */
    web3SigningCredential: Web3SigningCredential;
    /**
     * 
     * @type {EthContractInvocationType}
     * @memberof InvokeContractV1Request
     */
    invocationType: EthContractInvocationType;
    /**
     * The name of the contract method to invoke.
     * @type {string}
     * @memberof InvokeContractV1Request
     */
    methodName: string;
    /**
     * The list of arguments to pass in to the contract method being invoked.
     * @type {Array<any>}
     * @memberof InvokeContractV1Request
     */
    params: Array<any>;
    /**
     * 
     * @type {string | number}
     * @memberof InvokeContractV1Request
     */
    value?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof InvokeContractV1Request
     */
    gas?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof InvokeContractV1Request
     */
    gasPrice?: string | number;
    /**
     * 
     * @type {number}
     * @memberof InvokeContractV1Request
     */
    nonce?: number;
    /**
     * The amount of milliseconds to wait for a transaction receipt beforegiving up and crashing. Only has any effect if the invocation type is SEND
     * @type {number}
     * @memberof InvokeContractV1Request
     */
    timeoutMs?: number;
    /**
     * The keychainId for retrieve the contracts json.
     * @type {string}
     * @memberof InvokeContractV1Request
     */
    keychainId: string;
}
/**
 * 
 * @export
 * @interface InvokeContractV1Response
 */
export interface InvokeContractV1Response {
    /**
     * 
     * @type {Web3TransactionReceipt}
     * @memberof InvokeContractV1Response
     */
    transactionReceipt?: Web3TransactionReceipt;
    /**
     * 
     * @type {any}
     * @memberof InvokeContractV1Response
     */
    callOutput?: any | null;
    /**
     * 
     * @type {boolean}
     * @memberof InvokeContractV1Response
     */
    success: boolean;
}
/**
 * 
 * @export
 * @interface InvokeRequestBaseV1
 */
export interface InvokeRequestBaseV1 {
    /**
     * Address of the solidity contract
     * @type {string}
     * @memberof InvokeRequestBaseV1
     */
    contractAddress: string;
    /**
     * 
     * @type {Web3SigningCredential}
     * @memberof InvokeRequestBaseV1
     */
    web3SigningCredential: Web3SigningCredential;
    /**
     * 
     * @type {EthContractInvocationType}
     * @memberof InvokeRequestBaseV1
     */
    invocationType: EthContractInvocationType;
    /**
     * The name of the contract method to invoke.
     * @type {string}
     * @memberof InvokeRequestBaseV1
     */
    methodName: string;
    /**
     * The list of arguments to pass in to the contract method being invoked.
     * @type {Array<any>}
     * @memberof InvokeRequestBaseV1
     */
    params: Array<any>;
    /**
     * 
     * @type {string | number}
     * @memberof InvokeRequestBaseV1
     */
    value?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof InvokeRequestBaseV1
     */
    gas?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof InvokeRequestBaseV1
     */
    gasPrice?: string | number;
    /**
     * 
     * @type {number}
     * @memberof InvokeRequestBaseV1
     */
    nonce?: number;
    /**
     * The amount of milliseconds to wait for a transaction receipt beforegiving up and crashing. Only has any effect if the invocation type is SEND
     * @type {number}
     * @memberof InvokeRequestBaseV1
     */
    timeoutMs?: number;
    /**
     * 
     * @type {ContractJSON}
     * @memberof InvokeRequestBaseV1
     */
    contractJSON: ContractJSON;
}
/**
 * Enumerates the possible types of receipts that can be waited for by someone or something that has requested the execution of a transaction on a ledger.
 * @export
 * @enum {string}
 */

export enum ReceiptType {
    NodeTxPoolAck = 'NODE_TX_POOL_ACK',
    LedgerBlockAck = 'LEDGER_BLOCK_ACK'
}

/**
 * 
 * @export
 * @interface RunTransactionV1Request
 */
export interface RunTransactionV1Request {
    /**
     * 
     * @type {Web3SigningCredential}
     * @memberof RunTransactionV1Request
     */
    web3SigningCredential: Web3SigningCredential;
    /**
     * 
     * @type {XdaiTransactionConfig}
     * @memberof RunTransactionV1Request
     */
    transactionConfig: XdaiTransactionConfig;
    /**
     * 
     * @type {ConsistencyStrategy}
     * @memberof RunTransactionV1Request
     */
    consistencyStrategy: ConsistencyStrategy;
}
/**
 * 
 * @export
 * @interface RunTransactionV1Response
 */
export interface RunTransactionV1Response {
    /**
     * 
     * @type {Web3TransactionReceipt}
     * @memberof RunTransactionV1Response
     */
    transactionReceipt: Web3TransactionReceipt;
}
/**
 * 
 * @export
 * @interface SolidityContractJsonArtifact
 */
export interface SolidityContractJsonArtifact {
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    contractName: string;
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    metadata?: string;
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    bytecode?: string;
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    deployedBytecode?: string;
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    sourceMap?: string;
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    deployedSourceMap?: string;
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    sourcePath?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SolidityContractJsonArtifact
     */
    compiler?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SolidityContractJsonArtifact
     */
    functionHashes?: { [key: string]: object; };
    /**
     * 
     * @type {object}
     * @memberof SolidityContractJsonArtifact
     */
    gasEstimates?: object;
}
/**
 * @type Web3SigningCredential
 * @export
 */
export type Web3SigningCredential = Web3SigningCredentialCactusKeychainRef | Web3SigningCredentialNone | Web3SigningCredentialPrivateKeyHex;

/**
 * 
 * @export
 * @interface Web3SigningCredentialCactusKeychainRef
 */
export interface Web3SigningCredentialCactusKeychainRef {
    /**
     * 
     * @type {Web3SigningCredentialType}
     * @memberof Web3SigningCredentialCactusKeychainRef
     */
    type: Web3SigningCredentialType;
    /**
     * The ethereum account (public key) that the credential  belongs to. Basically the username in the traditional  terminology of authentication.
     * @type {string}
     * @memberof Web3SigningCredentialCactusKeychainRef
     */
    ethAccount: string;
    /**
     * The key to use when looking up the the keychain entry holding the secret pointed to by the  keychainEntryKey parameter.
     * @type {string}
     * @memberof Web3SigningCredentialCactusKeychainRef
     */
    keychainEntryKey: string;
    /**
     * The keychain ID to use when looking up the the keychain plugin instance that will be used to retrieve the secret pointed to by the keychainEntryKey parameter.
     * @type {string}
     * @memberof Web3SigningCredentialCactusKeychainRef
     */
    keychainId: string;
}
/**
 * Using this denotes that there is no signing required because the transaction is pre-signed.
 * @export
 * @interface Web3SigningCredentialNone
 */
export interface Web3SigningCredentialNone {
    /**
     * 
     * @type {Web3SigningCredentialType}
     * @memberof Web3SigningCredentialNone
     */
    type: Web3SigningCredentialType;
}
/**
 * 
 * @export
 * @interface Web3SigningCredentialPrivateKeyHex
 */
export interface Web3SigningCredentialPrivateKeyHex {
    /**
     * 
     * @type {Web3SigningCredentialType}
     * @memberof Web3SigningCredentialPrivateKeyHex
     */
    type: Web3SigningCredentialType;
    /**
     * The ethereum account (public key) that the credential belongs to. Basically the username in the traditional terminology of authentication.
     * @type {string}
     * @memberof Web3SigningCredentialPrivateKeyHex
     */
    ethAccount: string;
    /**
     * The HEX encoded private key of an eth account.
     * @type {string}
     * @memberof Web3SigningCredentialPrivateKeyHex
     */
    secret: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum Web3SigningCredentialType {
    CactusKeychainRef = 'CACTUS_KEYCHAIN_REF',
    GethKeychainPassword = 'GETH_KEYCHAIN_PASSWORD',
    PrivateKeyHex = 'PRIVATE_KEY_HEX',
    None = 'NONE'
}

/**
 * 
 * @export
 * @interface Web3TransactionReceipt
 */
export interface Web3TransactionReceipt {
    [key: string]: object | any;

    /**
     * 
     * @type {boolean}
     * @memberof Web3TransactionReceipt
     */
    status: boolean;
    /**
     * 
     * @type {string}
     * @memberof Web3TransactionReceipt
     */
    transactionHash: string;
    /**
     * 
     * @type {number}
     * @memberof Web3TransactionReceipt
     */
    transactionIndex: number;
    /**
     * 
     * @type {string}
     * @memberof Web3TransactionReceipt
     */
    blockHash: string;
    /**
     * 
     * @type {number}
     * @memberof Web3TransactionReceipt
     */
    blockNumber: number;
    /**
     * 
     * @type {number}
     * @memberof Web3TransactionReceipt
     */
    gasUsed: number;
    /**
     * 
     * @type {string}
     * @memberof Web3TransactionReceipt
     */
    contractAddress?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Web3TransactionReceipt
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof Web3TransactionReceipt
     */
    to: string;
}
/**
 * 
 * @export
 * @interface XdaiTransactionConfig
 */
export interface XdaiTransactionConfig {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof XdaiTransactionConfig
     */
    rawTransaction?: string;
    /**
     * 
     * @type {string | number}
     * @memberof XdaiTransactionConfig
     */
    from?: string | number;
    /**
     * 
     * @type {string}
     * @memberof XdaiTransactionConfig
     */
    to?: string;
    /**
     * 
     * @type {string | number}
     * @memberof XdaiTransactionConfig
     */
    value?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof XdaiTransactionConfig
     */
    gas?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof XdaiTransactionConfig
     */
    gasPrice?: string | number;
    /**
     * 
     * @type {number}
     * @memberof XdaiTransactionConfig
     */
    nonce?: number;
    /**
     * 
     * @type {string}
     * @memberof XdaiTransactionConfig
     */
    data?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploys the bytecode of a Solidity contract.
         * @param {DeployContractJsonObjectV1Request} [deployContractJsonObjectV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractJsonObjectV1: async (deployContractJsonObjectV1Request?: DeployContractJsonObjectV1Request, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-xdai/deploy-contract-solidity-bytecode-json-object`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployContractJsonObjectV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deploys the bytecode of a Solidity contract.
         * @param {DeployContractV1Request} [deployContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractV1: async (deployContractV1Request?: DeployContractV1Request, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-xdai/deploy-contract-solidity-bytecode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployContractV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrometheusMetricsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-xdai/get-prometheus-exporter-metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invokes a contract on a besu ledger
         * @param {InvokeContractJsonObjectV1Request} [invokeContractJsonObjectV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeContractJsonObject: async (invokeContractJsonObjectV1Request?: InvokeContractJsonObjectV1Request, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-xdai/invoke-contract-json-object`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invokeContractJsonObjectV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invokes a contract on a xdai ledger
         * @param {InvokeContractV1Request} [invokeContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeContractV1: async (invokeContractV1Request?: InvokeContractV1Request, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-xdai/invoke-contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invokeContractV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Executes a transaction on a xdai ledger
         * @param {RunTransactionV1Request} [runTransactionV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTransactionV1: async (runTransactionV1Request?: RunTransactionV1Request, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-xdai/run-transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTransactionV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deploys the bytecode of a Solidity contract.
         * @param {DeployContractJsonObjectV1Request} [deployContractJsonObjectV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployContractJsonObjectV1(deployContractJsonObjectV1Request?: DeployContractJsonObjectV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContractV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployContractJsonObjectV1(deployContractJsonObjectV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deploys the bytecode of a Solidity contract.
         * @param {DeployContractV1Request} [deployContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployContractV1(deployContractV1Request?: DeployContractV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContractV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployContractV1(deployContractV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrometheusMetricsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrometheusMetricsV1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invokes a contract on a besu ledger
         * @param {InvokeContractJsonObjectV1Request} [invokeContractJsonObjectV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeContractJsonObject(invokeContractJsonObjectV1Request?: InvokeContractJsonObjectV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvokeContractV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invokeContractJsonObject(invokeContractJsonObjectV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invokes a contract on a xdai ledger
         * @param {InvokeContractV1Request} [invokeContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeContractV1(invokeContractV1Request?: InvokeContractV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvokeContractV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invokeContractV1(invokeContractV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Executes a transaction on a xdai ledger
         * @param {RunTransactionV1Request} [runTransactionV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runTransactionV1(runTransactionV1Request?: RunTransactionV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTransactionV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runTransactionV1(runTransactionV1Request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Deploys the bytecode of a Solidity contract.
         * @param {DeployContractJsonObjectV1Request} [deployContractJsonObjectV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractJsonObjectV1(deployContractJsonObjectV1Request?: DeployContractJsonObjectV1Request, options?: any): AxiosPromise<DeployContractV1Response> {
            return localVarFp.deployContractJsonObjectV1(deployContractJsonObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deploys the bytecode of a Solidity contract.
         * @param {DeployContractV1Request} [deployContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractV1(deployContractV1Request?: DeployContractV1Request, options?: any): AxiosPromise<DeployContractV1Response> {
            return localVarFp.deployContractV1(deployContractV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrometheusMetricsV1(options?: any): AxiosPromise<string> {
            return localVarFp.getPrometheusMetricsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invokes a contract on a besu ledger
         * @param {InvokeContractJsonObjectV1Request} [invokeContractJsonObjectV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeContractJsonObject(invokeContractJsonObjectV1Request?: InvokeContractJsonObjectV1Request, options?: any): AxiosPromise<InvokeContractV1Response> {
            return localVarFp.invokeContractJsonObject(invokeContractJsonObjectV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invokes a contract on a xdai ledger
         * @param {InvokeContractV1Request} [invokeContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeContractV1(invokeContractV1Request?: InvokeContractV1Request, options?: any): AxiosPromise<InvokeContractV1Response> {
            return localVarFp.invokeContractV1(invokeContractV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Executes a transaction on a xdai ledger
         * @param {RunTransactionV1Request} [runTransactionV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTransactionV1(runTransactionV1Request?: RunTransactionV1Request, options?: any): AxiosPromise<RunTransactionV1Response> {
            return localVarFp.runTransactionV1(runTransactionV1Request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Deploys the bytecode of a Solidity contract.
     * @param {DeployContractJsonObjectV1Request} [deployContractJsonObjectV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deployContractJsonObjectV1(deployContractJsonObjectV1Request?: DeployContractJsonObjectV1Request, options?: any) {
        return DefaultApiFp(this.configuration).deployContractJsonObjectV1(deployContractJsonObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deploys the bytecode of a Solidity contract.
     * @param {DeployContractV1Request} [deployContractV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deployContractV1(deployContractV1Request?: DeployContractV1Request, options?: any) {
        return DefaultApiFp(this.configuration).deployContractV1(deployContractV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Prometheus Metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPrometheusMetricsV1(options?: any) {
        return DefaultApiFp(this.configuration).getPrometheusMetricsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invokes a contract on a besu ledger
     * @param {InvokeContractJsonObjectV1Request} [invokeContractJsonObjectV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public invokeContractJsonObject(invokeContractJsonObjectV1Request?: InvokeContractJsonObjectV1Request, options?: any) {
        return DefaultApiFp(this.configuration).invokeContractJsonObject(invokeContractJsonObjectV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invokes a contract on a xdai ledger
     * @param {InvokeContractV1Request} [invokeContractV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public invokeContractV1(invokeContractV1Request?: InvokeContractV1Request, options?: any) {
        return DefaultApiFp(this.configuration).invokeContractV1(invokeContractV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Executes a transaction on a xdai ledger
     * @param {RunTransactionV1Request} [runTransactionV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public runTransactionV1(runTransactionV1Request?: RunTransactionV1Request, options?: any) {
        return DefaultApiFp(this.configuration).runTransactionV1(runTransactionV1Request, options).then((request) => request(this.axios, this.basePath));
    }
}


