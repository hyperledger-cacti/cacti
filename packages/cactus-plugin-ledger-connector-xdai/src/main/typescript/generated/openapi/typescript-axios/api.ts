/* tslint:disable */
/* eslint-disable */
/**
 * Hyperledger Cactus Plugin - Connector Xdai
 * Can perform basic tasks on a Xdai ledger
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ConsistencyStrategy
 */
export interface ConsistencyStrategy {
    /**
     * 
     * @type {ReceiptType}
     * @memberof ConsistencyStrategy
     */
    receiptType: ReceiptType;
    /**
     * The amount of milliseconds to wait for the receipt to arrive to the connector. Defaults to 0 which means to wait for an unlimited amount of time. Note that this wait may be interrupted still by other parts of the infrastructure such as load balancers cutting of HTTP requests after some time even if they are the type that is supposed to be kept alive. The question of re-entrancy is a broader topic not in scope to discuss here, but it is important to mention it.
     * @type {number}
     * @memberof ConsistencyStrategy
     */
    timeoutMs?: number;
    /**
     * The number of blocks to wait to be confirmed in addition to the block containing the transaction in question. Note that if the receipt type is set to only wait for node transaction pool ACK and this parameter is set to anything, but zero then the API will not accept the request due to conflicting parameters.
     * @type {number}
     * @memberof ConsistencyStrategy
     */
    blockConfirmations: number;
}
/**
 * 
 * @export
 * @interface DeployContractV1Request
 */
export interface DeployContractV1Request {
    /**
     * The contract name for retrieve the contracts json on the keychain.
     * @type {string}
     * @memberof DeployContractV1Request
     */
    contractName: string;
    /**
     * The application binary interface of the solidity contract
     * @type {Array<any>}
     * @memberof DeployContractV1Request
     */
    contractAbi: Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof DeployContractV1Request
     */
    constructorArgs: Array<any>;
    /**
     * 
     * @type {Web3SigningCredential}
     * @memberof DeployContractV1Request
     */
    web3SigningCredential: Web3SigningCredential;
    /**
     * See https://ethereum.stackexchange.com/a/47556 regarding the maximum length of the bytecode
     * @type {string}
     * @memberof DeployContractV1Request
     */
    bytecode: string;
    /**
     * The keychainId for retrieve the contracts json.
     * @type {string}
     * @memberof DeployContractV1Request
     */
    keychainId: string;
    /**
     * 
     * @type {number}
     * @memberof DeployContractV1Request
     */
    gas?: number;
    /**
     * 
     * @type {string}
     * @memberof DeployContractV1Request
     */
    gasPrice?: string;
    /**
     * The amount of milliseconds to wait for a transaction receipt with theaddress of the contract(which indicates successful deployment) beforegiving up and crashing.
     * @type {number}
     * @memberof DeployContractV1Request
     */
    timeoutMs?: number;
}
/**
 * 
 * @export
 * @interface DeployContractV1Response
 */
export interface DeployContractV1Response {
    /**
     * 
     * @type {Web3TransactionReceipt}
     * @memberof DeployContractV1Response
     */
    transactionReceipt: Web3TransactionReceipt;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EthContractInvocationType {
    SEND = 'SEND',
    CALL = 'CALL'
}

/**
 * 
 * @export
 * @interface InvokeContractV1Request
 */
export interface InvokeContractV1Request {
    /**
     * 
     * @type {string}
     * @memberof InvokeContractV1Request
     */
    contractName: string;
    /**
     * 
     * @type {Web3SigningCredential}
     * @memberof InvokeContractV1Request
     */
    signingCredential: Web3SigningCredential;
    /**
     * 
     * @type {EthContractInvocationType}
     * @memberof InvokeContractV1Request
     */
    invocationType: EthContractInvocationType;
    /**
     * The name of the contract method to invoke.
     * @type {string}
     * @memberof InvokeContractV1Request
     */
    methodName: string;
    /**
     * The list of arguments to pass in to the contract method being invoked.
     * @type {Array<any>}
     * @memberof InvokeContractV1Request
     */
    params: Array<any>;
    /**
     * 
     * @type {string | number}
     * @memberof InvokeContractV1Request
     */
    value?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof InvokeContractV1Request
     */
    gas?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof InvokeContractV1Request
     */
    gasPrice?: string | number;
    /**
     * 
     * @type {number}
     * @memberof InvokeContractV1Request
     */
    nonce?: number;
    /**
     * The amount of milliseconds to wait for a transaction receipt beforegiving up and crashing. Only has any effect if the invocation type is SEND
     * @type {number}
     * @memberof InvokeContractV1Request
     */
    timeoutMs?: number;
    /**
     * The keychainId for retrieve the contracts json.
     * @type {string}
     * @memberof InvokeContractV1Request
     */
    keychainId?: string;
}
/**
 * 
 * @export
 * @interface InvokeContractV1Response
 */
export interface InvokeContractV1Response {
    /**
     * 
     * @type {Web3TransactionReceipt}
     * @memberof InvokeContractV1Response
     */
    transactionReceipt?: Web3TransactionReceipt;
    /**
     * 
     * @type {any}
     * @memberof InvokeContractV1Response
     */
    callOutput?: any | null;
    /**
     * 
     * @type {boolean}
     * @memberof InvokeContractV1Response
     */
    success: boolean;
}
/**
 * Enumerates the possible types of receipts that can be waited for by someone or something that has requested the execution of a transaction on a ledger.
 * @export
 * @enum {string}
 */
export enum ReceiptType {
    NODETXPOOLACK = 'NODE_TX_POOL_ACK',
    LEDGERBLOCKACK = 'LEDGER_BLOCK_ACK'
}

/**
 * 
 * @export
 * @interface RunTransactionV1Request
 */
export interface RunTransactionV1Request {
    /**
     * 
     * @type {Web3SigningCredential}
     * @memberof RunTransactionV1Request
     */
    web3SigningCredential: Web3SigningCredential;
    /**
     * 
     * @type {XdaiTransactionConfig}
     * @memberof RunTransactionV1Request
     */
    transactionConfig: XdaiTransactionConfig;
    /**
     * 
     * @type {ConsistencyStrategy}
     * @memberof RunTransactionV1Request
     */
    consistencyStrategy: ConsistencyStrategy;
}
/**
 * 
 * @export
 * @interface RunTransactionV1Response
 */
export interface RunTransactionV1Response {
    /**
     * 
     * @type {Web3TransactionReceipt}
     * @memberof RunTransactionV1Response
     */
    transactionReceipt: Web3TransactionReceipt;
}
/**
 * 
 * @export
 * @interface SolidityContractJsonArtifact
 */
export interface SolidityContractJsonArtifact {
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    contractName: string;
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    metadata?: string;
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    bytecode?: string;
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    deployedBytecode?: string;
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    sourceMap?: string;
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    deployedSourceMap?: string;
    /**
     * 
     * @type {string}
     * @memberof SolidityContractJsonArtifact
     */
    sourcePath?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SolidityContractJsonArtifact
     */
    compiler?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SolidityContractJsonArtifact
     */
    functionHashes?: { [key: string]: object; };
    /**
     * 
     * @type {object}
     * @memberof SolidityContractJsonArtifact
     */
    gasEstimates?: object;
}
/**
 * @type Web3SigningCredential
 * @export
 */
export type Web3SigningCredential = Web3SigningCredentialCactusKeychainRef | Web3SigningCredentialNone | Web3SigningCredentialPrivateKeyHex;

/**
 * 
 * @export
 * @interface Web3SigningCredentialCactusKeychainRef
 */
export interface Web3SigningCredentialCactusKeychainRef {
    /**
     * 
     * @type {Web3SigningCredentialType}
     * @memberof Web3SigningCredentialCactusKeychainRef
     */
    type: Web3SigningCredentialType;
    /**
     * The ethereum account (public key) that the credential  belongs to. Basically the username in the traditional  terminology of authentication.
     * @type {string}
     * @memberof Web3SigningCredentialCactusKeychainRef
     */
    ethAccount: string;
    /**
     * The key to use when looking up the the keychain entry holding the secret pointed to by the  keychainEntryKey parameter.
     * @type {string}
     * @memberof Web3SigningCredentialCactusKeychainRef
     */
    keychainEntryKey: string;
    /**
     * The keychain ID to use when looking up the the keychain plugin instance that will be used to retrieve the secret pointed to by the keychainEntryKey parameter.
     * @type {string}
     * @memberof Web3SigningCredentialCactusKeychainRef
     */
    keychainId: string;
}
/**
 * Using this denotes that there is no signing required because the transaction is pre-signed.
 * @export
 * @interface Web3SigningCredentialNone
 */
export interface Web3SigningCredentialNone {
    /**
     * 
     * @type {Web3SigningCredentialType}
     * @memberof Web3SigningCredentialNone
     */
    type: Web3SigningCredentialType;
}
/**
 * 
 * @export
 * @interface Web3SigningCredentialPrivateKeyHex
 */
export interface Web3SigningCredentialPrivateKeyHex {
    /**
     * 
     * @type {Web3SigningCredentialType}
     * @memberof Web3SigningCredentialPrivateKeyHex
     */
    type: Web3SigningCredentialType;
    /**
     * The ethereum account (public key) that the credential belongs to. Basically the username in the traditional terminology of authentication.
     * @type {string}
     * @memberof Web3SigningCredentialPrivateKeyHex
     */
    ethAccount: string;
    /**
     * The HEX encoded private key of an eth account.
     * @type {string}
     * @memberof Web3SigningCredentialPrivateKeyHex
     */
    secret: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Web3SigningCredentialType {
    CACTUSKEYCHAINREF = 'CACTUS_KEYCHAIN_REF',
    GETHKEYCHAINPASSWORD = 'GETH_KEYCHAIN_PASSWORD',
    PRIVATEKEYHEX = 'PRIVATE_KEY_HEX',
    NONE = 'NONE'
}

/**
 * 
 * @export
 * @interface Web3TransactionReceipt
 */
export interface Web3TransactionReceipt {
    [key: string]: object | any;

    /**
     * 
     * @type {boolean}
     * @memberof Web3TransactionReceipt
     */
    status: boolean;
    /**
     * 
     * @type {string}
     * @memberof Web3TransactionReceipt
     */
    transactionHash: string;
    /**
     * 
     * @type {number}
     * @memberof Web3TransactionReceipt
     */
    transactionIndex: number;
    /**
     * 
     * @type {string}
     * @memberof Web3TransactionReceipt
     */
    blockHash: string;
    /**
     * 
     * @type {number}
     * @memberof Web3TransactionReceipt
     */
    blockNumber: number;
    /**
     * 
     * @type {number}
     * @memberof Web3TransactionReceipt
     */
    gasUsed: number;
    /**
     * 
     * @type {string}
     * @memberof Web3TransactionReceipt
     */
    contractAddress?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Web3TransactionReceipt
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof Web3TransactionReceipt
     */
    to: string;
}
/**
 * 
 * @export
 * @interface XdaiTransactionConfig
 */
export interface XdaiTransactionConfig {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof XdaiTransactionConfig
     */
    rawTransaction?: string;
    /**
     * 
     * @type {string | number}
     * @memberof XdaiTransactionConfig
     */
    from?: string | number;
    /**
     * 
     * @type {string}
     * @memberof XdaiTransactionConfig
     */
    to?: string;
    /**
     * 
     * @type {string | number}
     * @memberof XdaiTransactionConfig
     */
    value?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof XdaiTransactionConfig
     */
    gas?: string | number;
    /**
     * 
     * @type {string | number}
     * @memberof XdaiTransactionConfig
     */
    gasPrice?: string | number;
    /**
     * 
     * @type {number}
     * @memberof XdaiTransactionConfig
     */
    nonce?: number;
    /**
     * 
     * @type {string}
     * @memberof XdaiTransactionConfig
     */
    data?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploys the bytecode of a Solidity contract.
         * @param {DeployContractV1Request} [deployContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractV1: async (deployContractV1Request?: DeployContractV1Request, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-xdai/deploy-contract-solidity-bytecode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deployContractV1Request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deployContractV1Request !== undefined ? deployContractV1Request : {}) : (deployContractV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrometheusExporterMetricsV1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-xdai/get-prometheus-exporter-metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invokeds a contract on a xdai ledger
         * @param {InvokeContractV1Request} [invokeContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeContractV1: async (invokeContractV1Request?: InvokeContractV1Request, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-xdai/invoke-contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof invokeContractV1Request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(invokeContractV1Request !== undefined ? invokeContractV1Request : {}) : (invokeContractV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Executes a transaction on a xdai ledger
         * @param {RunTransactionV1Request} [runTransactionV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTransactionV1: async (runTransactionV1Request?: RunTransactionV1Request, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/@hyperledger/cactus-plugin-ledger-connector-xdai/run-transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof runTransactionV1Request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(runTransactionV1Request !== undefined ? runTransactionV1Request : {}) : (runTransactionV1Request || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploys the bytecode of a Solidity contract.
         * @param {DeployContractV1Request} [deployContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployContractV1(deployContractV1Request?: DeployContractV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployContractV1Response>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deployContractV1(deployContractV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrometheusExporterMetricsV1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getPrometheusExporterMetricsV1(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Invokeds a contract on a xdai ledger
         * @param {InvokeContractV1Request} [invokeContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeContractV1(invokeContractV1Request?: InvokeContractV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvokeContractV1Response>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).invokeContractV1(invokeContractV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Executes a transaction on a xdai ledger
         * @param {RunTransactionV1Request} [runTransactionV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runTransactionV1(runTransactionV1Request?: RunTransactionV1Request, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTransactionV1Response>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).runTransactionV1(runTransactionV1Request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deploys the bytecode of a Solidity contract.
         * @param {DeployContractV1Request} [deployContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContractV1(deployContractV1Request?: DeployContractV1Request, options?: any): AxiosPromise<DeployContractV1Response> {
            return DefaultApiFp(configuration).deployContractV1(deployContractV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Prometheus Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrometheusExporterMetricsV1(options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).getPrometheusExporterMetricsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invokeds a contract on a xdai ledger
         * @param {InvokeContractV1Request} [invokeContractV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeContractV1(invokeContractV1Request?: InvokeContractV1Request, options?: any): AxiosPromise<InvokeContractV1Response> {
            return DefaultApiFp(configuration).invokeContractV1(invokeContractV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Executes a transaction on a xdai ledger
         * @param {RunTransactionV1Request} [runTransactionV1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTransactionV1(runTransactionV1Request?: RunTransactionV1Request, options?: any): AxiosPromise<RunTransactionV1Response> {
            return DefaultApiFp(configuration).runTransactionV1(runTransactionV1Request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Deploys the bytecode of a Solidity contract.
     * @param {DeployContractV1Request} [deployContractV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deployContractV1(deployContractV1Request?: DeployContractV1Request, options?: any) {
        return DefaultApiFp(this.configuration).deployContractV1(deployContractV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Prometheus Metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPrometheusExporterMetricsV1(options?: any) {
        return DefaultApiFp(this.configuration).getPrometheusExporterMetricsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invokeds a contract on a xdai ledger
     * @param {InvokeContractV1Request} [invokeContractV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public invokeContractV1(invokeContractV1Request?: InvokeContractV1Request, options?: any) {
        return DefaultApiFp(this.configuration).invokeContractV1(invokeContractV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Executes a transaction on a xdai ledger
     * @param {RunTransactionV1Request} [runTransactionV1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public runTransactionV1(runTransactionV1Request?: RunTransactionV1Request, options?: any) {
        return DefaultApiFp(this.configuration).runTransactionV1(runTransactionV1Request, options).then((request) => request(this.axios, this.basePath));
    }
}


