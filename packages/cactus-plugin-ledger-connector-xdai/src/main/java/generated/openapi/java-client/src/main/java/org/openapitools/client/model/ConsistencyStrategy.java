/*
 * Hyperledger Cactus Plugin - Connector Xdai
 * Can perform basic tasks on a Xdai ledger
 *
 * The version of the OpenAPI document: v2.0.0-alpha.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import org.openapitools.client.model.ReceiptType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ConsistencyStrategy
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ConsistencyStrategy {
  public static final String SERIALIZED_NAME_RECEIPT_TYPE = "receiptType";
  @SerializedName(SERIALIZED_NAME_RECEIPT_TYPE)
  private ReceiptType receiptType;

  public static final String SERIALIZED_NAME_TIMEOUT_MS = "timeoutMs";
  @SerializedName(SERIALIZED_NAME_TIMEOUT_MS)
  private Integer timeoutMs;

  public static final String SERIALIZED_NAME_BLOCK_CONFIRMATIONS = "blockConfirmations";
  @SerializedName(SERIALIZED_NAME_BLOCK_CONFIRMATIONS)
  private Integer blockConfirmations;

  public static final String SERIALIZED_NAME_POLL_INTERVAL_MS = "pollIntervalMs";
  @SerializedName(SERIALIZED_NAME_POLL_INTERVAL_MS)
  private Integer pollIntervalMs;

  public ConsistencyStrategy() {
  }

  public ConsistencyStrategy receiptType(ReceiptType receiptType) {
    
    this.receiptType = receiptType;
    return this;
  }

   /**
   * Get receiptType
   * @return receiptType
  **/
  @javax.annotation.Nonnull
  public ReceiptType getReceiptType() {
    return receiptType;
  }


  public void setReceiptType(ReceiptType receiptType) {
    this.receiptType = receiptType;
  }


  public ConsistencyStrategy timeoutMs(Integer timeoutMs) {
    
    this.timeoutMs = timeoutMs;
    return this;
  }

   /**
   * The amount of milliseconds to wait for the receipt to arrive to the connector. Defaults to 0 which means to wait for an unlimited amount of time. Note that this wait may be interrupted still by other parts of the infrastructure such as load balancers cutting of HTTP requests after some time even if they are the type that is supposed to be kept alive. The question of re-entrance is a broader topic not in scope to discuss here, but it is important to mention it.
   * minimum: 0
   * @return timeoutMs
  **/
  @javax.annotation.Nullable
  public Integer getTimeoutMs() {
    return timeoutMs;
  }


  public void setTimeoutMs(Integer timeoutMs) {
    this.timeoutMs = timeoutMs;
  }


  public ConsistencyStrategy blockConfirmations(Integer blockConfirmations) {
    
    this.blockConfirmations = blockConfirmations;
    return this;
  }

   /**
   * The number of blocks to wait to be confirmed in addition to the block containing the transaction in question. Note that if the receipt type is set to only wait for node transaction pool ACK and this parameter is set to anything, but zero then the API will not accept the request due to conflicting parameters.
   * minimum: 0
   * maximum: 20000
   * @return blockConfirmations
  **/
  @javax.annotation.Nonnull
  public Integer getBlockConfirmations() {
    return blockConfirmations;
  }


  public void setBlockConfirmations(Integer blockConfirmations) {
    this.blockConfirmations = blockConfirmations;
  }


  public ConsistencyStrategy pollIntervalMs(Integer pollIntervalMs) {
    
    this.pollIntervalMs = pollIntervalMs;
    return this;
  }

   /**
   * The amount of time (in milliseconds) connector will wait before making another confiramtion request to the network in case of previous confiramtion request fails
   * minimum: 0
   * @return pollIntervalMs
  **/
  @javax.annotation.Nullable
  public Integer getPollIntervalMs() {
    return pollIntervalMs;
  }


  public void setPollIntervalMs(Integer pollIntervalMs) {
    this.pollIntervalMs = pollIntervalMs;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConsistencyStrategy consistencyStrategy = (ConsistencyStrategy) o;
    return Objects.equals(this.receiptType, consistencyStrategy.receiptType) &&
        Objects.equals(this.timeoutMs, consistencyStrategy.timeoutMs) &&
        Objects.equals(this.blockConfirmations, consistencyStrategy.blockConfirmations) &&
        Objects.equals(this.pollIntervalMs, consistencyStrategy.pollIntervalMs);
  }

  @Override
  public int hashCode() {
    return Objects.hash(receiptType, timeoutMs, blockConfirmations, pollIntervalMs);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConsistencyStrategy {\n");
    sb.append("    receiptType: ").append(toIndentedString(receiptType)).append("\n");
    sb.append("    timeoutMs: ").append(toIndentedString(timeoutMs)).append("\n");
    sb.append("    blockConfirmations: ").append(toIndentedString(blockConfirmations)).append("\n");
    sb.append("    pollIntervalMs: ").append(toIndentedString(pollIntervalMs)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("receiptType");
    openapiFields.add("timeoutMs");
    openapiFields.add("blockConfirmations");
    openapiFields.add("pollIntervalMs");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("receiptType");
    openapiRequiredFields.add("blockConfirmations");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ConsistencyStrategy
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!ConsistencyStrategy.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ConsistencyStrategy is not found in the empty JSON string", ConsistencyStrategy.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!ConsistencyStrategy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ConsistencyStrategy` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ConsistencyStrategy.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ConsistencyStrategy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ConsistencyStrategy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ConsistencyStrategy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ConsistencyStrategy.class));

       return (TypeAdapter<T>) new TypeAdapter<ConsistencyStrategy>() {
           @Override
           public void write(JsonWriter out, ConsistencyStrategy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ConsistencyStrategy read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ConsistencyStrategy given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ConsistencyStrategy
  * @throws IOException if the JSON string is invalid with respect to ConsistencyStrategy
  */
  public static ConsistencyStrategy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ConsistencyStrategy.class);
  }

 /**
  * Convert an instance of ConsistencyStrategy to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

