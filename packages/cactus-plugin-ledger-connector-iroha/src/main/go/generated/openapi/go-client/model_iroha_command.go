/*
Hyperledger Cactus Plugin - Connector Iroha

Can perform basic tasks on a Iroha ledger

API version: v2.0.0-alpha.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cactus-plugin-ledger-connector-iroha

import (
	"encoding/json"
	"fmt"
)

// IrohaCommand the model 'IrohaCommand'
type IrohaCommand string

// List of IrohaCommand
const (
	CreateAccount IrohaCommand = "createAccount"
	SetAccountDetail IrohaCommand = "setAccountDetail"
	SetAccountQuorum IrohaCommand = "setAccountQuorum"
	CompareAndSetAccountDetail IrohaCommand = "compareAndSetAccountDetail"
	CreateAsset IrohaCommand = "createAsset"
	AddAssetQuantity IrohaCommand = "addAssetQuantity"
	SubtractAssetQuantity IrohaCommand = "subtractAssetQuantity"
	TransferAsset IrohaCommand = "transferAsset"
	CreateDomain IrohaCommand = "createDomain"
	CreateRole IrohaCommand = "createRole"
	DetachRole IrohaCommand = "detachRole"
	AppendRole IrohaCommand = "appendRole"
	AddSignatory IrohaCommand = "addSignatory"
	RemoveSignatory IrohaCommand = "removeSignatory"
	GrantPermission IrohaCommand = "grantPermission"
	RevokePermission IrohaCommand = "revokePermission"
	AddPeer IrohaCommand = "addPeer"
	RemovePeer IrohaCommand = "removePeer"
	SetSettingValue IrohaCommand = "setSettingValue"
	CallEngine IrohaCommand = "callEngine"
)

// All allowed values of IrohaCommand enum
var AllowedIrohaCommandEnumValues = []IrohaCommand{
	"createAccount",
	"setAccountDetail",
	"setAccountQuorum",
	"compareAndSetAccountDetail",
	"createAsset",
	"addAssetQuantity",
	"subtractAssetQuantity",
	"transferAsset",
	"createDomain",
	"createRole",
	"detachRole",
	"appendRole",
	"addSignatory",
	"removeSignatory",
	"grantPermission",
	"revokePermission",
	"addPeer",
	"removePeer",
	"setSettingValue",
	"callEngine",
}

func (v *IrohaCommand) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := IrohaCommand(value)
	for _, existing := range AllowedIrohaCommandEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid IrohaCommand", value)
}

// NewIrohaCommandFromValue returns a pointer to a valid IrohaCommand
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewIrohaCommandFromValue(v string) (*IrohaCommand, error) {
	ev := IrohaCommand(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for IrohaCommand: valid values are %v", v, AllowedIrohaCommandEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v IrohaCommand) IsValid() bool {
	for _, existing := range AllowedIrohaCommandEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to IrohaCommand value
func (v IrohaCommand) Ptr() *IrohaCommand {
	return &v
}

type NullableIrohaCommand struct {
	value *IrohaCommand
	isSet bool
}

func (v NullableIrohaCommand) Get() *IrohaCommand {
	return v.value
}

func (v *NullableIrohaCommand) Set(val *IrohaCommand) {
	v.value = val
	v.isSet = true
}

func (v NullableIrohaCommand) IsSet() bool {
	return v.isSet
}

func (v *NullableIrohaCommand) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableIrohaCommand(val *IrohaCommand) *NullableIrohaCommand {
	return &NullableIrohaCommand{value: val, isSet: true}
}

func (v NullableIrohaCommand) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableIrohaCommand) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

