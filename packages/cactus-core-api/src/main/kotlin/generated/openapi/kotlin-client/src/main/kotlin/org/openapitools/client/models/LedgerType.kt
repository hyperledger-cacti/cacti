/**
 * Hyperledger Core API
 *
 * Contains/describes the core API types for Cactus. Does not describe actual endpoints on its own as this is left to the implementing plugins who can import and re-use commonly needed type definitions from this specification. One example of said commonly used type definitions would be the types related to consortium management, cactus nodes, ledgers, etc..
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.models


import com.squareup.moshi.Json

/**
 * Enumerates the different ledger vendors and their major versions encoded within the name of the LedgerType. For example \"BESU_1X\" involves all of the [1.0.0;2.0.0) where 1.0.0 is included and anything up until, but not 2.0.0. See: https://stackoverflow.com/a/4396303/698470 for further explanation.
 *
 * Values: bESU1X,bESU2X,bURROW0X,cORDA4X,fABRIC14X,fABRIC2,qUORUM2X,sAWTOOTH1X
 */

enum class LedgerType(val value: kotlin.String) {

    @Json(name = "BESU_1X")
    bESU1X("BESU_1X"),

    @Json(name = "BESU_2X")
    bESU2X("BESU_2X"),

    @Json(name = "BURROW_0X")
    bURROW0X("BURROW_0X"),

    @Json(name = "CORDA_4X")
    cORDA4X("CORDA_4X"),

    @Json(name = "FABRIC_14X")
    fABRIC14X("FABRIC_14X"),

    @Json(name = "FABRIC_2")
    fABRIC2("FABRIC_2"),

    @Json(name = "QUORUM_2X")
    qUORUM2X("QUORUM_2X"),

    @Json(name = "SAWTOOTH_1X")
    sAWTOOTH1X("SAWTOOTH_1X");

    /**
     * Override toString() to avoid using the enum variable name as the value, and instead use
     * the actual value defined in the API spec file.
     *
     * This solves a problem when the variable name and its value are different, and ensures that
     * the client sends the correct enum values to the server always.
     */
    override fun toString(): String = value

    companion object {
        /**
         * Converts the provided [data] to a [String] on success, null otherwise.
         */
        fun encode(data: Any?): kotlin.String? = if (data is LedgerType) "$data" else null

        /**
         * Returns a valid [LedgerType] for [data], null otherwise.
         */
        fun decode(data: Any?): LedgerType? = data?.let {
          val normalizedData = "$it".lowercase()
          values().firstOrNull { value ->
            it == value || normalizedData == "$value".lowercase()
          }
        }
    }
}

