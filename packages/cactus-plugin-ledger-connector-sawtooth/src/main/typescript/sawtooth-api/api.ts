/* tslint:disable */
/* eslint-disable */
/**
 * Sawtooth REST API
 * Official Sawtooth REST API specification with some modifications from Hyperledger Cacti project.
 *
 * The version of the OpenAPI document: 0.8.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Batch
 */
export interface Batch {
    /**
     * 
     * @type {BatchHeader}
     * @memberof Batch
     */
    'header': BatchHeader;
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    'header_signature': string;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof Batch
     */
    'transactions': Array<Transaction>;
}
/**
 * 
 * @export
 * @interface BatchHeader
 */
export interface BatchHeader {
    /**
     * 
     * @type {string}
     * @memberof BatchHeader
     */
    'signer_public_key': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchHeader
     */
    'transaction_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface BatchList
 */
export interface BatchList {
    /**
     * 
     * @type {Array<Batch>}
     * @memberof BatchList
     */
    'batches': Array<Batch>;
}
/**
 * 
 * @export
 * @interface BatchStatusesGet200Response
 */
export interface BatchStatusesGet200Response {
    /**
     * 
     * @type {Array<BatchStatusesInner>}
     * @memberof BatchStatusesGet200Response
     */
    'data'?: Array<BatchStatusesInner>;
    /**
     * 
     * @type {string}
     * @memberof BatchStatusesGet200Response
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface BatchStatusesInner
 */
export interface BatchStatusesInner {
    /**
     * 
     * @type {string}
     * @memberof BatchStatusesInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchStatusesInner
     */
    'status'?: BatchStatusesInnerStatusEnum;
    /**
     * 
     * @type {Array<BatchStatusesInnerInvalidTransactionsInner>}
     * @memberof BatchStatusesInner
     */
    'invalid_transactions'?: Array<BatchStatusesInnerInvalidTransactionsInner>;
}

export const BatchStatusesInnerStatusEnum = {
    Committed: 'COMMITTED',
    Invalid: 'INVALID',
    Pending: 'PENDING',
    Unknown: 'UNKNOWN'
} as const;

export type BatchStatusesInnerStatusEnum = typeof BatchStatusesInnerStatusEnum[keyof typeof BatchStatusesInnerStatusEnum];

/**
 * 
 * @export
 * @interface BatchStatusesInnerInvalidTransactionsInner
 */
export interface BatchStatusesInnerInvalidTransactionsInner {
    /**
     * 
     * @type {string}
     * @memberof BatchStatusesInnerInvalidTransactionsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchStatusesInnerInvalidTransactionsInner
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchStatusesInnerInvalidTransactionsInner
     */
    'extended_data'?: string;
}
/**
 * 
 * @export
 * @interface BatchStatusesPost200Response
 */
export interface BatchStatusesPost200Response {
    /**
     * 
     * @type {Array<BatchStatusesInner>}
     * @memberof BatchStatusesPost200Response
     */
    'data'?: Array<BatchStatusesInner>;
}
/**
 * 
 * @export
 * @interface BatchesBatchIdGet200Response
 */
export interface BatchesBatchIdGet200Response {
    /**
     * 
     * @type {Batch}
     * @memberof BatchesBatchIdGet200Response
     */
    'data'?: Batch;
    /**
     * 
     * @type {string}
     * @memberof BatchesBatchIdGet200Response
     */
    'head'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchesBatchIdGet200Response
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface BatchesGet200Response
 */
export interface BatchesGet200Response {
    /**
     * 
     * @type {Array<Batch>}
     * @memberof BatchesGet200Response
     */
    'data'?: Array<Batch>;
    /**
     * 
     * @type {string}
     * @memberof BatchesGet200Response
     */
    'head'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchesGet200Response
     */
    'link'?: string;
    /**
     * 
     * @type {Paging}
     * @memberof BatchesGet200Response
     */
    'paging'?: Paging;
}
/**
 * 
 * @export
 * @interface BatchesPost202Response
 */
export interface BatchesPost202Response {
    /**
     * 
     * @type {string}
     * @memberof BatchesPost202Response
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * 
     * @type {BlockHeader}
     * @memberof Block
     */
    'header': BlockHeader;
    /**
     * 
     * @type {string}
     * @memberof Block
     */
    'header_signature': string;
    /**
     * 
     * @type {Array<Batch>}
     * @memberof Block
     */
    'batches': Array<Batch>;
}
/**
 * 
 * @export
 * @interface BlockHeader
 */
export interface BlockHeader {
    /**
     * 
     * @type {number}
     * @memberof BlockHeader
     */
    'block_num': number;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    'previous_block_id': string;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    'signer_public_key': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BlockHeader
     */
    'batch_ids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    'consensus': string;
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    'state_root_hash': string;
}
/**
 * 
 * @export
 * @interface BlocksBlockIdGet200Response
 */
export interface BlocksBlockIdGet200Response {
    /**
     * 
     * @type {Block}
     * @memberof BlocksBlockIdGet200Response
     */
    'data'?: Block;
    /**
     * 
     * @type {string}
     * @memberof BlocksBlockIdGet200Response
     */
    'head'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlocksBlockIdGet200Response
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface BlocksGet200Response
 */
export interface BlocksGet200Response {
    /**
     * 
     * @type {Array<Block>}
     * @memberof BlocksGet200Response
     */
    'data'?: Array<Block>;
    /**
     * 
     * @type {string}
     * @memberof BlocksGet200Response
     */
    'head'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlocksGet200Response
     */
    'link'?: string;
    /**
     * 
     * @type {Paging}
     * @memberof BlocksGet200Response
     */
    'paging'?: Paging;
}
/**
 * 
 * @export
 * @interface Entry
 */
export interface Entry {
    /**
     * 
     * @type {string}
     * @memberof Entry
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Entry
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Paging
 */
export interface Paging {
    /**
     * 
     * @type {string}
     * @memberof Paging
     */
    'start'?: string;
    /**
     * 
     * @type {number}
     * @memberof Paging
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof Paging
     */
    'next_position'?: string;
    /**
     * 
     * @type {string}
     * @memberof Paging
     */
    'next'?: string;
}
/**
 * 
 * @export
 * @interface PeersGet200Response
 */
export interface PeersGet200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof PeersGet200Response
     */
    'data'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PeersGet200Response
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface ReceiptsGet200Response
 */
export interface ReceiptsGet200Response {
    /**
     * 
     * @type {Array<TransactionReceipt>}
     * @memberof ReceiptsGet200Response
     */
    'data'?: Array<TransactionReceipt>;
    /**
     * 
     * @type {string}
     * @memberof ReceiptsGet200Response
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface StateAddressGet200Response
 */
export interface StateAddressGet200Response {
    /**
     * 
     * @type {string}
     * @memberof StateAddressGet200Response
     */
    'data'?: string;
    /**
     * 
     * @type {string}
     * @memberof StateAddressGet200Response
     */
    'head'?: string;
    /**
     * 
     * @type {string}
     * @memberof StateAddressGet200Response
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface StateGet200Response
 */
export interface StateGet200Response {
    /**
     * 
     * @type {Array<Entry>}
     * @memberof StateGet200Response
     */
    'data'?: Array<Entry>;
    /**
     * 
     * @type {string}
     * @memberof StateGet200Response
     */
    'head'?: string;
    /**
     * 
     * @type {string}
     * @memberof StateGet200Response
     */
    'link'?: string;
    /**
     * 
     * @type {Paging}
     * @memberof StateGet200Response
     */
    'paging'?: Paging;
}
/**
 * 
 * @export
 * @interface StatusGet200Response
 */
export interface StatusGet200Response {
    /**
     * 
     * @type {StatusGet200ResponseData}
     * @memberof StatusGet200Response
     */
    'data'?: StatusGet200ResponseData;
    /**
     * 
     * @type {string}
     * @memberof StatusGet200Response
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface StatusGet200ResponseData
 */
export interface StatusGet200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof StatusGet200ResponseData
     */
    'endpoint'?: string;
    /**
     * 
     * @type {Array<StatusGet200ResponseDataPeersInner>}
     * @memberof StatusGet200ResponseData
     */
    'peers'?: Array<StatusGet200ResponseDataPeersInner>;
}
/**
 * 
 * @export
 * @interface StatusGet200ResponseDataPeersInner
 */
export interface StatusGet200ResponseDataPeersInner {
    /**
     * 
     * @type {string}
     * @memberof StatusGet200ResponseDataPeersInner
     */
    'endpoint'?: string;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {TransactionHeader}
     * @memberof Transaction
     */
    'header': TransactionHeader;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'header_signature': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface TransactionHeader
 */
export interface TransactionHeader {
    /**
     * 
     * @type {string}
     * @memberof TransactionHeader
     */
    'batcher_public_key': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionHeader
     */
    'dependencies': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TransactionHeader
     */
    'family_name': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionHeader
     */
    'family_version': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionHeader
     */
    'inputs': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TransactionHeader
     */
    'nonce': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionHeader
     */
    'outputs': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TransactionHeader
     */
    'payload_sha512': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionHeader
     */
    'signer_public_key': string;
}
/**
 * 
 * @export
 * @interface TransactionReceipt
 */
export interface TransactionReceipt {
    /**
     * 
     * @type {string}
     * @memberof TransactionReceipt
     */
    'transaction_id'?: string;
    /**
     * 
     * @type {Array<TransactionReceiptStateChangesInner>}
     * @memberof TransactionReceipt
     */
    'state_changes'?: Array<TransactionReceiptStateChangesInner>;
    /**
     * 
     * @type {Array<TransactionReceiptEventsInner>}
     * @memberof TransactionReceipt
     */
    'events'?: Array<TransactionReceiptEventsInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionReceipt
     */
    'data'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TransactionReceiptEventsInner
 */
export interface TransactionReceiptEventsInner {
    /**
     * 
     * @type {string}
     * @memberof TransactionReceiptEventsInner
     */
    'event_type'?: string;
    /**
     * 
     * @type {Array<TransactionReceiptEventsInnerAttributesInner>}
     * @memberof TransactionReceiptEventsInner
     */
    'attributes'?: Array<TransactionReceiptEventsInnerAttributesInner>;
    /**
     * 
     * @type {string}
     * @memberof TransactionReceiptEventsInner
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface TransactionReceiptEventsInnerAttributesInner
 */
export interface TransactionReceiptEventsInnerAttributesInner {
    /**
     * 
     * @type {string}
     * @memberof TransactionReceiptEventsInnerAttributesInner
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionReceiptEventsInnerAttributesInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface TransactionReceiptStateChangesInner
 */
export interface TransactionReceiptStateChangesInner {
    /**
     * 
     * @type {string}
     * @memberof TransactionReceiptStateChangesInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionReceiptStateChangesInner
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionReceiptStateChangesInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface TransactionsGet200Response
 */
export interface TransactionsGet200Response {
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof TransactionsGet200Response
     */
    'data'?: Array<Transaction>;
    /**
     * 
     * @type {string}
     * @memberof TransactionsGet200Response
     */
    'head'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionsGet200Response
     */
    'link'?: string;
    /**
     * 
     * @type {Paging}
     * @memberof TransactionsGet200Response
     */
    'paging'?: Paging;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches an array of objects with a status and id for each batch requested. There are four possible statuses with string values `\'COMMITTED\'`, `\'INVALID\'`, `\'PENDING\'`, and `\'UNKNOWN\'`.  The batch(es) you want to check can be specified using the `id` filter parameter. If a `wait` time is specified in the URL, the API will wait to respond until all batches are committed, or the time in seconds has elapsed. If the value of `wait` is not set (i.e., `?wait&id=...`), or it is set to any non-integer value other than `false`, the wait time will be just under the API\'s specified timeout (usually 300).  Note that because this route does not return full resources, the response will not be paginated, and there will be no `head` or `paging` properties. 
         * @summary Fetches the committed statuses for a set of batches
         * @param {string} id A comma-separated list of batch ids
         * @param {number} [wait] A time in seconds to wait for commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchStatusesGet: async (id: string, wait?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('batchStatusesGet', 'id', id)
            const localVarPath = `/batch_statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Identical to `GET /batch_statuses`, but takes ids of batches as a JSON formatted POST body rather than a query parameter. This allows for many more batches to be checked and should be used for more than 15 ids.  Note that because query information is not encoded in the URL, no `link` will be returned with this query. 
         * @summary Fetches the committed statuses for a set of batches
         * @param {Array<string>} requestBody A JSON array of batch id strings
         * @param {number} [wait] A time in seconds to wait for commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchStatusesPost: async (requestBody: Array<string>, wait?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('batchStatusesPost', 'requestBody', requestBody)
            const localVarPath = `/batch_statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetches a particular batch
         * @param {string} batchId Batch id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchesBatchIdGet: async (batchId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('batchesBatchIdGet', 'batchId', batchId)
            const localVarPath = `/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a paginated list of batches from the validator. 
         * @summary Fetches a list of batches
         * @param {string} [head] Index or id of head block
         * @param {string} [start] Id to start paging (inclusive)
         * @param {number} [limit] Number of items to return
         * @param {string} [reverse] If the list should be reversed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchesGet: async (head?: string, start?: string, limit?: number, reverse?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (head !== undefined) {
                localVarQueryParameter['head'] = head;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (reverse !== undefined) {
                localVarQueryParameter['reverse'] = reverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts a protobuf formatted `BatchList` as an octet-stream binary file and submits it to the validator to be committed.  The API will return immediately with a status of `202`. There will be no `data` object, only a `link` to a `/batch_statuses` endpoint to be polled to check the status of submitted batches. 
         * @summary Sends a BatchList to the validator
         * @param {BatchList} batchList A binary encoded protobuf BatchList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchesPost: async (batchList: BatchList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchList' is not null or undefined
            assertParamExists('batchesPost', 'batchList', batchList)
            const localVarPath = `/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetches a particular block
         * @param {string} blockId Block id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksBlockIdGet: async (blockId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('blocksBlockIdGet', 'blockId', blockId)
            const localVarPath = `/blocks/{block_id}`
                .replace(`{${"block_id"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a paginated list of blocks from the validator. 
         * @summary Fetches a list of blocks
         * @param {string} [head] Index or id of head block
         * @param {string} [start] Id to start paging (inclusive)
         * @param {number} [limit] Number of items to return
         * @param {string} [reverse] If the list should be reversed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksGet: async (head?: string, start?: string, limit?: number, reverse?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (head !== undefined) {
                localVarQueryParameter['head'] = head;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (reverse !== undefined) {
                localVarQueryParameter['reverse'] = reverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetches the endpoints of the authorized peers of the validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/peers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches an array of objects for each receipt requested.  The receipt(s) you want to retrieve can be specified using the `id` filter parameter, where `id` refers to the transaction id of the transaction the receipt is associated with. 
         * @summary Fetches the receipts for a set of transactions
         * @param {string} id A comma-separated list of transaction ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptsGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('receiptsGet', 'id', id)
            const localVarPath = `/receipts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Identical to `GET /receipts`, but takes ids of transactions as a JSON formatted POST body rather than a query parameter. This allows for many more receipts to be fetched and should be used with more than 15 ids.  Note that because query information is not encoded in the URL, no `link` will be returned with this request. 
         * @summary Fetches the receipts for a set of transactions
         * @param {Array<string>} requestBody A JSON array of transaction id strings
         * @param {number} [wait] A time in seconds to wait for commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptsPost: async (requestBody: Array<string>, wait?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('receiptsPost', 'requestBody', requestBody)
            const localVarPath = `/receipts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes full 70-character address and fetches a particular leaf. For partial address (i.e., group of leaves) use `/state` above.  
         * @summary Fetches a particular leaf from the current state
         * @param {string} address Radix address of a leaf
         * @param {string} [head] Index or id of head block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stateAddressGet: async (address: string, head?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('stateAddressGet', 'address', address)
            const localVarPath = `/state/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (head !== undefined) {
                localVarQueryParameter['head'] = head;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a paginated list of entries for the current state, or relative to a particular head block. Using the `address` filter parameter will narrow the list to any entries that have an address beginning with the characters specified. Note that the partial address in `address` parameter should have even  number of hexadecimal characters (i.e., complete bytes). 
         * @summary Fetches the data for the current state
         * @param {string} [head] Index or id of head block
         * @param {string} [address] A partial address to filter leaves by
         * @param {string} [start] Id to start paging (inclusive)
         * @param {number} [limit] Number of items to return
         * @param {string} [reverse] If the list should be reversed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stateGet: async (head?: string, address?: string, start?: string, limit?: number, reverse?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (head !== undefined) {
                localVarQueryParameter['head'] = head;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (reverse !== undefined) {
                localVarQueryParameter['reverse'] = reverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetches information pertaining to the status of the validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a paginated list of transactions from the validator. 
         * @summary Fetches a list of transactions
         * @param {string} [head] Index or id of head block
         * @param {string} [start] Id to start paging (inclusive)
         * @param {number} [limit] Number of items to return
         * @param {string} [reverse] If the list should be reversed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet: async (head?: string, start?: string, limit?: number, reverse?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (head !== undefined) {
                localVarQueryParameter['head'] = head;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (reverse !== undefined) {
                localVarQueryParameter['reverse'] = reverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetches a particular transaction
         * @param {string} transactionId Transaction id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsTransactionIdGet: async (transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('transactionsTransactionIdGet', 'transactionId', transactionId)
            const localVarPath = `/transactions/{transaction_id}`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetches an array of objects with a status and id for each batch requested. There are four possible statuses with string values `\'COMMITTED\'`, `\'INVALID\'`, `\'PENDING\'`, and `\'UNKNOWN\'`.  The batch(es) you want to check can be specified using the `id` filter parameter. If a `wait` time is specified in the URL, the API will wait to respond until all batches are committed, or the time in seconds has elapsed. If the value of `wait` is not set (i.e., `?wait&id=...`), or it is set to any non-integer value other than `false`, the wait time will be just under the API\'s specified timeout (usually 300).  Note that because this route does not return full resources, the response will not be paginated, and there will be no `head` or `paging` properties. 
         * @summary Fetches the committed statuses for a set of batches
         * @param {string} id A comma-separated list of batch ids
         * @param {number} [wait] A time in seconds to wait for commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchStatusesGet(id: string, wait?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchStatusesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchStatusesGet(id, wait, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Identical to `GET /batch_statuses`, but takes ids of batches as a JSON formatted POST body rather than a query parameter. This allows for many more batches to be checked and should be used for more than 15 ids.  Note that because query information is not encoded in the URL, no `link` will be returned with this query. 
         * @summary Fetches the committed statuses for a set of batches
         * @param {Array<string>} requestBody A JSON array of batch id strings
         * @param {number} [wait] A time in seconds to wait for commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchStatusesPost(requestBody: Array<string>, wait?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchStatusesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchStatusesPost(requestBody, wait, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetches a particular batch
         * @param {string} batchId Batch id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchesBatchIdGet(batchId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchesBatchIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchesBatchIdGet(batchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a paginated list of batches from the validator. 
         * @summary Fetches a list of batches
         * @param {string} [head] Index or id of head block
         * @param {string} [start] Id to start paging (inclusive)
         * @param {number} [limit] Number of items to return
         * @param {string} [reverse] If the list should be reversed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchesGet(head?: string, start?: string, limit?: number, reverse?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchesGet(head, start, limit, reverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accepts a protobuf formatted `BatchList` as an octet-stream binary file and submits it to the validator to be committed.  The API will return immediately with a status of `202`. There will be no `data` object, only a `link` to a `/batch_statuses` endpoint to be polled to check the status of submitted batches. 
         * @summary Sends a BatchList to the validator
         * @param {BatchList} batchList A binary encoded protobuf BatchList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchesPost(batchList: BatchList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchesPost202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchesPost(batchList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetches a particular block
         * @param {string} blockId Block id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blocksBlockIdGet(blockId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlocksBlockIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blocksBlockIdGet(blockId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a paginated list of blocks from the validator. 
         * @summary Fetches a list of blocks
         * @param {string} [head] Index or id of head block
         * @param {string} [start] Id to start paging (inclusive)
         * @param {number} [limit] Number of items to return
         * @param {string} [reverse] If the list should be reversed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blocksGet(head?: string, start?: string, limit?: number, reverse?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlocksGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blocksGet(head, start, limit, reverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetches the endpoints of the authorized peers of the validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async peersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PeersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.peersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches an array of objects for each receipt requested.  The receipt(s) you want to retrieve can be specified using the `id` filter parameter, where `id` refers to the transaction id of the transaction the receipt is associated with. 
         * @summary Fetches the receipts for a set of transactions
         * @param {string} id A comma-separated list of transaction ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptsGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReceiptsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptsGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Identical to `GET /receipts`, but takes ids of transactions as a JSON formatted POST body rather than a query parameter. This allows for many more receipts to be fetched and should be used with more than 15 ids.  Note that because query information is not encoded in the URL, no `link` will be returned with this request. 
         * @summary Fetches the receipts for a set of transactions
         * @param {Array<string>} requestBody A JSON array of transaction id strings
         * @param {number} [wait] A time in seconds to wait for commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiptsPost(requestBody: Array<string>, wait?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReceiptsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiptsPost(requestBody, wait, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes full 70-character address and fetches a particular leaf. For partial address (i.e., group of leaves) use `/state` above.  
         * @summary Fetches a particular leaf from the current state
         * @param {string} address Radix address of a leaf
         * @param {string} [head] Index or id of head block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stateAddressGet(address: string, head?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StateAddressGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stateAddressGet(address, head, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a paginated list of entries for the current state, or relative to a particular head block. Using the `address` filter parameter will narrow the list to any entries that have an address beginning with the characters specified. Note that the partial address in `address` parameter should have even  number of hexadecimal characters (i.e., complete bytes). 
         * @summary Fetches the data for the current state
         * @param {string} [head] Index or id of head block
         * @param {string} [address] A partial address to filter leaves by
         * @param {string} [start] Id to start paging (inclusive)
         * @param {number} [limit] Number of items to return
         * @param {string} [reverse] If the list should be reversed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stateGet(head?: string, address?: string, start?: string, limit?: number, reverse?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StateGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stateGet(head, address, start, limit, reverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetches information pertaining to the status of the validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a paginated list of transactions from the validator. 
         * @summary Fetches a list of transactions
         * @param {string} [head] Index or id of head block
         * @param {string} [start] Id to start paging (inclusive)
         * @param {number} [limit] Number of items to return
         * @param {string} [reverse] If the list should be reversed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsGet(head?: string, start?: string, limit?: number, reverse?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsGet(head, start, limit, reverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetches a particular transaction
         * @param {string} transactionId Transaction id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionsTransactionIdGet(transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlocksBlockIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsTransactionIdGet(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Fetches an array of objects with a status and id for each batch requested. There are four possible statuses with string values `\'COMMITTED\'`, `\'INVALID\'`, `\'PENDING\'`, and `\'UNKNOWN\'`.  The batch(es) you want to check can be specified using the `id` filter parameter. If a `wait` time is specified in the URL, the API will wait to respond until all batches are committed, or the time in seconds has elapsed. If the value of `wait` is not set (i.e., `?wait&id=...`), or it is set to any non-integer value other than `false`, the wait time will be just under the API\'s specified timeout (usually 300).  Note that because this route does not return full resources, the response will not be paginated, and there will be no `head` or `paging` properties. 
         * @summary Fetches the committed statuses for a set of batches
         * @param {string} id A comma-separated list of batch ids
         * @param {number} [wait] A time in seconds to wait for commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchStatusesGet(id: string, wait?: number, options?: any): AxiosPromise<BatchStatusesGet200Response> {
            return localVarFp.batchStatusesGet(id, wait, options).then((request) => request(axios, basePath));
        },
        /**
         * Identical to `GET /batch_statuses`, but takes ids of batches as a JSON formatted POST body rather than a query parameter. This allows for many more batches to be checked and should be used for more than 15 ids.  Note that because query information is not encoded in the URL, no `link` will be returned with this query. 
         * @summary Fetches the committed statuses for a set of batches
         * @param {Array<string>} requestBody A JSON array of batch id strings
         * @param {number} [wait] A time in seconds to wait for commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchStatusesPost(requestBody: Array<string>, wait?: number, options?: any): AxiosPromise<BatchStatusesPost200Response> {
            return localVarFp.batchStatusesPost(requestBody, wait, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetches a particular batch
         * @param {string} batchId Batch id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchesBatchIdGet(batchId: string, options?: any): AxiosPromise<BatchesBatchIdGet200Response> {
            return localVarFp.batchesBatchIdGet(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a paginated list of batches from the validator. 
         * @summary Fetches a list of batches
         * @param {string} [head] Index or id of head block
         * @param {string} [start] Id to start paging (inclusive)
         * @param {number} [limit] Number of items to return
         * @param {string} [reverse] If the list should be reversed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchesGet(head?: string, start?: string, limit?: number, reverse?: string, options?: any): AxiosPromise<BatchesGet200Response> {
            return localVarFp.batchesGet(head, start, limit, reverse, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts a protobuf formatted `BatchList` as an octet-stream binary file and submits it to the validator to be committed.  The API will return immediately with a status of `202`. There will be no `data` object, only a `link` to a `/batch_statuses` endpoint to be polled to check the status of submitted batches. 
         * @summary Sends a BatchList to the validator
         * @param {BatchList} batchList A binary encoded protobuf BatchList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchesPost(batchList: BatchList, options?: any): AxiosPromise<BatchesPost202Response> {
            return localVarFp.batchesPost(batchList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetches a particular block
         * @param {string} blockId Block id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksBlockIdGet(blockId: string, options?: any): AxiosPromise<BlocksBlockIdGet200Response> {
            return localVarFp.blocksBlockIdGet(blockId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a paginated list of blocks from the validator. 
         * @summary Fetches a list of blocks
         * @param {string} [head] Index or id of head block
         * @param {string} [start] Id to start paging (inclusive)
         * @param {number} [limit] Number of items to return
         * @param {string} [reverse] If the list should be reversed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksGet(head?: string, start?: string, limit?: number, reverse?: string, options?: any): AxiosPromise<BlocksGet200Response> {
            return localVarFp.blocksGet(head, start, limit, reverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetches the endpoints of the authorized peers of the validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peersGet(options?: any): AxiosPromise<PeersGet200Response> {
            return localVarFp.peersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches an array of objects for each receipt requested.  The receipt(s) you want to retrieve can be specified using the `id` filter parameter, where `id` refers to the transaction id of the transaction the receipt is associated with. 
         * @summary Fetches the receipts for a set of transactions
         * @param {string} id A comma-separated list of transaction ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptsGet(id: string, options?: any): AxiosPromise<ReceiptsGet200Response> {
            return localVarFp.receiptsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Identical to `GET /receipts`, but takes ids of transactions as a JSON formatted POST body rather than a query parameter. This allows for many more receipts to be fetched and should be used with more than 15 ids.  Note that because query information is not encoded in the URL, no `link` will be returned with this request. 
         * @summary Fetches the receipts for a set of transactions
         * @param {Array<string>} requestBody A JSON array of transaction id strings
         * @param {number} [wait] A time in seconds to wait for commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiptsPost(requestBody: Array<string>, wait?: number, options?: any): AxiosPromise<ReceiptsGet200Response> {
            return localVarFp.receiptsPost(requestBody, wait, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes full 70-character address and fetches a particular leaf. For partial address (i.e., group of leaves) use `/state` above.  
         * @summary Fetches a particular leaf from the current state
         * @param {string} address Radix address of a leaf
         * @param {string} [head] Index or id of head block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stateAddressGet(address: string, head?: string, options?: any): AxiosPromise<StateAddressGet200Response> {
            return localVarFp.stateAddressGet(address, head, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a paginated list of entries for the current state, or relative to a particular head block. Using the `address` filter parameter will narrow the list to any entries that have an address beginning with the characters specified. Note that the partial address in `address` parameter should have even  number of hexadecimal characters (i.e., complete bytes). 
         * @summary Fetches the data for the current state
         * @param {string} [head] Index or id of head block
         * @param {string} [address] A partial address to filter leaves by
         * @param {string} [start] Id to start paging (inclusive)
         * @param {number} [limit] Number of items to return
         * @param {string} [reverse] If the list should be reversed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stateGet(head?: string, address?: string, start?: string, limit?: number, reverse?: string, options?: any): AxiosPromise<StateGet200Response> {
            return localVarFp.stateGet(head, address, start, limit, reverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetches information pertaining to the status of the validator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: any): AxiosPromise<StatusGet200Response> {
            return localVarFp.statusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a paginated list of transactions from the validator. 
         * @summary Fetches a list of transactions
         * @param {string} [head] Index or id of head block
         * @param {string} [start] Id to start paging (inclusive)
         * @param {number} [limit] Number of items to return
         * @param {string} [reverse] If the list should be reversed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(head?: string, start?: string, limit?: number, reverse?: string, options?: any): AxiosPromise<TransactionsGet200Response> {
            return localVarFp.transactionsGet(head, start, limit, reverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetches a particular transaction
         * @param {string} transactionId Transaction id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsTransactionIdGet(transactionId: string, options?: any): AxiosPromise<BlocksBlockIdGet200Response> {
            return localVarFp.transactionsTransactionIdGet(transactionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Fetches an array of objects with a status and id for each batch requested. There are four possible statuses with string values `\'COMMITTED\'`, `\'INVALID\'`, `\'PENDING\'`, and `\'UNKNOWN\'`.  The batch(es) you want to check can be specified using the `id` filter parameter. If a `wait` time is specified in the URL, the API will wait to respond until all batches are committed, or the time in seconds has elapsed. If the value of `wait` is not set (i.e., `?wait&id=...`), or it is set to any non-integer value other than `false`, the wait time will be just under the API\'s specified timeout (usually 300).  Note that because this route does not return full resources, the response will not be paginated, and there will be no `head` or `paging` properties. 
     * @summary Fetches the committed statuses for a set of batches
     * @param {string} id A comma-separated list of batch ids
     * @param {number} [wait] A time in seconds to wait for commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public batchStatusesGet(id: string, wait?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).batchStatusesGet(id, wait, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Identical to `GET /batch_statuses`, but takes ids of batches as a JSON formatted POST body rather than a query parameter. This allows for many more batches to be checked and should be used for more than 15 ids.  Note that because query information is not encoded in the URL, no `link` will be returned with this query. 
     * @summary Fetches the committed statuses for a set of batches
     * @param {Array<string>} requestBody A JSON array of batch id strings
     * @param {number} [wait] A time in seconds to wait for commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public batchStatusesPost(requestBody: Array<string>, wait?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).batchStatusesPost(requestBody, wait, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetches a particular batch
     * @param {string} batchId Batch id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public batchesBatchIdGet(batchId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).batchesBatchIdGet(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a paginated list of batches from the validator. 
     * @summary Fetches a list of batches
     * @param {string} [head] Index or id of head block
     * @param {string} [start] Id to start paging (inclusive)
     * @param {number} [limit] Number of items to return
     * @param {string} [reverse] If the list should be reversed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public batchesGet(head?: string, start?: string, limit?: number, reverse?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).batchesGet(head, start, limit, reverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts a protobuf formatted `BatchList` as an octet-stream binary file and submits it to the validator to be committed.  The API will return immediately with a status of `202`. There will be no `data` object, only a `link` to a `/batch_statuses` endpoint to be polled to check the status of submitted batches. 
     * @summary Sends a BatchList to the validator
     * @param {BatchList} batchList A binary encoded protobuf BatchList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public batchesPost(batchList: BatchList, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).batchesPost(batchList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetches a particular block
     * @param {string} blockId Block id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blocksBlockIdGet(blockId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).blocksBlockIdGet(blockId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a paginated list of blocks from the validator. 
     * @summary Fetches a list of blocks
     * @param {string} [head] Index or id of head block
     * @param {string} [start] Id to start paging (inclusive)
     * @param {number} [limit] Number of items to return
     * @param {string} [reverse] If the list should be reversed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blocksGet(head?: string, start?: string, limit?: number, reverse?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).blocksGet(head, start, limit, reverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetches the endpoints of the authorized peers of the validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public peersGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).peersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches an array of objects for each receipt requested.  The receipt(s) you want to retrieve can be specified using the `id` filter parameter, where `id` refers to the transaction id of the transaction the receipt is associated with. 
     * @summary Fetches the receipts for a set of transactions
     * @param {string} id A comma-separated list of transaction ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public receiptsGet(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).receiptsGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Identical to `GET /receipts`, but takes ids of transactions as a JSON formatted POST body rather than a query parameter. This allows for many more receipts to be fetched and should be used with more than 15 ids.  Note that because query information is not encoded in the URL, no `link` will be returned with this request. 
     * @summary Fetches the receipts for a set of transactions
     * @param {Array<string>} requestBody A JSON array of transaction id strings
     * @param {number} [wait] A time in seconds to wait for commit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public receiptsPost(requestBody: Array<string>, wait?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).receiptsPost(requestBody, wait, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes full 70-character address and fetches a particular leaf. For partial address (i.e., group of leaves) use `/state` above.  
     * @summary Fetches a particular leaf from the current state
     * @param {string} address Radix address of a leaf
     * @param {string} [head] Index or id of head block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stateAddressGet(address: string, head?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).stateAddressGet(address, head, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a paginated list of entries for the current state, or relative to a particular head block. Using the `address` filter parameter will narrow the list to any entries that have an address beginning with the characters specified. Note that the partial address in `address` parameter should have even  number of hexadecimal characters (i.e., complete bytes). 
     * @summary Fetches the data for the current state
     * @param {string} [head] Index or id of head block
     * @param {string} [address] A partial address to filter leaves by
     * @param {string} [start] Id to start paging (inclusive)
     * @param {number} [limit] Number of items to return
     * @param {string} [reverse] If the list should be reversed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stateGet(head?: string, address?: string, start?: string, limit?: number, reverse?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).stateGet(head, address, start, limit, reverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetches information pertaining to the status of the validator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public statusGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).statusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a paginated list of transactions from the validator. 
     * @summary Fetches a list of transactions
     * @param {string} [head] Index or id of head block
     * @param {string} [start] Id to start paging (inclusive)
     * @param {number} [limit] Number of items to return
     * @param {string} [reverse] If the list should be reversed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionsGet(head?: string, start?: string, limit?: number, reverse?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionsGet(head, start, limit, reverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetches a particular transaction
     * @param {string} transactionId Transaction id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionsTransactionIdGet(transactionId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionsTransactionIdGet(transactionId, options).then((request) => request(this.axios, this.basePath));
    }
}


